[{"categories":["MATLAB"],"content":"在进行数据分析时，有时我们会将一系列相关的曲线画到一起进行对比，对于数据存在部分重叠的情况，我们希望临时地将某些曲线隐藏。为了在 MATLAB 中实现这个功能，可以使用 legend 的回调函数。本文将简要讨论这种交互式功能的实现。 ","date":"2024-06-03","objectID":"/legend-callback/:0:0","series":null,"tags":["MATLAB"],"title":"MATLAB 自定义交互式图例","uri":"/legend-callback/#"},{"categories":["MATLAB"],"content":" 图例的回调函数简介回调函数是一类由事件触发的函数，图例的回调函数能够让我们在与图例进行交互时进行一些额外的动作。例如，默认情况下，双击图例的文字部分将触发交互式编辑器，可以对文字内容进行修改。 为了自定义回调函数，首先需要知道该函数的基本格式。我们可以在命令行中运行以下命令查看默认的回调函数以作参考： matlab get(groot, 'factoryLegendItemHitFcn') % 默认回调函数为 defaultItemHitCallback edit('defaultItemHitCallback.m') % 打开默认的回调函数 该回调函数接受两个输入参数，参考 MATLAB 帮助文档中 图例的外观和行为 可知： 第一个参数 hSrc 为被点击的图例对应的函数句柄。换句话说，如果点击的图例对应第三条曲线，则 hSrc 就是第三条曲线的函数句柄； 第二个参数 eventData 是关于事件数据的结构体，其包含如下字段： Peer：被点击的图例对应的函数句柄，与第一个参数 hSrc 相同； Region：点击的位置，可以是 'icon'（曲线形式的图标）或 'label'（曲线的名字）； SelectionType：点击方式，可以是 'normal'（左键单击）、'extend'（中键单击）、'open'（左键双击）等。需要注意的是，双击时，第一次点击会先触发 'normal' 事件，这就意味着交互式功能尽量不要简单地通过单击和双击进行区分，否则会产生意想不到的效果； Source：被点击的 legend 对象； EventName：事件名称，固定为 'ItemHit'。 因此，图例的回调函数应当具有如下的基本模板： matlab function my_legend_callback(hSrc, eventData) % code here end 下面将讨论交互式功能的具体实现。 ","date":"2024-06-03","objectID":"/legend-callback/:1:0","series":null,"tags":["MATLAB"],"title":"MATLAB 自定义交互式图例","uri":"/legend-callback/#图例的回调函数简介"},{"categories":["MATLAB"],"content":" 交互功能设计关于图例的交互，首先我们希望保留默认的编辑功能：左键双击图例文字时可以触发交互式编辑器，因而回调函数中应当保留原始代码： matlab % default case if strcmp(eventData.SelectionType, 'open') \u0026\u0026 strcmp(eventData.Region, 'label') startLabelEditing(hSrc, eventData.Peer); end 此外，希望左键单击图例中的曲线时，如果对应的曲线是可见的，则将其隐藏；反之则将其显示。为此可以读取选中曲线的 Visible 属性，并将其置反即可： matlab % single click to hide/show the selected object if strcmp(eventData.SelectionType, 'normal') \u0026\u0026 strcmp(eventData.Region, 'icon') if strcmp(eventData.Peer.Visible, 'on') eventData.Peer.Visible = 'off'; else eventData.Peer.Visible = 'on'; end end 当曲线比较多，需要批量操作时，可以考虑：中键单击图例中的曲线时，如果有其他曲线可见，则隐藏其他曲线，只保留被选中的曲线；如果只有被选中的曲线可见，则将全部曲线可见。 这个功能稍微有些复杂，因为我们还要找到图例中其他图形元素的句柄。考虑到能够显示在图例中的对象（除了 Line，还有 Patch 等）都有 'DisplayName' 这一参数，因此可以使用 findobj 并配合 '-property' 参数查找具有指定参数的句柄。因而这个功能可以由下面的代码实现： matlab % mid click to show only the selected object or show all if strcmp(eventData.SelectionType, 'extend') \u0026\u0026 strcmp(eventData.Region, 'icon') % get all graphic objects displayed in legend go = findobj(eventData.Peer.Parent, '-property', 'DisplayName'); go_visible = [go.Visible]; if sum(go_visible) == 1 \u0026\u0026 isequal(go(go_visible), eventData.Peer) for k = 1:length(go) go(k).Visible = 'on'; end else for k = 1:length(go) go(k).Visible = 'off'; end eventData.Peer.Visible = 'on'; end end 将上面的代码整合到回调函数模板中，就构成了满足我们需求的回调函数。将其另存为 my_legend_callback.m，绘图之后在创建图例时使用额外的键值对参数 legend(_, 'ItemHitFcn', @my_legend_callback) 指明回调函数，则可以实现图例的交互式操作。 ","date":"2024-06-03","objectID":"/legend-callback/:2:0","series":null,"tags":["MATLAB"],"title":"MATLAB 自定义交互式图例","uri":"/legend-callback/#交互功能设计"},{"categories":["MATLAB"],"content":" 小技巧刚开始接触回调函数时，我们可能并不清楚要求的回调函数具有几个输入参数，也不知道各个输出参数是什么。除了查看帮助文档外，我们可以构建一个临时的回调函数，利用 assignin 将输入参数强行输出到工作空间： matlab function test_callback(varargin) fprintf('Num of variables: %d\\n', nargin); for k = 1:nargin assignin('base', ['var', num2str(k)], varargin{k}) end end 当触发该回调函数时，命令行将会输出参数的数量，并按顺序将各个输入参数导出为 var1、var2 等变量。如此做，我们可以非常清楚地了解各个输入参数的形式，并且通过命令行逐步地调试所需的功能。然而需要特别注意的是，assignin 函数会覆盖工作空间的同名变量，因而在函数内部使用 assignin 通常是不推荐的。 另外，如果希望将这种交互式功能保存为默认的行为，可以参考 MATLAB 自定义默认绘图样式，使用 set(groot, 'defaultLegendItemHitFcn', @my_legend_callback) 将自定义的回调函数设为默认值。 最后分享一个完整的示例供大家测试： matlab % Test callback functions of legend % XiaoCY 2024-06-03 %% clear;clc set(groot, 'defaultLegendItemHitFcn', @my_legend_callback) x = linspace(0, 2*pi, 500)'; phi = linspace(0, pi, 5); y = sin(x + phi); figure plot(x,y) legend xlabel('x') ylabel('y') % Now, try to click legend icon with left/mid bottom %% callback function function my_legend_callback(hSrc,eventData) % default case if strcmp(eventData.SelectionType, 'open') \u0026\u0026 strcmp(eventData.Region, 'label') startLabelEditing(hSrc, eventData.Peer); end % single click to hide/show the selected object if strcmp(eventData.SelectionType, 'normal') \u0026\u0026 strcmp(eventData.Region, 'icon') if strcmp(eventData.Peer.Visible, 'on') eventData.Peer.Visible = 'off'; else eventData.Peer.Visible = 'on'; end end % mid click to show only the selected object or show all if strcmp(eventData.SelectionType, 'extend') \u0026\u0026 strcmp(eventData.Region, 'icon') % get all graphic objects displayed in legend % results may contain 'group' object create by 'bode', ignore their children go = findobj(eventData.Peer.Parent, '-property', 'DisplayName'); K = length(go); idx = true(K,1); for k = 1:K if isprop(go(k), 'Children') if isprop(go(k).Children, 'Visible') idx(go == go(k).Children) = false; end end end go = go(idx); go_visible = [go.Visible]; if sum(go_visible) == 1 \u0026\u0026 isequal(go(go_visible), eventData.Peer) for k = 1:length(go) go(k).Visible = 'on'; end else for k = 1:length(go) go(k).Visible = 'off'; end eventData.Peer.Visible = 'on'; end end end ","date":"2024-06-03","objectID":"/legend-callback/:3:0","series":null,"tags":["MATLAB"],"title":"MATLAB 自定义交互式图例","uri":"/legend-callback/#小技巧"},{"categories":["数字信号处理"],"content":"系统的频率响应是控制器设计的重要依据之一，在工程上，我们常使用扫频测试来获得系统的幅频响应和相频响应，以构建经验传递函数（Empirical Transfer Functions）。本文将简要讨论系统频率响应的估计算法。 ","date":"2024-04-06","objectID":"/freqrespest/:0:0","series":null,"tags":["幅频响应","相频响应","经验传递函数"],"title":"系统频率响应估计","uri":"/freqrespest/#"},{"categories":["数字信号处理"],"content":" 基本原理设多输入多输出线性系统的传递函数矩阵为 $H(s)$，则输入与输出信号之间的频域关系可以表示为： $$ \\bm{y}(j\\omega) = H(j\\omega) \\bm{u}(j\\omega) $$ 其中 $\\bm{u}$ 和 $\\bm{y}$ 分别代表系统的输入和输出向量，自变量 $j\\omega$ 显式地表示该变量是傅里叶变换之后的频域表述。由于输入通常是列向量，上式无法直接对 $\\bm{u}$ 求逆来计算传递函数矩阵。因此，首先考虑实值输出与输入之间的互相关函数矩阵 $R_{\\bm{yu}}(t)$，其定义为： $$ R_{\\bm{yu}} (t) = \\bm{y}(t) \\mathop{\\star} \\bm{u}(t) = \\int_{-\\infty}^{\\infty} \\bm{y}(\\tau) \\bm{u}^\\mathrm{T} (\\tau-t) \\,\\mathrm{d}\\tau $$ 进一步可知 $R_{\\bm{yu}}(t)$ 的傅里叶变换为： $$ \\begin{aligned} R_{\\bm{yu}}(j\\omega) \u0026= \\int_{-\\infty}^{\\infty} \\left( \\int_{-\\infty}^{\\infty} \\bm{y}(\\tau) \\bm{u}^\\mathrm{T} (\\tau-t) \\,\\mathrm{d}\\tau \\right) \\mathrm{e}^{-j\\omega t} \\,\\mathrm{d}t \\\\ \u0026=\\int_{-\\infty}^{\\infty} \\bm{y}(\\tau) \\mathrm{e}^{-j\\omega\\tau} \\left( \\int_{-\\infty}^{\\infty} \\bm{u}^\\mathrm{T} (\\tau-t) \\mathrm{e}^{j\\omega(\\tau-t)} \\,\\mathrm{d}\\tau \\right) \\mathrm{e}^{-j\\omega t} \\,\\mathrm{d}t \\\\ \u0026= \\bm{y}(j\\omega) \\bm{u}^\\dag(j\\omega) \\end{aligned} $$ 式中的角标 ${()}^\\dag$ 表示共轭转置。上式给出了信号的互相关函数与其傅里叶变换之间的关系，考虑到系统的传递函数矩阵，最后一个式子可以改写为： $$ \\bm{y}(j\\omega) \\bm{u}^\\dag(j\\omega) = H(j\\omega) \\bm{u}(j\\omega) \\bm{u}^\\dag(j\\omega) $$ 于是系统的经验传递函数可以表述为： $$ \\hat{H}(j\\omega) = \\bm{y}(j\\omega) \\bm{u}^\\dag(j\\omega) \\left( \\bm{u}(j\\omega) \\bm{u}^\\dag(j\\omega) \\right)^{-1} $$ 需要说明的是，这里我们用 $\\hat{H}(j\\omega)$ 表示估计值以区别于实际传递函数，估计的误差一方面来自数据中所包含的噪声，另一方面则来自有限时长下的频谱估计误差。本文将不对这些误差展开讨论。 ","date":"2024-04-06","objectID":"/freqrespest/:1:0","series":null,"tags":["幅频响应","相频响应","经验传递函数"],"title":"系统频率响应估计","uri":"/freqrespest/#基本原理"},{"categories":["数字信号处理"],"content":" 数据处理根据上面的讨论，数据处理时只需要利用快速傅里叶变换（FFT）将数据转化到频域，然后按照公式计算即可。然而，实际情况与理论有所区别： 测量噪声或输入扰动会导致 FFT 算得的频谱存在误差； 数据的采样率通常远大于关注频带的上限，实际计算只需要计算低频部分即可。 因此，在实际处理的时候需要进行一定的平滑处理，最简单的方法就是在频域直接进行加权平均。基本思路如下： 将输入、输出分别进行傅里叶变换转化为频域数据，并计算对应的频率； 根据关注频段设置参考频率 $f_r$，经验传递函数将计算参考频率处的响应； 根据相邻参考频率之间的差值设置频率分辨率 $f_\\mathrm{res}(i) = f_r(i+1) - f_r(i)$。特别地，当差值计算的频率分辨率小于预设的最小分辨率时应当予以修正； 对于任意参考频率 $f_r(i)$，查找频率在 $\\left( f_r(i) - f_\\mathrm{res}(i),\\, f_r(i) + f_\\mathrm{res}(i) \\right)$ 区间内 FFT 的数据点，对其加权后求解对应点的互相关函数值，并进一步按照公式得到频率响应； 整理参考频率和对应的响应，得到经验传递函数。 实际上，这正是 MATLAB 中 spafdr 函数的核心，根据这个思路自编的函数与 MATLAB 原生程序的对比如下： 经验传递函数估计结果 matlab % mdl = my_spafdr(y, u, f, fs) % A simplifed function for MATLAB `spafdr` used for algorithm demonstration % ASSUME: SISO system, meaning that y and u are scalar input (recorded as column vectors) % y --- [column vector] system output % u --- [column vector] system input % fr --- [Hz, column vector] frequency bins where to get system response % fs --- [Hz]sampling frequency % XiaoCY 2024-04-06 %% function mdl = my_spafdr(y, u, fr, fs) % y and u must be the same length, but I don't check here nfft = length(y); % calculate frequecy spectrum Y = fft(y); U = fft(u); f = (0:nfft-1)'/nfft*fs; % calculate frequency resolution fres = [diff(fr); fr(end)-fr(end-1)]; fmin = fs/nfft; fres(fres \u003c fmin) = fmin; % requested frequency resolution must not be less than the valid resolution % calculate cross-correlation and auto-correlation in frequency domain K = length(fr); [Ryu, Ruu] = deal(zeros(K,1)); for k = 1:K % get index of raw spectrum data within requested resolution idx = abs(f - fr(k)) \u003c fres(k); % set weighting function weight = cos((f(idx)-fr(k))/fres(k)*pi/2); % weight = weight / sum(weight); % not necessary here, we will divide this common factor % calculate weight-averaged correlation Ryu(k) = (Y(idx).*conj(U(idx))).'*weight; Ruu(k) = (U(idx).*conj(U(idx))).'*weight; end % get response in frequency domain and convert to frd model resp = Ryu./Ruu; mdl = idfrd(resp, 2*pi*fr, 1/fs); end ","date":"2024-04-06","objectID":"/freqrespest/:2:0","series":null,"tags":["幅频响应","相频响应","经验传递函数"],"title":"系统频率响应估计","uri":"/freqrespest/#数据处理"},{"categories":["控制理论基础"],"content":"线性时不变系统的稳定性可以通过计算极点、绘制奈奎斯特图或伯德图等多种方式进行判定，对于非线性系统，通常采用李雅普诺夫稳定性判据。本文将简要介绍李雅普诺夫直接法，并介绍实践中常用的引理。 ","date":"2024-01-07","objectID":"/lyapunov/:0:0","series":null,"tags":["Lyapunov","直接法"],"title":"李雅普诺夫稳定性简介","uri":"/lyapunov/#"},{"categories":["控制理论基础"],"content":" 基本定义记自洽系统（Autonomous System）的微分方程为： $$ \\dot{\\bm{x}} = f(\\bm{x}), \\quad \\bm{x}(0) = \\bm{x}_0 $$ 设 $f(0)=0$，此时系统将不会发生动态变化，称 $\\bm{x} = 0$ 是该系统的一个平衡点（Equilibrium）。考察系统在平衡点附近邻域的特性：对于任意 $\\varepsilon \u003e 0$，如果存在 $\\delta \u003e 0$，使得当系统的初始状态满足 $\\left\\lVert \\bm{x}_0 \\right\\rVert \u003c \\delta$ 时，在 $t \\ge 0$ 内均有 $\\left\\lVert \\bm{x} \\right\\rVert \u003c \\varepsilon$，则称该平衡点是稳定的（Stable）；进一步，如果随着时间的推移，有 $\\lim_{t \\to \\infty} \\left\\lVert \\bm{x} \\right\\rVert = 0$，则称系统是局部渐进稳定的（Locally Asymptotically Stable）；更进一步，如果对于任意初始状态 $\\bm{x}_0 \\in \\mathbb{R}^n$ 均有 $\\lim_{t \\to \\infty} \\left\\lVert \\bm{x} \\right\\rVert = 0$，则称该平衡点是全局稳定的（Globally Asymptotically Stable）。反之，则称系统是不稳定的（Unstable）。 我们进一步定义正定函数：假设函数 $V(\\bm{x}):\\, \\mathbb{R}^n \\to \\mathbb{R}$ 在某个包含原点的定义域 $\\mathcal{X}$ 内同时满足： $$ \\left\\{\\begin{aligned} V(\\bm{x}) \u0026= 0 ,\\quad \\bm{x} = 0 \\\\ V(\\bm{x}) \u0026\u003e 0 ,\\quad \\bm{x} \\ne 0,\\; \\bm{x} \\in \\mathcal{X} \\end{aligned}\\right. $$ 则称函数 $V(\\bm{x})$ 是正定的（Positive Definite）；如果 $\\mathcal{X} = \\mathbb{R}^n$，则称为全局正定（Globally Positive Definite）。特别地，如果第二个式子只能满足 $V(\\bm{x}) \\ge 0$，则称函数 $V(\\bm{x})$ 为半正定的（Positive Semidefinite）。若将第二个条件改为 $V(\\bm{x})\u003c0$ 或 $V(\\bm{x}) \\le 0$，则分别称函数为负定（Negative Definite） 和半负定（Negative Semidefinite）。 在上面的定义下，我们可以通过李雅普诺夫直接法（又称第二法）来判断平衡点的稳定性：对于自洽系统，如果存在一个连续可微的正定函数 $V(\\bm{x})$，进一步，如果有 $\\dot{V}(\\bm{x})$ 是半负定的，则 $\\bm{x}=0$ 是一个稳定的平衡点；如果 $\\dot{V}(\\bm{x})$ 是负定的，则 $\\bm{x}=0$ 是一个渐进稳定平衡点。相应的函数 $V(\\bm{x})$ 称为李雅普诺夫函数。 下面我们用一个例子来说明李雅普诺夫稳定性判定。 刚体的姿态运动可以使用四元数的微分方程表示为： $$ \\dot{\\mathfrak{q}} = \\frac{1}{2} \\mathfrak{q} \\otimes \\bm{\\omega} = \\frac{1}{2} \\left[ \\begin{gathered} q_0 \\\\ \\bm{q} \\end{gathered} \\right] \\otimes \\left[ \\begin{gathered} 0 \\\\ \\bm{\\omega} \\end{gathered} \\right] = \\frac{1}{2} \\left[ \\begin{gathered} - \\bm{q}^{\\mathrm{T}} \\bm{\\omega} \\\\ q_0 \\bm{\\omega} + \\bm{q} \\times \\bm{\\omega} \\end{gathered} \\right] $$ 其中四元数表示为 $\\mathfrak{q} = [q_0, \\bm{q}] = [q_0, q_1, q_2, q_3]$。考虑反馈的角速度为： $$ \\bm{\\omega} = -K \\mathrm{sign}(q_0) \\bm{q} ,\\quad K\u003e0 $$ 此时姿态运动变为： $$ \\dot{\\mathfrak{q}} = \\frac{1}{2} K \\mathrm{sign}(q_0) \\left[\\begin{gathered} \\bm{q}^{\\mathrm{T}} \\bm{q} \\\\ -q_0 \\bm{q} \\end{gathered}\\right] $$ 可知 $\\mathfrak{q} = [\\pm 1, 0, 0, 0]$ 是系统的平衡点。取正定函数： $$ V(\\mathfrak{q}) = 2 \\left( 1 - \\sqrt{1-\\bm{q}^\\mathrm{T} \\bm{q}} \\right) = 2 \\left( 1 - \\left\\lvert q_0 \\right\\rvert \\right) $$ 可知 $$ \\dot{V}(\\mathfrak{q}) = - 2 \\mathrm{sign}(q_0) \\dot{q}_0 = - K \\bm{q}^{\\mathrm{T}} \\bm{q} $$ 为负定的。因此 $\\mathfrak{q}=[\\pm 1, 0, 0, 0]$ 是渐进稳定的平衡点。这种结合四元数标量符号的反馈策略称为有符号反馈，可用于姿态控制器设计。 ","date":"2024-01-07","objectID":"/lyapunov/:1:0","series":null,"tags":["Lyapunov","直接法"],"title":"李雅普诺夫稳定性简介","uri":"/lyapunov/#基本定义"},{"categories":["控制理论基础"],"content":" 芭芭拉引理实际在构造李雅普诺夫函数时经常会遇到 $\\dot{V}(\\bm{x})$ 是半负定的情况，因而只能判断平衡点是稳定的。为了进一步了解部分状态的收敛特性，需要使用芭芭拉引理（Barbalat’s Lemma）。 假设定义在 $t\\ge 0$ 上的实值函数 $f(t)$ 一致连续（Uniformly Continuous），且满足： $$ \\lim_{T \\to \\infty} \\,\\int_0^T f(t) \\,\\mathrm{d}t \u003c \\infty $$ 则有： $$ \\lim_{t \\to \\infty} f(t) = 0 $$ 其中，函数 $f(t)$ 一致连续是指： $\\forall \\varepsilon \u003e 0$，$\\exist \\delta \u003e 0$，使得 $\\forall \\left\\lvert t_1 - t_2 \\right\\rvert \u003c \\delta$ 时恒有 $\\left\\lvert f(t_1) - f(t_2) \\right\\rvert \u003c \\varepsilon$。函数的一致连续性可以通过判断其导数是否有界来判定，对于实际的物理系统，状态的一致连续性通常都是可以保证的。 在判断平衡点稳定性的时候，更常用的是芭芭拉引理的推论：如果标量函数 $V(\\bm{x})$ 同时满足（1）$V(\\bm{x})$ 存在下界；（2）$\\dot{V}(\\bm{x})$ 是半负定的；（3）$\\dot{V}(\\bm{x})$ 关于时间一致连续。则有 $\\lim_{t \\to \\infty} \\dot{V}(\\bm{x}) = 0$。 我们可以用下面一阶系统的模型参考自适应控制（MRAC：Model Reference Adaptive Control）来说明芭芭拉引理的应用。 设一阶系统的微分方程为： $$ \\dot{y} = -a y + b u , \\quad a \u003e 0 $$ 其中 $u$ 和 $y$ 分别为系统的输入、输出，$a$ 和 $b$ 是未知的系统参数。给定参考模型为： $$ \\dot{y}_m = -a_m y_m + b_m u_m ,\\quad a_m \u003e 0 $$ 其中 $a_m$ 和 $b_m$ 为已知参数。假设被控对象的控制指令为： $$ u = \\theta_1 u_m - \\theta_2 y $$ 且定义系统输出与参考模型输出的误差为： $$ e = y - y_m $$ 于是有： $$ \\dot{e} = -a_m e - \\left( b \\theta_2 + a - a_m \\right) y + \\left( b\\theta_1 - b_m \\right) u_m $$ 理想情况下，我们希望被控对象与参考模型完全对齐，即 $y = y_m$、$b\\theta_1 = b_m$、$b\\theta_2 = a_m - a$，因此 $\\theta_1$ 和 $\\theta_2$ 也应当自适应地进行调整。设 $$ V(e,\\theta_1,\\theta_2) = \\frac{1}{2} e^2 + \\frac{1}{2 b \\gamma} \\left( b\\theta_1 - b_m \\right)^2 + \\frac{1}{2 b \\gamma} \\left( b\\theta_2 + a - a_m \\right)^2 , \\quad \\gamma \u003e 0 $$ 则有： $$ \\dot{V}(e,\\theta_1,\\theta_2) = -a_m e^2 + \\frac{1}{\\gamma} \\left( b \\theta_1 - b_m \\right) \\left( \\dot{\\theta}_1 + \\gamma u_m e \\right) + \\frac{1}{\\gamma} \\left( b\\theta_2 + a-a_m \\right)\\left( \\dot{\\theta}_2 - \\gamma y e \\right) $$ 如果取自适应律为： $$ \\left\\{\\begin{aligned} \\dot{\\theta}_1 \u0026= - \\gamma u_m e \\\\ \\dot{\\theta}_2 \u0026= \\gamma y e \\end{aligned}\\right. $$ 则 $\\dot{V}(e,\\theta_1,\\theta_2) = e^2/2$ 是半负定的。利用李雅普诺夫稳定性判据只能知道 $e=0$ 是个稳定的平衡点，即误差是有界的。 对于实际的物理系统，状态及其微分都可以满足一致连续的条件，因此根据芭芭拉引理的推论，可知 $\\lim_{t \\to \\infty}\\dot{V}(e,\\theta_1,\\theta_2) = 0$。因此在给定的自适应律下，可以进一步判定模型的跟踪误差将收敛到 $0$，被控对象的输出将能够理想地跟随参考模型。注意，芭芭拉引理并没有给出参数的收敛特性，因而尽管输出表现了良好的跟随，内部的参数可能并不会收敛到真实值。 ","date":"2024-01-07","objectID":"/lyapunov/:2:0","series":null,"tags":["Lyapunov","直接法"],"title":"李雅普诺夫稳定性简介","uri":"/lyapunov/#芭芭拉引理"},{"categories":["控制理论基础"],"content":" 拉萨尔不变性原理在某些场景下，我们只能得到半负定的李雅普诺夫函数，而根据直觉经验系统应当是渐进稳定的。为了证明系统的稳定性，需要引入拉萨尔不变性原理（LaSalle’s Invariance Principle）： 设 $\\bm{x}=0$ 是自洽系统 $ \\dot{\\bm{x}} = f(\\bm{x})$ 的一个平衡点，标量函数 $V(\\bm{x})$ 是正定的，且 $\\dot{V}(\\bm{x}) \\ne 0$。记 $\\mathcal{I}$ 为所有满足 $\\dot{V}(\\bm{x})=0$ 的完整状态轨迹的集合。如果 $\\mathcal{I}$ 除了平衡点 $\\bm{x}=0$ 外不包含任何其他轨迹，则系统渐进稳定。 下面我们使用维基百科上经典的单摆系统来阐述拉萨尔不变性原理的应用。 带阻尼的单摆系统可以由如下微分方程进行描述： $$ ml \\ddot{\\theta} = - mg \\sin \\theta - kl \\dot{\\theta} $$ 取状态变量 $x_1=\\theta$、$x_2 = \\dot{\\theta}$，则系统的状态空间方程可写为： $$ \\left\\{\\begin{aligned} \\dot{x}_1 \u0026= x_2 \\\\ \\dot{x}_2 \u0026= - \\frac{g}{l} \\sin x_1 - \\frac{k}{m} x_2 \\end{aligned}\\right. ,\\quad \\bm{x}(0) = \\begin{bmatrix} \\theta_0 \\\\ \\dot{\\theta}_0 \\end{bmatrix} $$ 取正定函数： $$ V(x_1, x_2) = \\frac{g}{l} \\left( 1-\\cos x_1 \\right) + \\frac{1}{2} x_2^2 $$ 可知其导数为： $$ \\dot{V}(x_1,x_2) = \\frac{g}{l} \\sin x_ 1 \\dot{x}_1 + x_2 \\dot{x}_2 = - \\frac{k}{m} x_2^2 $$ 为半负定函数。进一步，考虑满足 $\\dot{V}(\\bm{x})=0$ 的集合为： $$ \\mathcal{I} = \\left\\{ (x_1, x_2) \\left| \\dot{V}(x_1,x_2) = 0 \\right.\\right\\} = \\left\\{ (x_1, x_2) \\left| x_2=0 \\right. \\right\\} $$ 首先可知平衡点 $\\bm{x} = 0$ 属于集合 $\\mathcal{I}$。为了确认该集合不包含其他轨迹，假设在某一时刻 $t = t_i$ 有 $x_1(t_i) \\ne 0, \\, x_2(t_i) = 0$，代入状态空间方程可知 $\\dot{x}_2(t_i) \\ne 0$，则 $x_2$ 将无法维持为 $0$，轨迹将不在集合 $\\mathcal{I}$ 中。因此集合 $\\mathcal{I}$ 只包含系统的稳定点，进而根据拉萨尔不变性原理可以判定该系统渐进稳定。 ","date":"2024-01-07","objectID":"/lyapunov/:3:0","series":null,"tags":["Lyapunov","直接法"],"title":"李雅普诺夫稳定性简介","uri":"/lyapunov/#拉萨尔不变性原理"},{"categories":["控制理论基础"],"content":" 参考文献 Karl Johan Åström, Björn Wittenmark. Adaptive Control. 2nd Edition. Dover Publications. 2008. Enrico Canuto, Carlo Novara, Luca Massotti, et al. Spacecraft Dynamics and Control: The Embedded Model Control Approach. Butterworth-Heinemann. 2018. Naira Hovakimyan, Chengyu Gao. $\\mathcal{L}_1$ Adaptive Control Theory: Guaranteed Robustness with Fast Adaptation. Society for Industrial and Applied Mathematics. 2010. LaSalle’s invariance principle. Wikipedia. ","date":"2024-01-07","objectID":"/lyapunov/:4:0","series":null,"tags":["Lyapunov","直接法"],"title":"李雅普诺夫稳定性简介","uri":"/lyapunov/#参考文献"},{"categories":["数字信号处理"],"content":"最小二乘法（Least-Squares Method）是一种常用的参数估计方法，本文将介绍最小二乘法的基本原理，并推导其递归形式，讨论时变参数的估计策略。 ","date":"2023-08-26","objectID":"/leastsquare/:0:0","series":null,"tags":["最小二乘法","参数估计"],"title":"最小二乘法与参数估计","uri":"/leastsquare/#"},{"categories":["数字信号处理"],"content":" 最小二乘法考察下式给出的多变量模型： $$ y = \\theta_1\\varphi_1 + \\theta_2\\varphi_2 + \\cdots + \\theta_n \\varphi_n = \\bm{\\varphi}^\\mathrm{T} \\bm{\\theta} $$ 其中，$\\bm{\\theta}^\\mathrm{T} = [\\theta_1,\\,\\theta_2,\\dots,\\theta_n]$ 为模型的参数，$\\bm{\\varphi}^\\mathrm{T} = [\\varphi_1,\\,\\varphi_2,\\,\\dots,\\,\\varphi_n]$ 为一系列已知且相互独立的函数。需要注意的是，$\\bm{\\varphi}$ 可以是关于另一变量的非线性函数，例如 $\\varphi_k = x^{k-1}$ 表示多项式。由于模型关于参数 $\\bm{\\theta}$ 是线性的，为了表述的方便，采用加粗的符号表示列向量，上式最后的等号将模型写成了矩阵的形式。 假设现在进行了 $i$ 次观测，根据模型可以建立方程组： $$ \\underbrace{\\begin{bmatrix} \\varphi_1(1) \u0026 \\varphi_2(1) \u0026 \\cdots \u0026 \\varphi_n(1) \\\\ \\varphi_1(2) \u0026 \\varphi_2(2) \u0026 \\cdots \u0026 \\varphi_n(2) \\\\ \\vdots \u0026 \\vdots \u0026 \u0026 \\vdots \\\\ \\varphi_1(i) \u0026 \\varphi_2(i) \u0026 \\cdots \u0026 \\varphi_n(i) \\\\ \\end{bmatrix}}_{\\Phi(i)} \\underbrace{\\begin{bmatrix} \\theta_1 \\\\ \\theta_2 \\\\ \\vdots \\\\ \\theta_n \\end{bmatrix}}_{\\bm{\\theta}} = \\underbrace{\\begin{bmatrix} y(1) \\\\ y(2) \\\\ \\vdots \\\\ y(i) \\end{bmatrix}}_{Y(i)} $$ 显然，当观测次数 $i \u003c n$ 时，方程数小于变量数，存在多解；当 $i=n$ 且观测相互独立时，上述方程组可以定解；当 $i \u003e n$ 时，由于噪声的存在，方程通常是相互矛盾的，为了对参数 $\\bm{\\theta}$ 进行估计，考虑误差的平方和最小，即： $$ \\hat{\\bm{\\theta}}(i) = \\mathop{\\mathrm{argmin}}\\limits_{\\bm{\\theta}} J(\\bm{\\theta},i) ,\\quad J(\\bm{\\theta},i) = \\frac{1}{2} \\bigl( Y(i) - \\Phi(i) \\bm{\\theta} \\bigr)^\\mathrm{T}\\bigl( Y(i) - \\Phi(i) \\bm{\\theta} \\bigr) $$ 令上式关于 $\\bm{\\theta}$ 的导数为零，可得： $$ \\frac{\\partial J(\\bm{\\theta},i)}{\\partial \\bm{\\theta}} = 0 \\quad \\Rightarrow \\quad \\Phi^\\mathrm{T}(i) \\Phi(i) \\bm{\\theta} = \\Phi^\\mathrm{T} Y(i) $$ 由此可以解得： $$ \\hat{\\bm{\\theta}}(i) = \\bigl( \\Phi^\\mathrm{T}(i) \\Phi(i) \\bigr)^{-1} \\Phi^\\mathrm{T}(i) Y(i) $$ 于是 $\\hat{\\bm{\\theta}}(i)$ 就是参数 $\\bm{\\theta}$ 在 $i$ 次测量下的最小二乘估计。 ","date":"2023-08-26","objectID":"/leastsquare/:1:0","series":null,"tags":["最小二乘法","参数估计"],"title":"最小二乘法与参数估计","uri":"/leastsquare/#最小二乘法"},{"categories":["数字信号处理"],"content":" 递归最小二乘法如果将 $i$ 看作离散时间系统的时间索引（后面将从 0 开始计数），根据上面最小二乘法的表达式可以实时对参数进行估计。为此，我们通常需要将上式转化为递归形式，即递归最小二乘法（Recursive Least-Squares）。 首先考虑将矩阵 $\\Phi^\\mathrm{T}(i)\\Phi(i)$ 进行分解： $$ \\Phi^\\mathrm{T}(i)\\Phi(i) % = \\begin{bmatrix} % \\bm{\\varphi}(1) \u0026 \\bm{\\varphi}(2) \u0026 \\cdots \u0026 \\bm{\\varphi}(i) % \\end{bmatrix} % \\begin{bmatrix} % \\bm{\\varphi}^\\mathrm{T}(1) \\\\ \\bm{\\varphi}^\\mathrm{T}(2) \\\\ \\vdots \\\\ \\bm{\\varphi}^\\mathrm{T}(i) % \\end{bmatrix} = \\sum_{k=0}^i \\bm{\\varphi}(k) \\bm{\\varphi}^\\mathrm{T}(k) = \\Phi^\\mathrm{T}(i-1)\\Phi(i-1) + \\bm{\\varphi}(i) \\bm{\\varphi}^\\mathrm{T}(i) $$ 为了表述的方便，记 $P(i) = \\bigl( \\Phi^\\mathrm{T}(i) \\Phi(i) \\bigr)^{-1}$，上式写为： $$ P^{-1}(i) = P^{-1}(i-1) + \\bm{\\varphi}(i) \\bm{\\varphi}^\\mathrm{T}(i) $$ 于是参数估计可以写成迭代形式： $$ \\begin{aligned} \\hat{\\bm{\\theta}}(i) \u0026= P(i) \\sum_{k=0}^i \\bm{\\varphi}(k) y(k) \\\\ \u0026= P(i) \\left( \\sum_{k=0}^{i-1} \\bm{\\varphi}(k) y(k) + \\bm{\\varphi}(i)y(i) \\right) \\\\ \u0026= P(i) \\left( P^{-1}(i-1) \\hat{\\bm{\\theta}}(i-1) + \\bm{\\varphi}(i) y(i) \\right) \\\\ \u0026= P(i) \\left( \\left( P^{-1}(i) - \\bm{\\varphi}(i) \\bm{\\varphi}^\\mathrm{T}(i) \\right) \\hat{\\bm{\\theta}}(i-1) + \\bm{\\varphi}(i) y(i) \\right) \\\\ \u0026= \\hat{\\bm{\\theta}}(i-1) + \\underbrace{P(i) \\bm{\\varphi}(i)}_{K(i)} \\left( y(i) - \\bm{\\varphi}^\\mathrm{T}(i) \\hat{\\bm{\\theta}}(i-1) \\right) \\end{aligned} $$ 式中 $\\hat{\\bm{\\theta}}(i-1)$ 为参数 $\\bm{\\theta}$ 上一时刻的估计值；$y(i)$ 为当前时刻测量值；$\\bm{\\varphi}(i) \\hat{\\bm{\\theta}}(i-1)$ 是利用当前测量和上一时刻的参数给出的先验估计。 为了得到矩阵 $P(i)$ 的递归形式，进一步考虑矩阵求逆公式： $$ \\left( A + BCD \\right)^{-1} = A^{-1} - A^{-1} B \\left( C^{-1} + D A^{-1}B \\right)^{-1} DA^{-1} $$ 于是有： $$ \\begin{aligned} P(i) \u0026= \\bigl( \\Phi^\\mathrm{T}(i-1)\\Phi(i-1) + \\bm{\\varphi}(i) \\bm{\\varphi}^\\mathrm{T}(i) \\bigr)^{-1} \\\\ \u0026= \\bigl( \\underbrace{P^{-1}(i-1)}_{A} + \\underbrace{\\bm{\\varphi}(i)}_{B} \\underbrace{I}_{C} \\underbrace{\\bm{\\varphi}^\\mathrm{T}(i)}_{D} \\bigr)^{-1} \\\\ \u0026= P(i-1) - P(i-1) \\bm{\\varphi}(i) \\bigl( I + \\bm{\\varphi}^\\mathrm{T}(i) P(i-1) \\bm{\\varphi}(i) \\bigr)^{-1} \\bm{\\varphi}^\\mathrm{T}(i) P(i-1) \\end{aligned} $$ 同时可知： $$ \\begin{aligned} K(i) \u0026= P(i) \\bm{\\varphi}(i) \\\\ \u0026= P(i-1) \\bm{\\varphi}(i) \\left( I - \\bigl( I + \\bm{\\varphi}^\\mathrm{T}(i) P(i-1) \\bm{\\varphi}(i) \\bigr)^{-1} \\bm{\\varphi}^\\mathrm{T}(i) P(i-1) \\bm{\\varphi}(i) \\right) \\\\ \u0026= P(i-1) \\bm{\\varphi}(i)\\bigl( I + \\bm{\\varphi}^\\mathrm{T}(i) P(i-1) \\bm{\\varphi}(i) \\bigr)^{-1} \\end{aligned} $$ 最后一个等号反用了矩阵求逆公式，其中考虑 $A=B=C=I,\\, D=\\bm{\\varphi}^\\mathrm{T}(i) P(i-1) \\bm{\\varphi}(i)$。 综上，递归最小二乘法整理为： $$ \\left\\{\\begin{aligned} \\hat{\\bm{\\theta}}(i) \u0026= \\hat{\\bm{\\theta}}(i-1) + K(i) \\bigl( y(i) - \\bm{\\varphi}^\\mathrm{T}(i) \\hat{\\bm{\\theta}}(i-1) \\bigr) \\\\ K(i) \u0026= P(i-1) \\bm{\\varphi}(i)\\bigl( I + \\bm{\\varphi}^\\mathrm{T}(i) P(i-1) \\bm{\\varphi}(i) \\bigr)^{-1} \\\\ P(i) \u0026= \\bigl( I - K(i) \\bm{\\varphi}^\\mathrm{T}(i) \\bigr) P(i-1) \\end{aligned}\\right. $$ 根据最小二乘法的讨论可知，参数估计至少需要 $n$ 次测量。为了能够使迭代形式在 $i=0$ 时刻就开始运行，通常可以根据先验知识给出估计参数的初值 $\\hat{\\bm{\\theta}}(0)$，并令 $P(0)$ 充分大，通过迭代使其收敛。 提示 递归最小二乘法可以看作如下关于参数 $\\bm{\\theta}$ 系统的 卡尔曼滤波： $$ \\bm{\\theta}(i+1) = \\bm{\\theta}(i) , \\quad y(i) = \\bm{\\varphi}^\\mathrm{T}(i) \\bm{\\theta}(i) + e(i) $$ 其中测量误差 $e(i)$ 为单位高斯白噪声。 ","date":"2023-08-26","objectID":"/leastsquare/:2:0","series":null,"tags":["最小二乘法","参数估计"],"title":"最小二乘法与参数估计","uri":"/leastsquare/#递归最小二乘法"},{"categories":["数字信号处理"],"content":" 时变参数估计如果参数 $\\bm{\\theta}$ 会随着时间发生缓慢的变化，我们在考虑误差可以对最近时刻的测量引入更高的权重。引入指数形式的遗忘因子 $0 \u003c \\lambda \\le 1$，最小二乘法的代价函数变为： $$ J(\\bm{\\theta}, i) = \\frac{1}{2} \\bigl( \\Phi(i) \\bm{\\theta} - Y(i) \\bigr)^\\mathrm{T} \\Lambda(i) \\bigl( \\Phi(i) \\bm{\\theta} - Y(i) \\bigr) = \\frac{1}{2} \\sum_{k=0}^i \\lambda^{i-k} \\left( y(k) - \\bm{\\varphi}^\\mathrm{T}(k) \\bm{\\theta} \\right)^2 $$ 类似地，令代价函数对参数的偏导为零可得： $$ \\frac{\\partial J(\\bm{\\theta},i)}{\\partial \\bm{\\theta}} = 0 \\quad \\Rightarrow \\quad \\Phi^\\mathrm{T}(i) \\Lambda(i) \\Phi(i) \\bm{\\theta} = \\Phi^\\mathrm{T}(i) \\Lambda(i) Y(i) $$ 其中，加权矩阵 $\\Lambda(i)$ 为对角矩阵： $$ \\Lambda(i) = \\begin{bmatrix} \\lambda^{i} \u0026 0 \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 \\lambda^{i-1} \u0026 \\cdots \u0026 0 \\\\ 0 \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 \\lambda^0 \\end{bmatrix} $$ 于是参数估计值为： $$ \\hat{\\bm{\\theta}}(i) = \\bigl( \\Phi^\\mathrm{T}(i) \\Lambda(i) \\Phi(i) \\bigr)^{-1} \\Phi^\\mathrm{T}(i) \\Lambda(i) Y(i) $$ 定义 $P(i) =\\bigl( \\Phi^\\mathrm{T}(i) \\Lambda(i) \\Phi(i) \\bigr)^{-1}$，有： $$ \\begin{aligned} P^{-1}(i) \u0026= \\sum_{k=0}^i \\lambda^{i-k}\\bm{\\varphi}(k) \\bm{\\varphi}^\\mathrm{T}(k) \\\\ \u0026 = \\lambda \\left( \\sum_{k=0}^{i-1} \\lambda^{i-k}\\bm{\\varphi}(k) \\bm{\\varphi}^\\mathrm{T}(k) \\right) + \\bm{\\varphi}(i) \\bm{\\varphi}^\\mathrm{T}(i) \\\\ \u0026= \\lambda P^{-1}(i-1) + \\bm{\\varphi}(i) \\bm{\\varphi}^\\mathrm{T}(i) \\end{aligned} $$ 据此将参数估计写成迭代形式为： $$ \\begin{aligned} \\hat{\\bm{\\theta}}(i) \u0026= P(i) \\sum_{k=0}^{i} \\lambda^{i-k} \\bm{\\varphi}(k) y(k) \\\\ \u0026= P(i) \\left( \\lambda \\sum_{k=0}^{i-1} \\lambda^{i-k} \\bm{\\varphi}(k) y(k) + \\bm{\\varphi}(i) y(i) \\right) \\\\ \u0026= P(i) \\left( \\lambda P^{-1}(i-1) \\hat{\\bm{\\theta}}(i-1) + \\bm{\\varphi}(i)y(i) \\right) \\\\ \u0026= P(i) \\left( \\left( P^{-1}(i) - \\bm{\\varphi}(i) \\bm{\\varphi}^\\mathrm{T}(i) \\right) \\hat{\\bm{\\theta}}(i-1) + \\bm{\\varphi}(i)y(i) \\right) \\\\ \u0026= \\hat{\\bm{\\theta}}(i-1) + \\underbrace{P(i) \\bm{\\varphi}(i)}_{K(i)} \\left( y(i) - \\bm{\\varphi}^\\mathrm{T}(i) \\hat{\\bm{\\theta}}(i-1) \\right) \\end{aligned} $$ 与没有遗忘因子的迭代具有完全相同的形式。进一步根据矩阵求逆公式考虑 $P(i)$ 的递归方程为： $$ P(i) = \\lambda^{-1} P(i-1) - \\lambda^{-1} P(i-1) \\bm{\\varphi}(i) \\left( I + \\bm{\\varphi}^\\mathrm{T}(i) \\lambda^{-1} P(i-1) \\bm{\\varphi}(i) \\right)^{-1} \\bm{\\varphi}^\\mathrm{T}(i) \\lambda^{-1} P(i-1) $$ 进一步有： $$ \\begin{aligned} K(i) \u0026= P(i) \\bm{\\varphi}(i) \\\\ \u0026= \\lambda^{-1} P(i-1) \\bm{\\varphi}(i) \\left( I - \\left( I + \\bm{\\varphi}^\\mathrm{T}(i) \\lambda^{-1} P(i-1) \\bm{\\varphi}(i) \\right)^{-1} \\bm{\\varphi}^\\mathrm{T}(i) \\lambda^{-1} P(i-1) \\right) \\\\ \u0026= \\lambda^{-1} P(i-1) \\left( I + \\bm{\\varphi}^\\mathrm{T}(i) \\lambda^{-1} P(i-1) \\bm{\\varphi}(i) \\right)^{-1} \\\\ \u0026= P(i-1) \\left( \\lambda + \\bm{\\varphi}^\\mathrm{T}(i)P(i-1) \\bm{\\varphi}(i) \\right)^{-1} \\end{aligned} $$ 整理后得到时变参数的最小二乘估计为： $$ \\left\\{\\begin{aligned} \\hat{\\bm{\\theta}}(i) \u0026= \\hat{\\bm{\\theta}}(i-1) + K(i) \\bigl( y(i) - \\bm{\\varphi}^\\mathrm{T}(i) \\hat{\\bm{\\theta}}(i-1) \\bigr) \\\\ K(i) \u0026= P(i-1) \\bm{\\varphi}(i)\\bigl( \\lambda + \\bm{\\varphi}^\\mathrm{T}(i) P(i-1) \\bm{\\varphi}(i) \\bigr)^{-1} \\\\ P(i) \u0026= \\lambda^{-1} \\bigl( I - K(i) \\bm{\\varphi}^\\mathrm{T}(i) \\bigr) P(i-1) \\end{aligned}\\right. $$ ","date":"2023-08-26","objectID":"/leastsquare/:3:0","series":null,"tags":["最小二乘法","参数估计"],"title":"最小二乘法与参数估计","uri":"/leastsquare/#时变参数估计"},{"categories":["数字信号处理"],"content":" 连续时间模型连续时间下，考虑遗忘因子 $\\alpha \\ge 0$，代价函数可以表述为： $$ J(\\bm{\\theta},t) = \\int_0^t \\mathrm{e}^{-\\alpha(t-\\tau)} \\left( y(\\tau) - \\bm{\\varphi}^\\mathrm{T}(\\tau) \\bm{\\theta} \\right)^2 \\, \\mathrm{d}\\tau $$ 相似的推导可以得到连续时间模型的最小二乘估计为： $$ \\left\\{\\begin{aligned} \\frac{\\mathrm{d}\\hat{\\bm{\\theta}}(t)}{\\mathrm{d}t} \u0026= P(t) \\bm{\\varphi}(t) \\left( y(t) - \\bm{\\varphi}^\\mathrm{T}(t) \\hat{\\bm{\\theta}}(t) \\right) \\\\ \\frac{\\mathrm{d}P(t)}{\\mathrm{d}t} \u0026= \\alpha P(t) - P(t) \\bm{\\varphi}(t) \\bm{\\varphi}^\\mathrm{T}(t) P(t) \\end{aligned}\\right. $$ ","date":"2023-08-26","objectID":"/leastsquare/:4:0","series":null,"tags":["最小二乘法","参数估计"],"title":"最小二乘法与参数估计","uri":"/leastsquare/#连续时间模型"},{"categories":["数字信号处理"],"content":" 参考文献 Karl Johan Åström, Björn Wittenmark. Adaptive Control. 2nd Edition. Dover Publications. 2008. ","date":"2023-08-26","objectID":"/leastsquare/:5:0","series":null,"tags":["最小二乘法","参数估计"],"title":"最小二乘法与参数估计","uri":"/leastsquare/#参考文献"},{"categories":["Embedded Model Control"],"content":"依据模型完成状态预测器和控制律设计后，控制器结构基本确定，环路性能将由参数决定。在分离原理的加持下，本文首先讨论理想控制环路和状态预测环路的带宽约束，最后给出极点配置的具体实现。 ","date":"2023-07-22","objectID":"/emc06-poleplacement/:0:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（6）：带宽与极点配置","uri":"/emc06-poleplacement/#"},{"categories":["Embedded Model Control"],"content":" 带宽的标准设计模型嵌入控制由状态预测器、控制律和参考发生器构成，其中参考发生器独立于闭环设计，可以根据实际需求灵活设计，从环路上看来是指令的前置滤波器，因而在闭环的参数设计中不予考虑。根据 模型嵌入控制简介 中给出的系统基本架构，以单输入单输出系统为例，传递函数的形式可以表述为下图所示： 模型嵌入控制系统框图 图中假设模型建模准确，可控动态的传递函数为 $M(z)$；状态预测器中可预测部分扰动的传递函数为 $K_d(z)$、随机噪声部分的传递函数记为 $F_0(z)$；$K(z)$ 将状态反馈折算到嵌入模型的输出端，可以看作是 PD 控制器。 系统框图可以分为三个环路：（1）由 $M(z)$、$F_0(z)$ 和 $K_d(z)$ 构成的状态预测环路；（2）由 $M(z)$ 和 $K(z)$ 构成的理想控制环路；（3）结合被控对象 $M(z)$ 和阴影区的模型嵌入控制构成的完整系统环路。模型嵌入控制希望完整系统环路收敛到状态预测环路。 为了便于环路传递函数的计算，将模型嵌入控制的系统结构等效为如下框图： 模型嵌入控制等效框图 定义理想控制环路的灵敏度函数 $S_c(z)$ 和补灵敏度函数 $V_c(z)$ 分别为： $$ S_c(z) = \\frac{1}{1+M(z)K(z)} ,\\quad V_c(z) = 1 - S_c(z) $$ 类似地，状态预测环路的灵敏度函数 $S_m(z)$ 和补灵敏度函数 $V_m(z)$ 分别为： $$ S_m(z) = \\frac{1}{1+M(z) \\bigl( F_0(z) + K_d(z) \\bigr)} ,\\quad V_m(z) = 1-S_m(z) $$ 根据等效框图，可以得到模型嵌入控制的传递函数（从 $y$ 到 $u$）为： $$ K_{\\mathrm{EMC}}(z) = - \\left( \\frac{V_c(z) F_0(z)}{1 + F_0(z) M(z) S_c(z)} + \\frac{K_d(z)}{1 + F_0(z) M(z) S_c(z)} \\right) = - \\frac{V_c(z) F_0(z) + K_d(z)}{1+F_0(z) M(z) S_c(z)} $$ 于是完整控制环路的灵敏度函数为： $$ S(z) = \\frac{1}{1+K_{\\mathrm{EMC}}(z) M(z)} = S_m(z) + M(z) F_0(z) S_m(z) S_c(z) $$ 为了使 $S(z)$ 收敛于 $S_m(z)$，后一项应当趋近于零。其中，被控对象 $M(z)$ 通常呈现低通的形式，高频增益较小；不可预测的扰动 $F_0(z)$ 根据扰动模型具有固定的形式。因此为了使 $M(z)F_0(z)S_c(z) \\ll S_m(z)$，只能通过 $S_c(z) \\ll S_m(z)$ 实现，这意味着理想控制环路的带宽要远大于状态预测环路的带宽。 另一方面，我们考虑被控对象对参考指令的跟随性能，将跟踪误差做如下分解： $$ \\tilde{\\bm{y}}_r = \\bm{y} - \\bm{y}_r = \\left( \\bm{y} - \\hat{\\bm{y}} \\right) + \\left( \\hat{\\bm{y}}_r - \\bm{y}_r \\right) = \\tilde{\\bm{y}} + C_c \\bm{e}_r $$ 跟踪误差受到状态预测器的预测误差 $\\tilde{\\bm{y}}$ 和测得的跟踪误差 $\\bm{e}_r$ 决定。根据 控制律设计 的讨论，$\\bm{e}_r$ 可以通过理想控制环路进行抑制；考虑 状态预测器设计 所得到的设计方程，为： $$ \\left( I - S_m \\partial H + V_m \\partial P \\right) \\tilde{\\bm{y}} = \\bigl( S_m \\partial H - V_m \\partial P \\bigr) \\left( \\bm{y}_r + C_c \\bm{e}_r \\right) + S_m D_y \\bm{w} - V_m \\bm{w}_m $$ 其中 $\\bm{w}$ 和 $\\bm{w}_m$ 均为外部随机扰动，只能通过状态预测器灵敏度函数和补灵敏度函数的设计进行一定程度的抑制；为了避免跟踪误差通过不确定性 $\\partial H$ 和 $\\partial P$ 影响状态预测误差，希望 $\\bm{e}_r$ 充分小，这又要求理想控制环路的带宽远大于状态预测环路带宽。 ","date":"2023-07-22","objectID":"/emc06-poleplacement/:1:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（6）：带宽与极点配置","uri":"/emc06-poleplacement/#带宽的标准设计"},{"categories":["Embedded Model Control"],"content":" 极点配置具体实现系统的稳定性由闭环极点决定，参数设计的目标是通过调整设计参数将闭环极点分配到合适的位置，从而使闭环性能满足设计需求。为了不失一般性，记 $N$ 阶闭环状态空间方程的状态矩阵为 $A$，其特征多项式为： $$ p_\\lambda(A) = \\bigl\\lvert \\lambda I - A \\bigr\\rvert = \\prod_{k=1}^N \\left( \\lambda - \\lambda_k \\right) $$ 第二个等号说明特征多项式由系统极点 $\\lambda_k$ 构成。对于采样时间为 $T$ 的离散时间系统，其极点 $\\lambda_k$ 与连续时间系统的极点 $s_k=-2\\pi f_k$ 的关系为： $$ \\lambda_k = \\mathrm{e}^{s_kT} = \\mathrm{e}^{-2\\pi f_k T} $$ 定义补极点 $\\gamma_k = 1-\\lambda_k$，当连续时间系统极点对应的频率满足 $2 \\pi f_k T \\ll 1$ 时，有： $$ \\gamma_k = 1 - \\mathrm{e}^{-2\\pi f_k T} \\approx 2 \\pi f_k T $$ 离散时间系统的补极点与连续时间系统的极点具有近似的线性对应关系，具有更好的物理意义。使用补极点代替极点，特征方程可以改写为： $$ p_\\lambda(A) = \\bigl\\lvert \\left( 1-\\gamma \\right) I - A \\bigr\\rvert = \\bigl\\lvert \\left( -\\gamma \\right)I - \\left( A - I \\right) \\bigr\\rvert = p_{(-\\gamma)} (A-I) = \\prod_{k=1}^N \\left( -\\gamma + \\gamma_k \\right) $$ 上式最后的等号指出 $A-I$ 的特征值为补极点的相反数，记为 $\\bar{\\gamma}_k = -\\gamma_k$。由于最后一个等式的成立，实际在配置补极点时并不需要求解高次方程，只需要让特征多项式的系数对应相等即可。借助于 MATLAB 的符号计算，极点配置的核心代码只需要以下三行： matlab coeff1 = charpoly(A-eye(N)); % 计算补极点（相反数）表述下的特征方程 coeff2 = poly(-gamma); % 根据目标补极点构造特征方程 S = solve(coeff1(2:end)==coeff2(2:end); % 根据特征方程系数对应相等进行求解 直接使用这种方法需要注意待调参数的数量与闭环状态数量相等，且环路设计应当取保可控性和客观性。目标补极点 $\\gamma_k$ 通常可以根据等比数列设计为对数均匀的形式，即： $$ \\gamma_k = 2 \\pi f_0 T 2^{-\\alpha \\left( k-1 \\right)} $$ 如此做，控制参数将由 $f_0$ 和 $\\alpha$ 两个参数决定，单独改变 $f_0$ 容易得到近似平移的灵敏度曲线，如下图所示： 极点配置设计的灵敏度和补灵敏度曲线示例 考虑到这种方法希望得到对数均匀分布的极点，在计算资源充分的情况下，我们也可以约束连续时间系统极点对应的最大、最小频率计算特征值 $\\lambda$，然后再借助补极点完成计算。下面折叠的代码给出模型嵌入控制极点配置的参考程序。 matlab % Ploe placement for EMC design % Usage % [Para, A] = xplace(A,p,T); % Required paramters: % A --- state matrix, symbilic matrix % p --- poles or poles bound [Hz] % T --- time unit [s] % Optional paramters: % Method --- place poles based on gamma or lambda, default: 'lambda' % Tunable --- return tunable matrix 'A', default: false % Export --- [WRANING: overwrite] export results to workspace, default: false % Constrain --- extra equations to be used to calculate eigenvalues % % For more information, see \u003ca href=\"https://ichunyu.github.io/helps/functions/xplace\" % \u003eonline documentation\u003c/a\u003e. % XiaoCY 2022-03-31, create this function % XiaoCY 2022-04-01, add parameters % 1. Method: place poles according to 'gamma' or 'lambda'; % 2. Tunable: return matrix A in numerical/generized form; % 3. Overwrite: overwrite variables is workspace; % 4. Check designed parameters; % 5. Add built-in matrix 'A': second-order state feedbcak. % XiaoCY 2022-04-02, change algorithm of method 'lambda'. % XiaoCY 2022-05-31, update parameters and built-in A % 1. add parameter 'Constrains' for extra equations; % 2. add built-in Euler case matrix 'A'. % XiaoCY 2022-09-13, add time unit to output struct. % XiaoCY 2022-11-10, replace 'Overwrite' with 'Export' to make sense. % XiaoCY 2022-11-13, [BREAKING CHANGE] % 1. merge parameters `p1` and `p2` as a single vector `p`; % 2. allow specified poles in `p`. % XiaoCY 2023-04-20, enable 'PrincipalValue' in `solve` %% main function varargout = xplace(varargin) p = inputParser; p.FunctionName = 'xplace'; p.addRequired('A'); p.addRequired('p', @(x)isnumeric(x)); p.addRequired('T', @(x)isnumeric(x)); p.addParameter('Method','lambda'); p.addParameter('Tunable', false); p.addParameter('Overwrite', false); p.addParameter('Export',false); p.addParameter('Constrain',[], @(s)isa(s,'sym')||isempty(s)); p.parse(varargin{:}); [A,cons] = ParseA(p.Results.A); T = p.Results.T; cons = [cons,p.Results.Constrain]; v = symvar(A); N = length(A); if length(v) ~= N + length(cons) error('Numbers of equations and variables don''t fit.') end method = validatestring(p.Results.Method,{'gamma','lambda'}); Np = length(p.Results.p); if strcmp(method, 'gamma') if Np == 1 % all poles are the same f0 = p.Results.p; gamma = 2*pi*f0*T*ones(1,N); elseif Np == 2 % p(1) as first pole, p(2) as exponent coffecient f0 = p.Results.p(1); alpha = p.Results.p(2); gamma = 2*pi*f0*T * 2.^(-alpha*(0:N-1)); elseif Np == N % p(:) are poles f0 = p.Results.p; gamma = 2*pi*f0*T; end else if Np == 1 f0 = p.Results.p; lambda = exp(-","date":"2023-07-22","objectID":"/emc06-poleplacement/:2:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（6）：带宽与极点配置","uri":"/emc06-poleplacement/#极点配置具体实现"},{"categories":["Embedded Model Control"],"content":" 参考文献 E. Canuto, C. Novara, D. Carlucci, et al. Spacecraft Dynamics and Control: The Embedded Model Control Approach. Butterworth-Heinemann. 2018. ","date":"2023-07-22","objectID":"/emc06-poleplacement/:3:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（6）：带宽与极点配置","uri":"/emc06-poleplacement/#参考文献"},{"categories":["Embedded Model Control"],"content":"模型嵌入控制的控制律可以利用预测的状态和扰动实现反馈，此外，利用参考发生器还可以先验地给出前馈指令。本文将对控制律进行具体推导，实现模型嵌入控制的结构设计。 控制系统的核心目标是驱动被控对象的输出跟随参考信号。在状态空间的建模下，我们可以将这种跟随进一步描述为被控对象对参考动态的跟随，具体表现为被控对象与参考动态的跟踪误差 $\\tilde{\\bm{x}}$ 收敛。为此，首先考虑被控对象的状态方程为： $$ \\left\\{\\begin{aligned} \u0026 \\bm{x}_c(i+1) = A_c \\bm{x}_c(i) + B_c \\bigl( \\bm{u}(i) + \\bm{h}(\\bm{x}_c(i)) \\bigr) + H_c \\bm{x}_d(i) + G_c \\bm{w}_c(i) \\\\ \u0026 \\bm{x}_d(i+1) = A_d \\bm{x}_d(i) + G_d \\bm{w}_d(i) \\\\ \u0026 \\bm{y}(i) = C_c \\bm{x}_c(i) + C_d \\bm{x}_d(i) \\end{aligned}\\right. $$ 同时假设参考发生器的状态方程为： $$ \\left\\{\\begin{aligned} \u0026 \\bm{x}_r (i+1) = A_c \\bm{x}_r(i) + B_c \\bm{u}_r(i) \\\\ \u0026 \\bm{y}_r(i) = C_c \\bm{x}_r(i) \\end{aligned}\\right. ,\\quad \\bm{x}_r(0) = \\bm{x}_{r0} $$ 参考发生器中的参考动态 $\\bm{x}_r$ 仅受参考指令 $\\bm{u}_r$ 的驱动，不受到任何外部扰动的影响；此外，参考输出 $\\bm{y}_r$ 仅与参考状态相关，没有引入任何噪声。因此，参考发生器可以看作理想的被控对象，能够提供理想条件下的参考轨迹。参考指令 $\\bm{u}_r$ 可以基于 $\\bm{x}_r$ 采用理想的状态反馈，从而达到给定条件下的最优控制。 考虑到被控对象输出可能受到扰动 $C_d\\bm{x}_d$ 的影响，引入待定参数矩阵 $Q$ 进行修正，定义状态的跟踪误差为： $$ \\tilde{\\bm{x}}_r = \\bm{x}_c - \\bm{x}_r + Q \\bm{x}_d $$ 于是输出的跟踪误差为： $$ \\tilde{\\bm{y}}_r = \\bm{y} - \\bm{y}_r = C_c \\bm{x}_c + C_d \\bm{x}_d - C_c \\bm{x}_r = C_c \\tilde{\\bm{x}}_r + \\left( C_d - C_c Q \\right) \\bm{x}_d $$ 当被控对象跟踪良好时，外部扰动通过控制律补偿，扰动动态 $\\bm{x}_d$ 不应当对输出的跟踪误差产生影响，因此可以得到控制律设计的第一个约束方程： $$ C_d - C_c Q = 0 $$ 进一步，考察跟踪误差 $\\tilde{\\bm{x}}_r$ 的动态方程为： $$ \\tilde{\\bm{x}}_r(i+1) = A_c \\tilde{\\bm{x}}_r(i) + B_c \\bigl( \\bm{u}(i) + \\bm{h}(\\bm{x}_c(i)) - \\bm{u}_r(i) \\bigr) + \\left( H_c + Q A_d - A_c Q \\right) \\bm{x}_d(i) + \\bm{w}_r(i) $$ 其中 $\\bm{w}_r = G_c \\bm{w}_c + Q G_d \\bm{w}_d$ 将扰动动态的随机噪声 $[\\bm{w}_c,\\,\\bm{w}_d]$ 折合到对跟踪误差的扰动，是被控对象对参考信号跟踪性能的限制因素，必须通过控制环路的闭环极点配置进行约束。控制律主要由三部分构成： 状态反馈 $-K \\tilde{\\bm{x}}_r$：状态反馈不仅能够确保状态的跟踪误差收敛，还能通过参数设计实现闭环极点的任意配置，是影响系统性能的关键要素； 参考指令 $\\bm{u}_r$：参考指令能够驱动参考状态跟随目标参考信号，相应地可以作为开环控制指令驱动被控对象以改善系统的动态响应； 扰动补偿 $-\\bm{h}(\\bm{x}_c) - P \\bm{x}_d$：其中 $\\bm{h}(\\bm{x}_c)$ 和 $P \\bm{x}_d$ 分别代表被控对象受到的内部扰动和外部扰动，补偿后可以改善跟踪性能。 综上所述，理想控制律为： $$ \\bm{u}(i) = - K \\tilde{\\bm{x}}_r(i) + \\bm{u}_r(i) - \\bm{h}(\\bm{x}_c(i)) - P \\bm{x}_d(i) $$ 将上式代入跟踪误差的状态方程，得： $$ \\tilde{\\bm{x}}_r(i+1) = \\left( A_c - B_c K \\right) \\tilde{\\bm{x}}_r(i) + \\left( H_c + Q A_d - A_c Q - B_c P \\right) \\bm{x}_d(i) + \\bm{w}_r(i) $$ 考虑外部扰动应当被控制所补偿，令 $\\bm{x}_d$ 的系数矩阵为 $0$，增加约束条件： $$ H_c + Q A_d - A_c Q - B_c P = 0 $$ 结合两个约束条件可以对参数矩阵 $Q$ 和 $P$ 定解；通过对闭环状态矩阵 $A_c-B_c K$ 的极点配置能够实现控制参数 $K$ 设计，理想控制律设计得以完成。在实际设计中，状态真值 $[\\bm{x}_c,\\,\\bm{x}_d]$ 替换为状态预测器给出的预测值 $[\\hat{\\bm{x}}_c,\\,\\hat{\\bm{x}}_d]$。同样地，状态耦合 $\\bm{h}(\\bm{x}_c)$ 也应当替换为相应的标称模型 $\\bm{h}_{\\mathrm{nom}}(\\hat{\\bm{x}}_c)$。于是实际的控制律应当修正为： $$ \\bm{u}(i) = - K \\bm{e}_r(i) + \\bm{u}_r(i) - \\bm{h}_{\\mathrm{nom}}(\\hat{\\bm{x}}_c(i)) - P \\hat{\\bm{x}}_d(i) $$ 其中，标称耦合 $\\bm{h}_{\\mathrm{nom}}(\\hat{\\bm{x}}_c)$ 与实际 $\\bm{h}(\\bm{x}_c)$ 之间的误差将按照参数不确定性处理。实际测得的跟踪误差定义为： $$ \\bm{e}_r = \\hat{\\bm{x}}_c - \\bm{x}_r + Q \\hat{\\bm{x}}_d $$ 响应的状态方程为： $$ \\bm{e}_r(i+1) = \\left( A_c - B_c K \\right) \\bm{e}_r(i) + G_c \\bar{\\bm{w}}_c(i) + QG_d \\bar{\\bm{w}}_d(i) $$ 结合 状态预测器设计 给出的状态预测误差方程，可得全系统的误差动态方程为： $$ \\begin{bmatrix} \\tilde{\\bm{x}}_c(i+1) \\\\ \\tilde{\\bm{x}}_d(i+1) \\\\ -\\bar{\\bm{x}}_n(i+1) \\\\ \\bm{e}_r(i+1) \\end{bmatrix} = \\left[\\begin{array}{ccc:c} A_c-G_cL_cC_c \u0026 H_c-G_cL_cC_d \u0026 G_cN_c \u0026 0 \\\\ -G_dL_dC_c \u0026 A_d-G_dL_dC_d \u0026 G_dN_d \u0026 0\\\\ -L_nC_c \u0026 -L_nC_d \u0026 A_n \u0026 0 \\\\ \\hdashline L_wC_c \u0026 L_wC_d \u0026 -N_w \u0026 A_c - B_c K \\\\ \\end{array}\\right] \\begin{bmatrix} \\tilde{\\bm{x}}_c(i) \\\\ \\tilde{\\bm{x}}_d(i) \\\\ -\\bar{\\bm{x}}_n(i) \\\\ \\bm{e}_r(i) \\end{bmatrix} + \\begin{bmatrix} G_c\\bm{w}_c(i) \\\\ G_d \\bm{w}_d(i) \\\\ 0 \\\\ 0 \\end{bmatrix} $$ 式中 $L_w = G_cL_c + QG_dL_d$，$N_w = G_cN_c + QG_dN_d$。完整误差环路的状态矩阵为下三角矩阵，主对角线分别由状态预测环路的状态矩阵和理想控制环路的状态矩阵组成。因此，当模型准确时，环路设计满足分离定理，状态预测器和控制律能够单独设计。 ","date":"2023-07-17","objectID":"/emc05-controllaw/:0:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（5）：控制律设计","uri":"/emc05-controllaw/#"},{"categories":["Embedded Model Control"],"content":"状态预测器由可控动态、扰动动态和噪声估计器组成，能够对可控动态的状态和扰动进行一步预测。本文将讨论状态预测器的结构设计，并推导不确定性影响下的设计方程。 ","date":"2023-07-16","objectID":"/emc04-statepredictor/:0:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（4）：状态预测器设计","uri":"/emc04-statepredictor/#"},{"categories":["Embedded Model Control"],"content":" 基于模型的状态预测器设计状态预测器设计的核心目标是数字控制器内给出的状态收敛于被控对象的真实状态。考虑到被控对象受到的随机扰动无法完全补偿，设计的目标应当修正为状态预测误差有界。可控动态和扰动动态的状态预测误差分别定义为： $$ \\tilde{\\bm{x}}_c = \\bm{x}_c - \\hat{\\bm{x}}_c, \\quad \\tilde{\\bm{x}}_d = \\bm{x}_d - \\hat{\\bm{x}}_d $$ 根据前面对 被控对象建模 的讨论，离散时间的被控对象状态方程可以写为： $$ \\left\\{\\begin{aligned} \u0026 \\bm{x}_c(i+1) = A_c \\bm{x}_c(i) + B_c \\bigl( \\bm{u}(i) + \\bm{h}(\\bm{x}_c(i)) \\bigr) + H_c \\bm{x}_d(i) + G_c \\bm{w}_c(i) \\\\ \u0026 \\bm{x}_d(i+1) = A_d \\bm{x}_d(i) + G_d \\bm{w}_d(i) \\\\ \u0026 \\bm{y}(i) = C_c \\bm{x}_c(i) + C_d \\bm{x}_d(i) \\end{aligned}\\right. $$ 基于该模型，构造形式相同并实时运行在数字控制器内的数值模型，称为嵌入模型，其状态方程为： $$ \\left\\{\\begin{aligned} \u0026 \\hat{\\bm{x}}_c(i+1) = A_c \\hat{\\bm{x}}_c(i) + B_c \\bigl( \\bm{u}(i) + \\bm{h}_{\\mathrm{nom}}(\\hat{\\bm{x}}_c(i)) \\bigr) + H_c \\hat{\\bm{x}}_d(i) + G_c \\bar{\\bm{w}}_c(i) \\\\ \u0026 \\hat{\\bm{x}}_d(i+1) = A_d \\hat{\\bm{x}}_d(i) + G_d \\bar{\\bm{w}}_d(i) \\\\ \u0026 \\hat{\\bm{y}}(i) = C_c \\hat{\\bm{x}}_c(i) + C_d \\hat{\\bm{x}}_d(i) \\end{aligned}\\right. $$ 嵌入模型的状态由 $\\hat{}$ 标记，表示其可以基于模型进行一步预测；而驱动噪声以 $\\bar{}$ 标记以表示状态预测器只关注驱动噪声当前时刻的估计值。式中 $\\bm{h}(\\bm{x}_c)$ 表示被控对象状态之间由于参数不确定性或非线性引入耦合，嵌入模型中引入 $\\bm{h}_{\\mathrm{nom}}(\\hat{\\bm{x}}_c)$ 表示耦合的标称模型。 被控对象和嵌入模型的状态方程相减，可以得到状态预测误差的动态方程为： $$ \\left\\{\\begin{aligned} \u0026 \\tilde{\\bm{x}}_c(i+1) = A_c \\tilde{\\bm{x}}_c(i) + H_c \\tilde{\\bm{x}}_d(i) + G_c \\bm{w}_c(i) - G_c \\bar{\\bm{w}}_c(i) + B_c \\Delta \\bm{h}(i) \\\\ \u0026 \\tilde{\\bm{x}}_d(i+1) = A_d \\tilde{\\bm{x}}_d(i) + G_d \\bm{w}_d(i) - G_d \\bar{\\bm{w}}_d(i) \\\\ \u0026 \\tilde{\\bm{y}}(i) = C_c \\tilde{\\bm{x}}_c(i) + C_d \\tilde{\\bm{x}}_d(i) \\end{aligned}\\right. $$ 状态预测误差与控制指令 $\\bm{u}$ 无关，会受到 $\\Delta \\bm{h} = \\bm{h}(\\bm{x}_c) - \\bm{h}_{\\mathrm{nom}}(\\hat{\\bm{x}}_c)$ 和驱动噪声 $\\bm{w} = [\\bm{w}_c,\\,\\bm{w}_d]$ 的影响。考虑将 $\\Delta \\bm{h}$ 线性化为： $$ \\Delta \\bm{h} = \\bm{h}_{\\mathrm{nom}}(\\bm{x}_c) + \\tilde{\\bm{h}}(\\bm{x}_c) - \\bm{h}_{\\mathrm{nom}}(\\hat{\\bm{x}}_c) = \\left. \\frac{\\partial \\bm{h}_{\\mathrm{nom}}}{\\partial \\bm{x}} \\right\\rvert_{\\bm{x}=\\hat{\\bm{x}}_c} \\tilde{\\bm{x}}_c + \\tilde{\\bm{h}}(\\bm{x}_c) $$ 其中，第一项的影响在状态预测误差 $\\tilde{\\bm{x}}_c$ 收敛时有界，可以并为随机扰动 $\\bm{w}$ 的影响；第二项 $\\tilde{\\bm{h}}(\\bm{x}_c)$ 是未知的耦合，后面将按照参数不确定性进行讨论。基于模型的环路设计中可以假设 $\\Delta \\bm{h} = 0$，即认为模型准确可知。 分别记可控动态和扰动动态的传递函数矩阵为 $M(z)$ 和 $D(z)$，则状态预测误差的动态可以由下图给出： 状态预测误差动态框图 为了在随机噪声输入下使状态预测误差有界，必须构成稳定的闭环系统。由上图可知，闭环的关键是利用输出的预测误差 $\\tilde{\\bm{y}}$ 对驱动噪声 $\\bar{\\bm{w}} = [\\bar{\\bm{w}}_c ,\\, \\bar{\\bm{w}}_d]$ 进行估计。不失一般性地，构造噪声估计器为： $$ \\left\\{ \\begin{aligned} \u0026 \\bar{\\bm{x}}_n(i+1) = A_n \\bar{\\bm{x}}_n(i) + L_n \\tilde{\\bm{y}}(i) \\\\ \u0026 \\bar{\\bm{w}}(i) = \\begin{bmatrix} \\bar{\\bm{w}}_c(i) \\\\ \\bar{\\bm{w}}_d(i) \\end{bmatrix} = \\begin{bmatrix} N_c \\\\ N_d \\end{bmatrix} \\bar{\\bm{x}}_n(i) + \\begin{bmatrix} L_c \\\\ L_d \\end{bmatrix} \\tilde{\\bm{y}}(i) \\end{aligned} \\right. $$ 可控动态和扰动动态分别根据被控对象和外部扰动的基本特征建模，具有特定的结构和标称参数，故状态预测器的待调参数集中在噪声估计器。从极点配置上看，噪声估计器的设计原则是引入合适数量的状态和待调参数，确保状态预测环路的总状态数量和待调参数的数量相同，从而可以对极点进行任意配置。 记噪声估计器的传递函数矩阵为 $N(z)$，并采用 不确定性建模 中将扰动折合到输出端的表述，被控对象和状态预测器的环路框图如下图所示。在实际应用中，输入到状态预测器的是传感器的测量值 $\\breve{\\bm{y}}$，因此用于噪声估计的误差由预测误差 $\\tilde{\\bm{y}}$ 变更为测得的模型误差 $\\bm{e}_m$。 被控对象和状态预测环路 ","date":"2023-07-16","objectID":"/emc04-statepredictor/:1:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（4）：状态预测器设计","uri":"/emc04-statepredictor/#基于模型的状态预测器设计"},{"categories":["Embedded Model Control"],"content":" 基于不确定行的设计约束根据上图给出的环路结构，省略 $z$ 变换后的自变量，被控对象的输出和传感器测量值分别为： $$ \\bm{y} = M \\bm{u} + \\bm{d}_y ,\\quad \\breve{\\bm{y}} = \\bm{y} + \\tilde{\\bm{y}}_m $$ 嵌入模型的输出 $\\hat{\\bm{y}}$ 可以根据状态预测器的环路方程计算： $$ \\hat{\\bm{y}} = M \\left( \\bm{u} + D N \\left( \\breve{\\bm{y}} - \\hat{\\bm{y}} \\right) \\right) $$ 设被控对象传递函数矩阵 $M(z)$ 解耦为对角矩阵，状态预测器的灵敏度函数 $S_m(z)$ 和补灵敏度函数 $V_m(z)$ 可定义为： $$ S_m = \\bigl( I + DNM \\bigr)^{-1},\\quad V_m = I - S_m $$ 于是嵌入模型的输出为： $$ \\hat{\\bm{y}} = S_m M \\bm{u} + V_m \\breve{\\bm{y}} $$ 于是嵌入模型的输出可以改写为： $$ \\hat{\\bm{y}} = S_m \\left( \\bm{y} - \\bm{d}_y \\right) + V_m \\left( \\bm{y} + \\tilde{\\bm{y}}_m \\right) = \\bm{y} - S_m \\bm{d}_y + V_m \\tilde{\\bm{y}}_m $$ 移项后可得输出的预测误差为： $$ \\tilde{\\bm{y}} = \\bm{y} - \\hat{\\bm{y}} = S_m \\bm{d}_y - V_m \\tilde{\\bm{y}}_m $$ 根据 不确定性建模 对扰动的简化和上图的示意，代入 $\\bm{d}_y$ 和 $\\tilde{\\bm{y}}_m$ 的具体形式： $$ \\bm{d}_y = D_y \\bm{w} + \\partial H \\bm{y}, \\quad \\tilde{\\bm{y}}_m = \\partial P \\bm{y} + \\bm{w}_m $$ 整理得： $$ \\tilde{\\bm{y}} = \\left( S_m \\partial H - V_m \\partial P \\right) \\bm{y} + S_m D_y \\bm{w} - V_m \\bm{w}_m $$ 该式说明：被控对象受到的外扰 $D_y\\bm{w}$ 可以被状态预测器环路的灵敏度函数 $S_m(z)$ 抑制，但传感器的测量噪声 $\\bm{w}_m$ 会以补灵敏度函数 $V_m(z)$ 的形式影响预测误差。参数不确定性分别以 $S_m(z) \\partial H(z)$ 和 $V_m(z) \\partial P(z)$ 的形式通过输出 $\\bm{y}$ 耦合到预测误差。 在测量噪声的影响下，被控对象输出的真值 $\\bm{y}$ 无法准确得知，利用参考信号和测得的跟踪误差进行改写，即： $$ \\bm{y} = \\hat{\\bm{y}} + \\tilde{\\bm{y}} = \\hat{\\bm{y}} - \\bm{y}_r + \\bm{y}_r + \\tilde{\\bm{y}} = C_c \\bm{e}_r + \\bm{y}_r + \\tilde{\\bm{y}} $$ 式中 $\\bm{e}_r$ 为测得的跟踪误差，将在 控制律设计 中展开讨论。代入上式，可以得到状态预测器设计方程为： $$ \\left( I - S_m \\partial H + V_m \\partial P \\right) \\tilde{\\bm{y}} = \\bigl( S_m \\partial H - V_m \\partial P \\bigr) \\left( \\bm{y}_r + C_c \\bm{e}_r \\right) + S_m D_y \\bm{w} - V_m \\bm{w}_m $$ 预测误差 $\\tilde{\\bm{y}}$ 的敛散性由 $\\left( I- S_m \\partial H + V_m \\partial P \\right)^{-1}$ 的极点决定。由于系统的不确定性使其极点无法准确评估，系统的鲁棒稳定性由下式给出： $$ \\left\\lVert -S_m \\partial H + V_m \\partial P \\right\\rVert_\\infty \\le \\left\\lVert S_m \\partial H \\right\\rVert_\\infty + \\left\\lVert V_m \\partial P \\right\\rVert_\\infty \\le \\eta_m \u003c 1 $$ 其中第一个不等式的防缩使设计更加保守，$\\eta_m^{-1}$ 为状态预测器在不确定性下的增益裕度。 从设计方程可知，预测误差 $\\tilde{\\bm{y}}$ 会受到测得的跟踪误差 $\\bm{e}_r$ 的影响，意味着不确定性会导致状态预测器与控制律之间存在弱耦合。一方面，$\\partial H C_c \\bm{e}_r$ 和 $\\partial P C_c \\bm{e}_r$ 可以分别看作 $D_y \\bm{w}$ 和 $\\bm{w}_m$ 的一部分，作为额外的扰动和测量噪声并通过状态预测器的环路设计进行抑制；另一方面，$\\bm{e}_r$ 可以被控制律约束在充分小的范围，这就要求理想控制环路的带宽大于状态预测环路带宽，，称之为模型嵌入控制的标准设计（Standard Design）。 ","date":"2023-07-16","objectID":"/emc04-statepredictor/:2:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（4）：状态预测器设计","uri":"/emc04-statepredictor/#基于不确定行的设计约束"},{"categories":["Embedded Model Control"],"content":" 示例：二阶系统的状态预测器从上面的推导可以看到，在假设模型准确时，被控对象、嵌入模型和状态预测误差具有相同的状态空间方程，实际设计时通常可以不必再推导状态预测误差的方程，直接基于被控对象模型进行设计。 继续 被控对象建模 示例中二阶系统的设计，其状态预测误差的方程为： $$ \\left\\{\\begin{aligned} \u0026 \\tilde{\\bm{x}}_c(i+1) = \\begin{bmatrix} 1 \u0026 1 \\\\ -\\omega_0^2 T^2 \u0026 1 \\end{bmatrix} \\tilde{\\bm{x}}_c(i) + \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} u + \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\bigl( w_c(i) - \\bar{w}_c(i) \\bigr) \\\\ \u0026 \\tilde{\\bm{x}}_d(i+1) = \\begin{bmatrix} 1 \u0026 1 \\\\ 0 \u0026 1 \\end{bmatrix} \\tilde{\\bm{x}}_d(i) + \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\bigl( \\bm{w}_d(i) - \\bar{\\bm{w}}_d(i) \\bigr) \\\\ \u0026 \\tilde{y}(i) = \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix} \\tilde{\\bm{x}}_c(i) \\end{aligned}\\right. $$ 为了从模型误差 $\\tilde{y}$ 中估计驱动噪声 $\\bar{\\bm{w}} = [\\bar{w}_c,\\,\\bar{\\bm{w}}_d]$，假设噪声估计器为纯增益，即： $$ \\begin{bmatrix} w_c(i) \\\\ w_{d1}(i) \\\\ w_{d2}(i) \\end{bmatrix} = \\begin{bmatrix} l_1 \\\\ l_2 \\\\ l_3 \\end{bmatrix} \\tilde{y}(i) $$ 此时状态预测器将有三个可调参数 $\\{l_1,\\,l_2,\\,l_3\\}$，不能与四个状态变量匹配，因而无法实现极点的任意配置。为此，需要在状态预测器引入扩展状态 $\\bar{x}_n$ 并引入额外的设计参数使可调参数与状态数目匹配。考虑如下状态预测器： $$ \\left\\{\\begin{aligned} \u0026 \\bar{x}_n(i+1) = \\left( 1-\\beta \\right) \\bar{x}_n(i) + \\tilde{y}(i) \\\\ \u0026 \\begin{bmatrix} w_c(i) \\\\ w_{d1}(i) \\\\ w_{d2}(i) \\end{bmatrix} = \\begin{bmatrix} m_0 \\\\ m_1 \\\\ m_2 \\end{bmatrix} \\bar{x}_n(i) + \\begin{bmatrix} l_0 \\\\ 0 \\\\ 0 \\end{bmatrix}\\tilde{y}(i) \\end{aligned}\\right. $$ 此时状态预测器共有五个状态变量，同时具备五个待调参数 $\\{ \\beta, \\, l_0,\\, m_0,\\, m_1,\\, m_2\\}$，可以证明闭环极点任意调整，因而闭环性能可以通过参数调整来满足。该二阶系统的状态预测器环路如下图所示，五个绿色模块为待调参数。 二阶系统状态预测器 ","date":"2023-07-16","objectID":"/emc04-statepredictor/:3:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（4）：状态预测器设计","uri":"/emc04-statepredictor/#示例二阶系统的状态预测器"},{"categories":["Embedded Model Control"],"content":"被控对象模型的各种不确定性会产生模型误差而影响状态预测，为了在设计中考虑不确定性的影响，本文简要介绍鲁棒控制的核心结论，并讨论被控对象的不确定性建模。 ","date":"2023-07-06","objectID":"/emc03-uncertainties/:0:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（3）：不确定性建模","uri":"/emc03-uncertainties/#"},{"categories":["Embedded Model Control"],"content":" 鲁棒控制基础鲁棒控制采用范数的形式对信号和系统进行描述，通过约束最不利情况来实现系统鲁棒性约束。不确定性的建模和考量将采用鲁棒控制的思路，因此先简要补充鲁棒控制的基础知识。 ","date":"2023-07-06","objectID":"/emc03-uncertainties/:1:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（3）：不确定性建模","uri":"/emc03-uncertainties/#鲁棒控制基础"},{"categories":["Embedded Model Control"],"content":" 范数的引入设 $\\bm{x}(t)$ 为定义在 $[0,\\,+\\infty]$ 范围且能量有限的向量信号，为了节约符号，将其傅里叶变化记为 $\\bm{x}(j\\omega)$，$\\mathcal{H}_2$ 范数定义为： $$ \\left\\lVert \\bm{x} \\right\\rVert_2^2 := \\frac{1}{2\\pi} \\int_{-\\infty}^{+\\infty} \\mathrm{trace} \\bigl( \\bm{x}^*(j\\omega) \\bm{x}(j\\omega) \\bigr) \\, \\mathrm{d}\\omega = \\int_0^{+\\infty} \\mathrm{trace} \\bigl( \\bm{x}^*(t) \\bm{x}(t) \\bigr) \\, \\mathrm{d} t $$ 角标 $()^*$ 表示共轭转置。后一个等号指明信号的频域积分与时域积分相等，这个关系称为怕赛瓦尔等式。 特别地，对于一维实数信号 $x(t)$，其 $\\mathcal{H}_2$ 范数为： $$ \\left\\lVert x \\right\\rVert_2^2 = \\frac{1}{2\\pi} \\int_{-\\infty}^{+\\infty} \\left\\lvert x(j\\omega) \\right\\rvert^2 \\, \\mathrm{d} \\omega = \\int_0^{+\\infty} x^2(t) \\, \\mathrm{d} t $$ 第一个等号可以从几何上解释为信号傅里叶变换（取模的平方后）曲线下的面积，而后一个等号可以看作信号的能量。因此 $\\mathcal{H}_2$ 范数实际上是对信号能量的描述。 信号的 $\\mathcal{H}_2$ 范数满足三角不等式，即： $$ \\left\\lVert \\bm{x}_1 + \\bm{x}_2 \\right\\rVert_2 \\le \\left\\lVert \\bm{x}_1 \\right\\rVert_2 + \\left\\lVert \\bm{x}_2 \\right\\rVert_2 $$ 记 $G(j\\omega)$ 为一多输入多输出稳定系统的传递函数矩阵，用 $\\bar{\\sigma}$ 表示矩阵的最大奇异值，则该系统的 $\\mathcal{H}_\\infty$ 范数定义为： $$ \\left\\lVert G \\right\\rVert_\\infty := \\sup_{\\omega \\in \\mathbb{R}} \\bar{\\sigma} \\bigl( G(j\\omega) \\bigr) $$ 对于单输入单输出系统，$\\left\\lVert G \\right\\rVert_\\infty$ 范数为传递函数最大的幅频响应，对应幅频响应的峰值。因此 $\\mathcal{H}_\\infty$ 范数是对系统最不利增益的描述。设 $\\bm{y}(j\\omega) = G(j\\omega) \\bm{x}(j\\omega)$ 为系统的输出，不难看出： $$ \\left\\lVert \\bm{y} \\right\\rVert_2 = \\left\\lVert G \\bm{x} \\right\\rVert_2 \\le \\left\\lVert G \\right\\rVert_\\infty \\left\\lVert \\bm{x} \\right\\rVert_2 $$ ","date":"2023-07-06","objectID":"/emc03-uncertainties/:1:1","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（3）：不确定性建模","uri":"/emc03-uncertainties/#范数的引入"},{"categories":["Embedded Model Control"],"content":" 小增益定理小增益定理为不确定性下的鲁棒性分析提供了数学基础。考虑将任意系统分解为如下图所示的两个稳定的子系统 $M$ 和 $\\Delta$。 系统分解示意图 在图示输入下，容易得到： $$ \\begin{aligned} \\left\\lVert \\bm{e}_1 \\right\\rVert_2 \u0026= \\left\\lVert \\bm{w}_1 + \\bm{y}_2 \\right\\rVert_2 \\\\ \u0026\\le \\left\\lVert \\bm{w}_1 \\right\\rVert_2 + \\left\\lVert \\bm{y}_2 \\right\\rVert_2 \\\\ \u0026\\le \\left\\lVert \\bm{w}_1 \\right\\rVert_2 + \\left\\lVert M \\bm{e}_2 \\right\\rVert_2 \\\\ \u0026\\le \\left\\lVert \\bm{w}_1 \\right\\rVert_2 + \\left\\lVert M \\right\\rVert_\\infty \\left\\lVert \\bm{e}_2 \\right\\rVert_2 \\\\ \u0026\\le \\left\\lVert \\bm{w}_1 \\right\\rVert_2 + \\left\\lVert M \\right\\rVert_\\infty \\left\\lVert \\bm{y}_1 + \\bm{w}_2 \\right\\rVert_2 \\\\ \u0026\\le \\left\\lVert \\bm{w}_1 \\right\\rVert_2 + \\left\\lVert M \\right\\rVert_\\infty \\Bigl( \\left\\lVert \\Delta \\right\\rVert_\\infty \\left\\lVert \\bm{e}_1 \\right\\rVert_2 + \\left\\lVert \\bm{w}_2 \\right\\rVert_2 \\Bigr) \\end{aligned} $$ 当 $\\left\\lVert M \\right\\rVert_\\infty \\left\\lVert \\Delta \\right\\rVert_\\infty\u003c1$ 时，可知： $$ \\bm{e}_1 \\le \\frac{1}{1-\\left\\lVert M \\right\\rVert_\\infty \\left\\lVert \\Delta \\right\\rVert_\\infty} \\Bigl( \\left\\lVert \\bm{w}_1 \\right\\rVert + \\left\\lVert M \\right\\rVert_\\infty \\left\\lVert \\bm{w}_2 \\right\\rVert \\Bigr) $$ 改式说明误差 $\\bm{e}_1$ 的能量有界而不会发散，闭环系统稳定。 因此我们可以得到小增益定理：对于稳定的 $M$ 和 $\\Delta$，如果有： $$ \\left\\lVert M \\right\\rVert_\\infty \\left\\lVert \\Delta \\right\\rVert_\\infty \\le \\eta \u003c 1 $$ 则由 $M$ 和 $\\Delta$ 构成的闭环系统稳定，并记 $\\eta^{-1}$ 为增益裕度。 ","date":"2023-07-06","objectID":"/emc03-uncertainties/:1:2","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（3）：不确定性建模","uri":"/emc03-uncertainties/#小增益定理"},{"categories":["Embedded Model Control"],"content":" 被控对象的不确定性在小增益定理的加持下，对于未知的 $\\Delta$，我们可以将其看作最不利包络（加权函数）$W$ 与形式未知但 $\\mathcal{H}_\\infty$ 范数小于 $1$ 的 $\\delta$ 的组合，即 $\\Delta = W \\delta$。于是 $M$-$\\Delta$ 系统可以分解为 $MW$-$\\delta$，环路稳定性可以根据 $\\left\\lVert MW \\right\\rVert_\\infty$ 判断。因此，不确定性建模的核心在于其传递函数矩阵包络的确定。 ","date":"2023-07-06","objectID":"/emc03-uncertainties/:2:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（3）：不确定性建模","uri":"/emc03-uncertainties/#被控对象的不确定性"},{"categories":["Embedded Model Control"],"content":" 参数不确定我们再次重复 被控对象建模 所讨论的可控动态模型的状态空间方程： $$ \\left\\{\\begin{aligned} \u0026 \\bm{x}_c(i+1) = A_c \\bm{x}_c(i) + B_c \\Bigl( \\bm{u}(i) + \\bm{h}(\\bm{x}_c(i) \\Bigr) + \\bm{d}(i) \\\\ \u0026 \\bm{y}(i) = C_c \\bm{x}_c(i) + C_d \\bm{x}_d(i) \\end{aligned}\\right. $$ 其中 $\\bm{h}(\\cdot)$ 为状态之间的耦合，并记 $M(z) = C_c \\left( zI -A_c \\right)^{-1} B_c$ 为可控动态的传递函数矩阵。 在实际设计中，我们通常将耦合分为可知的部分 $\\bm{h}_{\\mathrm{nom}}(\\cdot)$ 和由不确定参数导致的完全未知的 $\\bm{h}(\\cdot)$，前者可以集成在嵌入模型中以减小模型误差，或者完全忽略以简化设计。 考虑到状态之间的耦合可能是非线性的，为了便于分析，受限考虑将耦合的影响约束在扇形有界的范围内，即寻找矩阵 $H$ 使得： $$ -H^\\mathrm{T} \\bm{x}_c \\le \\bm{h}(\\bm{x}_c) \\le H^\\mathrm{T} \\bm{x}_c $$ 进一步，将状态耦合的折算到输出。使用稳定的传递函数矩阵 $\\varUpsilon(z)$ 表述最不利情况，使耦合满足： $$ \\left\\lVert \\bm{h}(\\bm{x}_c) \\right\\rVert_2 \\le \\left\\lVert H^\\mathrm{T} \\bm{x}_c \\right\\rVert \\le \\left\\lVert \\varUpsilon(z) \\right\\rVert_\\infty \\left\\lVert \\bm{y} \\right\\rVert_2 $$ 参数不确定性对输出的影响为： $$ \\left\\lVert \\bm{h}_y(\\bm{x}_c) \\right\\rVert_2 = \\left\\lVert M(z) \\bm{h}(\\bm{x}_c) \\right\\rVert_2 \\le \\left\\lVert M(z) \\varUpsilon(z) \\right\\rVert_\\infty \\left\\lVert \\bm{y} \\right\\rVert_2 $$ 我们将参数不确定性定义为： $$ \\partial H(z) := M(z) \\varUpsilon (z) $$ 进一步根据考虑到扰动动态为： $$ \\left\\{\\begin{aligned} \u0026\\bm{x}_d(i+1) = A_d \\bm{x}_d(i) + G_d \\bm{w}_d(i) \\\\ \u0026\\bm{d}(i) = H_c \\bm{x}_d(i) + G_c \\bm{w}_c(i) \\end{aligned}\\right. $$ 如果记驱动噪声 $\\bm{w} = [\\bm{w}_c,\\,\\bm{w}_d]$ 到输出的传递函数矩阵为： $$ D_y(z) = \\begin{bmatrix} C_c \u0026 C_d \\end{bmatrix} \\left( zI - \\begin{bmatrix} A_c \u0026 H_c \\\\ 0 \u0026 A_d \\end{bmatrix} \\right)^{-1} \\begin{bmatrix} G_c \u0026 0 \\\\ 0 \u0026 G_d \\end{bmatrix} $$ 则由驱动噪声和参数不确定性对可控动态输出端的总扰动为： $$ \\bm{d}_y = D_y \\bm{w} + \\partial H \\bm{y} $$ ","date":"2023-07-06","objectID":"/emc03-uncertainties/:2:1","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（3）：不确定性建模","uri":"/emc03-uncertainties/#参数不确定"},{"categories":["Embedded Model Control"],"content":" 未建模动态在可控动态建模时会存在未建模动态，这一方面可能是因为我们对模型动态响应认识不充分，另一方面可能是人为地忽略掉部分动态以使设计变的简单。记被控对象真实的传递函数矩阵为 $P(z)$，则未建模动态可以表示为： $$ \\partial P(z) = \\bigl( P(z) - M(z) \\bigr) M^{-1}(z) = P(z) M^{-1}(z) - I $$ 于是模型误差可以写为： $$ \\tilde{\\bm{y}}_m = \\breve{\\bm{y}} - \\bm{y} = P \\bm{u} + \\bm{w}_m - M \\bm{u} = \\partial P \\bm{y} + \\bm{w}_m $$ 式中 $\\bm{w}_m$ 为传感器的测量噪声。 综合上述讨论，参数不确定性和未建模动态与可控动态的关系由下图给出： 可控动态与不确定性 实际应用中可以使用蒙特卡洛仿真来估计 $\\partial H(z)$ 和 $\\partial P(z)$ 的边界供后续设计。 ","date":"2023-07-06","objectID":"/emc03-uncertainties/:2:2","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（3）：不确定性建模","uri":"/emc03-uncertainties/#未建模动态"},{"categories":["Embedded Model Control"],"content":" 参考文献 H. Kwakernaak. Robust control and H∞-optimization—Tutorial paper. Automatica. 29. 255–273. 1993. K. Zhou, J.C. Doyle. Essentials of Robust Control. Prentice Hall. 1998. J.C. Doyle, B.A. Francis, A.R. Tannenbaum. Feedback Control Theory, Courier Corporation. 1990. ","date":"2023-07-06","objectID":"/emc03-uncertainties/:3:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（3）：不确定性建模","uri":"/emc03-uncertainties/#参考文献"},{"categories":["Embedded Model Control"],"content":"被控对象以可控动态为核心，进一步引入了扰动动态，其数值实现称为嵌入模型（Embedded Model），是模型嵌入控制设计的基础。本文针对线性时不变（LTI：Linear Time-Invariant）系统建模，给出可控动态和扰动动态离散时间的状态空间表述。 ","date":"2023-07-03","objectID":"/emc02-plant/:0:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（2）：被控对象建模","uri":"/emc02-plant/#"},{"categories":["Embedded Model Control"],"content":" 可控动态建模可控动态是对被控对象物理特性的描述，我们之前在系统的描述中讨论过线性时不变系统的三种描述方法，在此简要复述为： 微分方程：被控对象的特性通常可以根据一定的物理原理建立微分方程，这是描述系统特性最基本的数学手段； 传递函数（或传递函数矩阵）：系统微分方程的拉普拉斯变换，直接地给出了输入输出关系，是频域设计和分析的依据； 状态空间方程：微分方程的等价描述，由于进一步定义了系统状态而能够对系统进行更加精细的描述。离散形式的状态空间还有给出了数值系统的具体实现。 我们假设读者已经具备连续时间系统的建模能力，设被控对象在连续时间下的状态空间微分方程为： $$ \\left\\{\\begin{aligned} \\dot{\\bm{x}} \u0026= A \\bm{x} + B \\bm{u} \\\\ \\bm{y} \u0026= C \\bm{x} + D \\bm{u} \\end{aligned}\\right. $$ 其中 $\\bm{x}$ 为系统的状态向量，$\\bm{y}$ 为输出，$A$、$B$、$C$、$D$ 分别为状态矩阵、输入矩阵、输出矩阵和直馈矩阵。通常情况下 $D=0$，在后面的讨论中将省略。 可控动态是对被控对象在离散时间下的建模，换言之，需要将上述连续时间的状态空间方程依据采样时间 $T$ 离散化。在一阶近似下，状态微分可以由微分代替，为： $$ \\dot{\\bm{x}} \\approx \\frac{1}{T} \\bigl( \\bm{x}_c(iT+T) - \\bm{x}_c(iT) \\bigr) $$ 记 $\\bm{x}_c$ 为可控动态的状态变量。为了表述的方便，后续离散时间状态变量的索引中将省略采样时间 $T$，改写为 $\\bm{x}_c(iT) \\rightarrow \\bm{x}_c(i)$。如此做，可控动态的状态空间方程为： $$ \\left\\{\\begin{aligned} \u0026 \\bm{x}_c(i+1) = A_c \\bm{x}_c(i) + B_c \\Bigl( \\bm{u}(i) + \\bm{h}(\\bm{x}_c(i)) \\Bigr) + \\bm{d}(i) \\\\ \u0026 \\bm{y}(i) = C_c \\bm{x}_c(i) + C_d \\bm{x}_d(i) \\end{aligned}\\right. $$ 其中，$A_c = I+AT$，$B_c = BT$，$C_c = C$。为了更加准确地对被控对象进行描述，可控动态补充了 $\\bm{h}(\\cdot)$ 以隐式地描述状态之间可能的未知或非线性耦合和输入端扰动 $\\bm{d}$。在一定的情况下（通常是多个传感器同时测量时），状态预测器能够对被控对象输出端的扰动（如传感器零偏）进行预测，因此不失一般性地可以在输出端增加 $C_d \\bm{x}_d$ 以表述该扰动的影响，后面将通过控制律设计对这部分扰动进行补偿。 在连续时间系统的离散化中，如果一阶近似带来较大误差，严格的建模应当从微分方程通解的积分中获得。对于线性时不变系统，状态方程的通解为： $$ \\bm{x}(t) = \\mathrm{e}^{A(t-t_0)} \\bm{x}(t_0) + \\int_{t_0}^t \\mathrm{e}^{A(t-\\tau)} B \\bm{u}(\\tau) \\,\\mathrm{d} \\tau $$ 取 $t_0 = iT$，$t = (i+1)T$，并设在 $iT \\le t \u003c (i+1)T$ 时间内指令 $\\bm{u}(t)$ 保持不变，因此离散后的矩阵为： $$ A_c = \\mathrm{e}^{AT} ,\\quad B_c = \\int_0^T \\mathrm{e}^{A\\tau} B \\, \\mathrm{d} \\tau $$ ","date":"2023-07-03","objectID":"/emc02-plant/:1:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（2）：被控对象建模","uri":"/emc02-plant/#可控动态建模"},{"categories":["Embedded Model Control"],"content":" 扰动动态建模由于扰动具有一定的随机性，扰动动态通常依赖于扰动的统计特性。将扰动看作随机噪声 $\\bm{w}$ 经过扰动动态的输出，于是从频域上可以将扰动动态看作噪声滤波器，其幅频响应与扰动的功率谱密度一致。例如通过某种手段测得外部扰动的功率谱密度呈现 $1/f$ 的特性，意味着扰动动态可以建模为一阶积分器。 此外，如果可预测部分的扰动具有较强的时域特性，例如零偏或者震荡等，可以将扰动在局部时间内看作某个微分方程的解，因此总体扰动可以看作该微分方程的通解。例如对于未知的常值扰动，可以看作微分方程 $\\dot{d} = 0$ 的某一个解，根据微分方程可以将扰动动态建模为一阶积分器。 不失一般性，扰动动态的状态空间方程可以写为： $$ \\left\\{\\begin{aligned} \u0026\\bm{x}_d(i+1) = A_d \\bm{x}_d(i) + G_d \\bm{w}_d(i) \\\\ \u0026\\bm{d}(i) = H_c \\bm{x}_d(i) + G_c \\bm{w}_c(i) \\end{aligned}\\right. $$ 式中 $\\bm{x}_d$ 为扰动动态的状态向量。为了对扰动进行充分的预测，扰动动态的极点（$A_d$ 的特征值）应当分布在单位圆上，这存在两种基本形式： 极点为 $1$：串联积分形式，频域上可以解释为低频扰动的预测，时域上根据积分阶数可以解释为分段常值（一阶积分）、分段线性（二阶积分）扰动等； 共轭极点 $\\mathrm{e}^{j 2\\pi f_0 T}, \\,(f_0 \u003c f_s/2)$：震荡模型，对应呈现周期特性的扰动。 需要说明的是，随机噪声 $\\bm{w}$ 分为扰动动态的驱动噪声 $\\bm{w}_d$ 和直接作用于可控动态的噪声 $\\bm{w}_c$。其中，$\\bm{w}_d$ 驱动扰动动态，基于模型的输出部分 $H_c \\bm{x}_d$ 对应可预测部分的扰动，而 $\\bm{w}_c$ 完全随机而无法预测。 为了进一步解释可预测扰动和不可预测扰动，我们可以考察一个随机游走的例子：考虑有一个正态分布随机数生成器，每生成一次随机数，一个质点就会沿着数轴移动相应的距离。该随机过程可以由 $x(i+1) = x(i) + w(i)$ 描述。假设现在这个质点的坐标值为 $7$，通过数学期望可以得到下一次移动的距离平均为 $0$，当需要对位置进行反馈时，这个值不会提供任何有用的信息，因而说“移动的距离不可预测”；然而，由于位移的均值为 $0$，可以预测下一时刻质点最可能的位置坐标将保持在 $7$，即“下一时刻的位置是可以预测的”。 假设驱动噪声 $\\bm{w} = [\\bm{w}_c,\\,\\bm{w}_d]$ 的各个分量相互独立，对于扰动动态，其状态 $\\bm{x}_d$ 不失一般性地都会受到 $\\bm{w}_d$ 的影响。设计输入扰动 $\\bm{d}$ 时需要考虑扰动的注入点，换句话说，被控对象的哪些状态会受到扰动的影响？因此 $G_c$ 的设计应当根据可控动态的物理条件决定。 ","date":"2023-07-03","objectID":"/emc02-plant/:2:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（2）：被控对象建模","uri":"/emc02-plant/#扰动动态建模"},{"categories":["Embedded Model Control"],"content":" 示例：二阶系统建模我们以单自由度弹簧-质量系统为例展示可控动态和扰动动态的建模。设弹簧的特征角频率为 $\\omega_0$，在控制加速度 $a_u$ 和扰动加速度 $a_d$ 的作用下，质点相对平衡位置的位移 $z$ 的微分方程为： $$ \\ddot{z} + \\omega_0^2 z = a_u + a_d $$ 选取连续时间的状态变量为 $\\bm{x} = [z, \\dot{z}]$，连续时间的状态空间方程可以写为： $$ \\left\\{\\begin{aligned} \\dot{\\bm{x}} \u0026= \\begin{bmatrix} 0 \u0026 1 \\\\ -\\omega_0^2 \u0026 0 \\end{bmatrix} \\bm{x} + \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\left( a_u + a_d \\right) \\\\ y \u0026= \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix} \\bm{x} \\end{aligned}\\right. ,\\quad \\bm{x}(0) = \\bm{x}_0 $$ 如果使用差分近似微分，可控动态的各个系数矩阵可以写为： $$ A_c = I+AT = \\begin{bmatrix} 1 \u0026 T \\\\ -\\omega_0^2 T \u0026 1 \\end{bmatrix} , \\quad B_c = BT = \\begin{bmatrix} 0 \\\\ T \\end{bmatrix} $$ 如果使用积分做准确计算，可控动态的系数矩阵为： $$ \\begin{gathered} A_c = \\mathrm{e}^{AT} = \\begin{bmatrix} \\cos(\\omega_0T) \u0026 \\sin(\\omega_0T)/\\omega_0 \\\\ -\\omega_0 \\sin(\\omega_0T) \u0026 \\cos(\\omega_0T) \\end{bmatrix} \\\\ B_c = \\int_0^T \\mathrm{e}^{A\\tau} B \\, \\mathrm{d} \\tau = \\begin{bmatrix} 2 \\sin^2(\\omega_0T/2) /\\omega_0^2 \\\\ \\sin(\\omega_0T)/\\omega_0 \\end{bmatrix} \\end{gathered} $$ 当 $\\omega_0T \\ll 1$ 且忽略 $T^2$ 项后，两种方法得到的可控动态一致。 实际中，我们希望将数字积分器改为累加器以节约时间步长 $T$ 引入的乘法计算。因此，取可控动态的状态向量为 $\\bm{x}_c = [z, \\dot{z}T]$，可控动态变为： $$ \\left\\{\\begin{aligned} \u0026 \\bm{x}_c(i+1) = \\begin{bmatrix} 1 \u0026 1 \\\\ -\\omega_0^2 T^2 \u0026 1 \\end{bmatrix} \\bm{x}_c(i) + \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} u + \\bm{d}(i) \\\\ \u0026 y(i) = \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix} \\bm{x}_c(i) \\end{aligned}\\right. ,\\quad \\bm{x}_c(0) = \\bm{x}_{c0} $$ 其中 $u = T^2 a_u$ 为数字形式的指令加速度。 假设质点受到的外部扰动时缓变的信号，可以认为具有分段线性特性，因而扰动动态可以取二阶积分器（实际上是累加器），其状态空间方程为： $$ \\left\\{\\begin{aligned} \u0026 \\bm{x}_d(i+1) = \\begin{bmatrix} 1 \u0026 1 \\\\ 0 \u0026 1 \\end{bmatrix} \\bm{x}_d(i) + \\begin{bmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{bmatrix} \\bm{w}_d(i) \\\\ \u0026 \\bm{d}(i) = \\begin{bmatrix} 0 \u0026 0 \\\\ 1 \u0026 0 \\end{bmatrix} \\bm{x}_d(i) + \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} w_c(i) \\end{aligned}\\right. $$ 其中，$\\bm{w}_d$ 的系数矩阵为单位矩阵，意味着驱动噪声 $\\bm{w}_d$ 的两个分量可以分别对扰动状态 $\\bm{x}_d$ 的两个分量产生影响；$\\bm{d}$ 的第一个分量为零，是因为外部扰动时加速度形式，不会直接对质点的速度产生影响；噪声 $w_c$ 表示不可预测的随机扰动加速度。 ","date":"2023-07-03","objectID":"/emc02-plant/:3:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（2）：被控对象建模","uri":"/emc02-plant/#示例二阶系统建模"},{"categories":["Embedded Model Control"],"content":"模型嵌入控制（EMC：Embedded Model Control）是一种基于模型的数字控制器，能够对未知的扰动进行预测与补偿，并使被控对象收敛于控制器内部的嵌入模型，因而具有很好的鲁棒性。本文将简要介绍模型嵌入控制的结构及基本原理，并对常用的符号定义进行归纳。 ","date":"2023-07-02","objectID":"/emc01-introduction/:0:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（1）：简介与符号约定","uri":"/emc01-introduction/#"},{"categories":["Embedded Model Control"],"content":" 模型嵌入控制简介模型嵌入控制基于状态空间进行建模与设计，当建模准确，在分离原理的加持下，闭环系统的环路设计可以分解为状态估计/预测环路和理想控制环路。模型嵌入控制以嵌入模型为核心，构建状态预测器，并基于预测的状态综合控制指令，构成完整的数字控制器。下面我们将对各个组成部分进行介绍。 ","date":"2023-07-02","objectID":"/emc01-introduction/:1:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（1）：简介与符号约定","uri":"/emc01-introduction/#模型嵌入控制简介"},{"categories":["Embedded Model Control"],"content":" 被控对象与嵌入模型基于模型的控制器设计首先需要对被控对象进行建模，在给定输入下，被控对象可能存在不可控的状态，实际建模时主要考虑其中可控状态的建模，相应的模型称为可控动态（Controllable Dynamics）。此外，区分可控动态和被控对象将有利于以后对模型误差的讨论。 如下图所示，蓝色阴影区内表示实际的被控对象，黄色阴影区内表示同时运行的数字计算单元。假设可控动态对被控对象的建模准确，并在数字计算单元内引入相同的可控动态，当两者同时接受相同的控制指令 $\\bm{u}$ 时，被控对象的输出 $\\bm{y}$ 应当与数字单元内可控动态的输出 $\\hat{\\bm{y}}$ 相同。然而，实际的被控对象会受到未知的外部扰动 $\\bm{d}$ 的影响，从而使两个输出之间存在误差。如果将扰动看作被控对象的一部分，那么这一误差可以解释为被控对象建模时忽略了扰动模型而引入的，因此将其称为模型误差，定义为 $\\bm{e}_m = \\bm{y} - \\hat{\\bm{y}}$。 被控对象与嵌入模型示意图 为了减小模型误差，在数字计算单元内进一步引入扰动动态（Disturbance Dynamics），与可控动态一同构成所谓的嵌入模型（Embedded Model）。扰动的建模是将扰动看作随机驱动噪声 $\\bar{\\bm{w}}$ 经过扰动动态后的输出。特别地，被控对象受到的扰动可以分为可预测和不可预测（完全随机）两个部分，前者可以根据扰动的特性进行建模，基于模型进行预测并通过反馈实现补偿；后者只能通过环路特性进行估计，是影响系统性能的主要因素。这将在以后状态预测器设计中详细讨论。 ","date":"2023-07-02","objectID":"/emc01-introduction/:1:1","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（1）：简介与符号约定","uri":"/emc01-introduction/#被控对象与嵌入模型"},{"categories":["Embedded Model Control"],"content":" 状态预测器状态预测的实现依赖于对嵌入模型的驱动噪声 $\\bar{\\bm{w}}$ 的估计。引入噪声估计器从模型误差 $\\bm{e}_m$ 中估计驱动噪声，状态预测环路的基本结构如下图黄色区域所示。 状态预测器结构框图 在以后的讨论中我们将指出：模型嵌入控制的设计结果能够驱动被控对象收敛于嵌入模型，换言之，完整控制环路的灵敏度函数将收敛于状态预测器。因此状态预测环路是模型嵌入控制设计的核心要素。状态预测环路的性能会受到被控对象不确定性的影响，模型嵌入控制将其归纳为四类：（1）初始状态的不确定性：被控对象的初始状态通常是未知的，相较于嵌入模型中人为给定的初始状态存在不确定性；（2）随机扰动：包括被控对象输入端的扰动以及传感噪声对输出的影响；（3）参数不确定性：被控对象的实际参数相较于可控动态建模使用的参数存在不确定性；（4）未建模动态：由于对被控对象的认识不充分，或者为了简化设计而忽略一部分特性，可控动态存在未建模动态。状态预测器的设计需要充分考虑各种不确定性带来的约束。 模型嵌入控制中的状态预测器（State Predictor）与一般控制器中的状态估计器（State Estimator）或着状态观测器（State Observer）具有相似的地位。考虑到数字控制存在单位延时，如下图所示。假设数字控制器的时间步长为 $T$，当其在 $iT$ 时刻接收到测量值 $\\breve{\\bm{y}}(i)$ 后，应当在 $\\tau \u003c T$ 时间内完成计算，并只能在 $(i+1)T$ 时刻输出。为了补偿该延时，必须对状态进行一步预测，并提前一步综合控制指令，因此我们更加倾向于使用状态预测器一词。 数字控制的单位延时 ","date":"2023-07-02","objectID":"/emc01-introduction/:1:2","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（1）：简介与符号约定","uri":"/emc01-introduction/#状态预测器"},{"categories":["Embedded Model Control"],"content":" 模型嵌入控制架构控制律依据状态预测器提供的状态预测值综合得到控制指令。不失一般性地，控制律可以由三个部分构成：（1）状态反馈：这是确保闭环系统稳定的基本条件，同时用于约束随机噪声对闭环性能的影响；（2）扰动补偿：将可预测部分的扰动进行反馈与补偿有利于提高被控对象的抗扰能力；（3）参考跟随：利用参考动态和特定的反馈律构成参考发生器，可以为被控对象提供合适的参考状态和参考指令，参考动态将以状态误差的形式进入控制律以确保被控对象对参考信号进行跟随，而参考指令作为开环指令有利于改善系统的动态过程。模型嵌入控制完整的架构如下图所示。 模型嵌入控制结构示意图 关于译名 在多数中文文章的直译下，“Embedded Model Control” 翻译为“嵌入（式）模型控制”。然而，该算法的提出者 Enrico Canuto 教授在他的博客中将中文名解释为“模型嵌入控制”，本系列文章采用这一译名。 ","date":"2023-07-02","objectID":"/emc01-introduction/:1:3","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（1）：简介与符号约定","uri":"/emc01-introduction/#模型嵌入控制架构"},{"categories":["Embedded Model Control"],"content":" 符号约定为了讨论的便利，本系列文章将采用以下符号约定： 为了不失一般性，粗体小写字母表示矢量，对应多输入多输出系统；普通小写字母表示标量； 相似地位的物理量采用相同的符号，但使用不同的帽子加以区分，使用的帽子有： （不加任何帽子）：除特别定义外表示真值，通常不可知； \\breve $(\\breve{*})$：测量值，对应传感器输出； \\tilde $(\\tilde{*})$：误差或噪声，由定义给出； \\hat $(\\hat{*})$：预测值，由模型给出，可用于控制律； \\bar $(\\bar{*})$：估计值，由反馈决定，只用于状态预测器。 为了排版的方便，正文中行内公式的向量均表示列向量，如 $[\\bm{w}_c ,\\, \\bm{w}_d]$。作为对比，其严格的数学写法应当为 $[\\bm{w}_c^\\mathrm{T},\\,\\bm{w}_d^\\mathrm{T}]^\\mathrm{T}$。 为了便于系数矩阵的检索，通常情况下，可控动态的线性状态空间方程写为： $$ \\left\\{ \\begin{aligned} \u0026\\bm{x}_c(i+1) = A_c \\bm{x}_c(i) + B_c \\bm{u}(i) + \\bm{d}(i) \\\\ \u0026\\bm{y}(i) = C_c \\bm{x}_c(i) + C_d \\bm{x}_d(i) \\end{aligned} \\right. $$ 扰动动态的状态空间方程为： $$ \\left\\{ \\begin{aligned} \u0026 \\bm{x}_d(i+1) = A_d \\bm{x}_d(i) + G_d \\bm{w}_d(i) \\\\ \u0026 \\bm{d}(i) = H_c \\bm{x}_d(i) + G_c \\bm{w}_c(i) \\end{aligned} \\right. $$ 在此约定的基础上，归纳将要用到的符号列表如下： 分类 符号 说明 被控对象 $\\bm{x}_c$ 可控动态的状态变量 $\\bm{x}_d$ 扰动动态的状态变量 $\\bm{w}_c$ 可控动态的随机扰动 $\\bm{w}_d$ 扰动动态的驱动噪声 $\\bm{w}_m$ 传感器的测量噪声 $\\bm{u}$ 被控对象的控制指令 $\\bm{d}$ $= H_c \\bm{x}_d + G_c \\bm{w}_c$ 可控动态受到的总扰动 $\\bm{y}$ 被控对象的输出 $\\breve{\\bm{y}}$ 被控对象输出的测量值 状态预测器 $\\hat{\\bm{x}}_c$ 嵌入模型中可控动态模型的状态变量 $\\hat{\\bm{x}}_d$ 嵌入模型中扰动动态模型的状态变量 $\\bar{\\bm{x}}_n$ 噪声估计器的状态变量 $\\bar{\\bm{w}}_c$ 可控动态随机噪声的估计值 $\\bar{\\bm{w}}_d$ 扰动动态驱动噪声的估计值 $\\bar{\\bm{d}}$ $= H_c \\hat{\\bm{x}}_d + G_c \\bar{\\bm{w}}_c$ 总外扰的估计值 $\\hat{\\bm{d}}$ $= H_c \\hat{\\bm{x}}_d$ 可依据扰动模型进行预测的扰动 $\\hat{\\bm{y}}$ 嵌入模型的输出 参考发生器 $\\bm{x}_r$ 可控动态状态的参考值 $\\bm{u}_r$ 参考控制指令 $\\bm{y}_r$ 被控对象输出的参考值 误差 $\\tilde{\\bm{x}}_c$ $=\\bm{x}_c - \\hat{\\bm{x}}_c$ 可控动态的状态预测误差 $\\tilde{\\bm{x}}_d$ $=\\bm{x}_d - \\hat{\\bm{x}}_d$ 扰动动态的状态预测误差 $\\tilde{\\bm{x}}_r$ $=\\bm{x}_c - \\bm{x}_r + Q\\bm{x}_d$ 被控对象状态的跟踪误差 $\\tilde{\\bm{y}}_m$ $=\\breve{\\bm{y}}-\\bm{y}$ 被控对象的模型误差 $\\tilde{\\bm{y}}$ $=\\bm{y} - \\hat{\\bm{y}}$ 被控对象输出的预测误差 $\\tilde{\\bm{y}}_r$ $=\\bm{y} - \\bm{y}_r$ 被控对象输出的跟踪误差 $\\bm{e}_m$ $=\\breve{\\bm{y}} - \\hat{\\bm{y}}$ 测得的模型误差 $\\bm{e}_r$ $=\\hat{\\bm{x}}_c - \\bm{x}_r + Q \\hat{\\bm{x}}_d$ 测得的跟踪误差 ","date":"2023-07-02","objectID":"/emc01-introduction/:2:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（1）：简介与符号约定","uri":"/emc01-introduction/#符号约定"},{"categories":["Embedded Model Control"],"content":" 参考文献 E. Canuto, C. Novara, D. Carlucci, et al. Spacecraft Dynamics and Control: The Embedded Model Control Approach. Butterworth-Heinemann. 2018. E. Canuto. Embedded Model Control: Outline of the theory. ISA Transactions. 2007(46). 363–377. E. Canuto, C. Novara, L. Colangelo. Embedded model control: Reconciling modern control theory and error-based control design. Control Theory Technol. 2018(16). 261–283. ","date":"2023-07-02","objectID":"/emc01-introduction/:3:0","series":null,"tags":["EMC","模型嵌入控制"],"title":"模型嵌入控制（1）：简介与符号约定","uri":"/emc01-introduction/#参考文献"},{"categories":["数字信号处理"],"content":"航天器的姿态在变轨、通讯、充电等阶段起着十分重要的作用。姿态控制系统由传感器、姿态确定算法和控制律构成。本文将首先介绍几种常用姿态传感器的基本原理，然后对常用的定姿算法进行简要推导。 ","date":"2023-05-31","objectID":"/attitude/:0:0","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#"},{"categories":["数字信号处理"],"content":" 姿态测量姿态传感器用于测量航天器当前姿态与参考方向之间的夹角，根据星表等信息获得参考方向在惯性系下的坐标，进一步可以确定航天器在惯性系下的姿态。对于航天器，常用的姿态传感器有地球敏感器、太阳敏感期、星敏感器等。 ","date":"2023-05-31","objectID":"/attitude/:1:0","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#姿态测量"},{"categories":["数字信号处理"],"content":" 地球敏感器对于近地轨道的卫星，地球的视角最大，立体角达到约 3.9 sr，因此不能使用点光源近似。地球敏感器旨在对地球的地平线进行测量，也称为地平仪（Horizon Sensor）。由于可见光范围内的地平线受到海洋、植物、沙漠等环境的影响，其表面并不均匀，而二氧化碳散发的 14.0 ~ 16.3 μm 范围的红外线更加均匀，所以大部分地平仪均对波长范围的红外线进行探测。 根据地球敏感器是否能够进行动态测量，可以将其分为辐射平衡式、圆锥扫描式、摆动扫描式三种类型。核心原理是测量地球四个边缘点相对于参考像点的位移，如下图所示。 地球敏感器原理示意图 当航天器姿态相对地平面存在误差时，利用参考点的位移可以计算圆心的偏移，进而获得翻滚角和俯仰角。 ","date":"2023-05-31","objectID":"/attitude/:1:1","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#地球敏感器"},{"categories":["数字信号处理"],"content":" 太阳敏感器太阳敏感器可分为模拟太阳敏感器和数字太阳敏感器，其中模拟太阳敏感器的基本元件为光电池，其输出电流与太阳光的入射角余弦成正比，常称为余弦传感器，基本方程为： $$ I(\\alpha) = I_0 \\cos \\alpha $$ 由于余弦函数在零位附近的斜率趋近于零，对微小角度的变化不敏感。为此，可以使用一对光电池对称分布于瞄准方向进行差分测量，如下图所示。 模拟太阳敏感器原理示意图 在这种布局下，两个光电池电流信号的差为： $$ \\Delta I (\\alpha) = I_0 \\cos \\left( \\alpha_0 - \\alpha \\right) - I_0 \\cos \\left( \\alpha_0 + \\alpha \\right) = 2I_0 \\sin\\alpha_0 \\sin \\alpha $$ 此时传感器在零位附近具有 $2I_0\\sin\\alpha_0$ 的斜率，提高了小角度检测的灵敏度。 数字太阳敏感器原理示意图 上图给出了数字太阳敏感器示意图：太阳光线首先通过顶层的狭缝变成线光源，以进行单方向入射角的测量。中间层具有不同尺寸的孔位用于编码（Gray Code），底层则是多个光电池用于检测太阳光是否透过编码孔位。由于光电池与入射角的余弦成正比，编码时的阈值会随之变动。因此，图中中间层最外侧的空隙允许所有视场（FoV：Field of View）内的光线透过，其下方光电池的电流作为阈值，作为其他光电池是否接收到光照的判据。第二个空隙为符号位，用于判断太阳光的入射方向；结合其他空隙的编码，可以将入射角进行量化，量化误差 $\\rho_s$ 与位数 $\\mu_s$ 的关系为： $$ \\rho_s = \\frac{\\alpha_\\mathrm{max}}{2^{\\mu_s-1}} $$ 方位角测量示意图 使用两个正交布置的单自由度太阳敏感器可以分别获得太阳方向在两个测量平面内投影与瞄准方向的夹角。设太阳敏感器测量坐标系与本体系相同，如上图所示。本体系下太阳的方向坐标记为 $\\mathbf{s}^b = [s_1,,s_2,,s_3]^\\mathrm{T}$，可以根据测得的夹角 $\\alpha$ 和 $\\beta$ 按下式计算： $$ \\mathbf{s}^b = \\begin{bmatrix} s_1 \\\\ s_2 \\\\ s_3\\end{bmatrix} = \\frac{1}{\\sqrt{ 1 + \\tan^2 \\alpha + \\tan^2 \\beta}} \\begin{bmatrix} \\tan\\alpha \\\\ \\tan\\beta \\\\ 1 \\end{bmatrix} $$ ","date":"2023-05-31","objectID":"/attitude/:1:2","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#太阳敏感器"},{"categories":["数字信号处理"],"content":" 星敏感器星敏感器本质为数码相机，基本结构如下图所示。恒星发出的光线经过透镜汇聚与焦平面，焦平面由电荷耦合元件（CCD：Charge-Coupled Device）或者互补金属氧化物半导体（CMOS：Complementary Metal-Oxide Semiconductor）构成像素点对平面坐标进行量化。其中，CCD 具有更低的噪声，但更容易受到辐射的破坏；COMS 更能够抵抗环境的不利影响，且具有更大的视场。 CMOS 的技术与微处理器的技术相同，因此像素点兼具数据处理功能，称为有源像素传感器（APS：Active Pixel Sensor）。 星敏感器原理示意图 不同于地球敏感器和太阳敏感器具有特定的参考对象，星敏感器能够针对亮度达到一定阈值的许多恒星同时进行探测。因此，为了确定航天器的姿态，还需要对恒星进行识别，这使得星敏感器的数据处理依赖于复杂的匹配算法。星敏感器的数据刷新率一般在 0.5 Hz 到 10 Hz 之间。根据星敏感器是否对准已知恒星，可以分为两种工作模式： 初始姿态对准模式：该模式也被称为空间迷失模式（lost-in-space mode）。在这种情况下，星敏感器需要扫描整个视场，寻找最亮的像素簇，并至少计算三个簇的中心位置。根据间距、亮度以及其他特性在星表中搜索目标恒星。这个过程可以在数秒内完成； 跟踪模式：在星敏感器识别了特定的恒星后，航天器的姿态可以确定。相比于初始姿态对准模式，由于提前知道了航天器的姿态，在进行星表匹配时会简单很多。 星敏感器受到多种噪声的影响：其中光学失真可以通过标定进行校准；温度效应则可以通过温控将其影响最小化。除此之外，星敏感器还会受到散粒噪声的影响，可以通过增大望远镜孔径或延长积分时间来减小其影响。在没有光照时，暗电流也会引入误差，但可以通过对焦平面降温进行抑制；必要情况下，星敏感器的算法需要考虑暗电流引起的热像素的影响，将其在数据处理中予以扣除；另一方面，在确定姿态时，星表的误差也是姿态误差的一个来源，其中包括：恒星自身的微小运动、航天器位置引入的视差和恒星像差。下表给出了部分科学任务卫星的星敏感器性能对比： 任务 时间 视场 [°] 精度（P/Y，R）[\"] 刷新率 [Hz] GRACE 2002 [±7, ±9.5] [2.1, 16.5] 1 LISA Pathfinder 2015 22 [\u003c1, \u003c5] 2 GRACE-FO 2018 [±18, ±16] [2.8, 23.7] 2 ","date":"2023-05-31","objectID":"/attitude/:1:3","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#星敏感器"},{"categories":["数字信号处理"],"content":" 姿态确定姿态传感器给出了参考方向与传感器瞄准方向之间的夹角，结合传感器的安装信息，可以获得参考方向在航天器本体系下的坐标表示。为了进一步确定航天器的姿态，需要通过星表获得参考方向在惯性系下的坐标表示，并使用姿态确定算法计算姿态矩阵或四元数。本节简要介绍几种常用的定姿算法。 ","date":"2023-05-31","objectID":"/attitude/:2:0","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#姿态确定"},{"categories":["数字信号处理"],"content":" TRIAD 算法TRIAD 算法（TRIaxial Attitude Determination）是最早发表的定姿算法，只需要对两个方向进行测量。其核心思想是根据两个参考矢量方向构造 TRIAD 坐标系，分别通过姿态传感器确定 TRIAD 坐标系与航天器本体坐标系的关系以及通过星表确定 TRIAD 坐标系与惯性系的关系，最后利用姿态矩阵的性质计算航天器的姿态。 TRIAD 定姿算法示意图 如上图所示，将航天器到远方恒星的单位矢量分别记做 $\\vec{s}_1$ 和 $\\vec{s}_2$，则 TRIAD 坐标系定义为： $$ \\vec{t}_1 = \\vec{s}_1 ,\\quad \\vec{t}_2 = \\frac{\\vec{s}_1 \\times \\vec{s}_2}{\\left\\|\\vec{s}_1 \\times \\vec{s}_2\\right\\|} ,\\quad \\vec{t}_3 = \\vec{t}_1 \\times \\vec{t}_2 $$ 利用星敏感器可以计算恒星方向在本体参考系下的坐标 $\\mathbf{s}_1^b$ 和 $\\mathbf{s}_2^b$，因此 TRIAD 与本体系之间的坐标变换矩阵为： $$ R_t^b = \\begin{bmatrix} \\mathbf{t}_1^b \u0026 \\mathbf{t}_2^b \u0026 \\mathbf{t}_3^b \\end{bmatrix} $$ 同理，利用星表获得恒星方向在惯性系下的坐标，进而可以获得 TRIAD 与惯性系之间的关系： $$ R_t^i = \\begin{bmatrix} \\mathbf{t}_1^i \u0026 \\mathbf{t}_2^i \u0026 \\mathbf{t}_3^i \\end{bmatrix} $$ 因此航天器的姿态矩阵为： $$ R_s^i =R_t^i R_b^t = R_t^i \\left( R_t^b \\right)^\\mathrm{T} $$ ","date":"2023-05-31","objectID":"/attitude/:2:1","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#triad-算法"},{"categories":["数字信号处理"],"content":" QUEST 算法当可测的方向多于两个，且测量精度不同时，TRIAD 算法的使用将受到限制。这时的定姿问题可以转化为最优化问题：即寻找姿态矩阵 $R = R_b^i$ 使得误差的平方加权和最小，用数学表述为： $$ \\mathop{\\arg\\min}_R J(R),\\quad J(R) = \\frac{1}{2} \\sum_{j=1}^m w_j \\left\\| \\breve{\\mathbf{s}}_j^b - R^\\mathrm{T}\\breve{\\mathbf{s}}_j^i \\right\\|^2 $$ 这个问题被称为 Wahba 问题，其中 $w_j$ 为权值，一般有： $$ \\sum_{j=1}^m w_j = w_0 = 1 $$ 考察优化目标函数： $$ \\begin{aligned} J(R) \u0026= \\frac{1}{2} \\sum_{j=1}^m w_j \\left( \\breve{\\mathbf{s}}_j^b - R^\\mathrm{T}\\breve{\\mathbf{s}}_j^i \\right)^\\mathrm{T} \\left( \\breve{\\mathbf{s}}_j^b - R^\\mathrm{T}\\breve{\\mathbf{s}}_j^i \\right) \\\\ \u0026= \\frac{1}{2} \\sum_{j=1}^m \\left(2 - 2 \\bigl(\\breve{\\mathbf{s}}_j^i \\bigr)^\\mathrm{T} R \\breve{\\mathbf{s}}_j^b\\right) \\\\ \u0026= w_0 - \\sum_{j=1}^m \\bigl(\\breve{\\mathbf{s}}_j^i \\bigr)^\\mathrm{T} R \\breve{\\mathbf{s}}_j^b \\\\ \u0026= w_0 - \\sum_{j=1}^m \\mathrm{tr} \\left( w_j \\breve{\\mathbf{s}}_j^b \\bigl( R^\\mathrm{T} \\breve{\\mathbf{s}}_j^i \\bigr)^\\mathrm{T} \\right) \\\\ \u0026= w_0 - \\mathrm{tr} \\left( \\sum_{j=1}^m \\left( w_j \\breve{\\mathbf{s}}_j^b \\bigl(\\breve{\\mathbf{s}}_j^i \\bigr)^\\mathrm{T} \\right) R \\right) \\end{aligned} $$ 定义矩阵 $W$ 为： $$ W = \\sum_{j=1}^m \\left( w_j \\breve{\\mathbf{s}}_j^b \\bigl(\\breve{\\mathbf{s}}_j^i \\bigr)^\\mathrm{T} \\right) $$ 原优化目标可转化为： $$ \\mathop{\\arg\\min}_R J(R) \\quad \\rightarrow \\quad \\mathop{\\arg\\max}_R \\mathrm{tr}\\bigl( WR \\bigr) = \\mathop{\\arg\\max}_R \\mathrm{tr}\\bigl( RW \\bigr) $$ 姿态矩阵 $R$ 有 $9$ 个参数，但只有 $3$ 个自由度，为了便于数值计算，矩阵表述转化为四元数 $\\mathfrak{q} = \\mathfrak{q}_s^i = [q_0,\\,q_1,\\,q_2,\\,q_3]^\\mathrm{T}$，上式可化为： $$ \\begin{aligned} \\mathrm{tr}\\bigl( RW \\bigr) \u0026= \\mathrm{tr}\\Bigl( \\bigl(2 \\mathbf{q} \\mathbf{q}^\\mathrm{T} + (q_0^2 - \\mathbf{q}^\\mathrm{T} \\mathbf{q})I + 2q_0 \\mathbf{q} \\times \\bigr) W \\Bigr) \\\\ \u0026= \\mathfrak{q}^\\mathrm{T} \\begin{bmatrix} w \u0026 \\mathbf{w}^\\mathrm{T} \\\\ \\mathbf{w} \u0026 W + W^\\mathrm{T} - wI \\end{bmatrix} \\mathfrak{q} \\end{aligned} $$ 其中： $$ w = \\mathrm{tr}(W),\\quad \\mathbf{w} = \\sum_{j=1}^m w_j \\breve{\\mathbf{s}}_j^b \\times \\breve{\\mathbf{s}}_j^i ,\\quad Q = \\begin{bmatrix} w \u0026 \\mathbf{w}^\\mathrm{T} \\\\ \\mathbf{w} \u0026 W + W^\\mathrm{T} - wI \\end{bmatrix} $$ 在四元数表述下，Wahba 问题变为有约束条件下的极值问题： $$ \\mathop{\\arg\\max}_\\mathfrak{q} \\mathfrak{q}^\\mathrm{T} Q \\mathfrak{q} ,\\quad \\mathfrak{q}^\\mathrm{T} \\mathfrak{q} = 1 $$ 这类问题可以利用拉格朗日乘数法进行求解，记： $$ L(\\mathfrak{q},\\,\\lambda) = \\frac{1}{2} \\mathfrak{q}^\\mathrm{T} Q \\mathfrak{q} + \\lambda \\bigl( 1 - \\mathfrak{q}^\\mathrm{T} \\mathfrak{q} \\bigr) $$ 则优化问题的解由下述方程组给出： $$ \\left\\{ \\begin{aligned} \\frac{\\partial L}{\\mathfrak{q}} \u0026= (Q-\\lambda I) \\mathfrak{q} = 0 \\\\ \\frac{\\partial L}{\\lambda} \u0026= 1 - \\mathfrak{q}^\\mathrm{T} \\mathfrak{q} = 0 \\end{aligned} \\right. $$ 进一步分析可知，最优四元数为矩阵 $Q$ 最大特征值对应的特征向量。因此姿态四元数的获取可以依据矩阵的特征值分解得到，这种方法称为 Q 方法（Q-Method）。 由于最优解只与 $Q$ 矩阵的最大特征值相关，分解全部特征值会增加不必要的计算量。QUEST 算法利用解的特性避免了特征值分解，其基本思想为：构造 $Q$ 矩阵后计算其特征多项式，取初值 $\\hat{\\lambda}_{\\mathrm{max},0} = w_0 = 1$ 进行牛顿迭代计算最大特征值，利用 $(Q-\\hat{\\lambda}_\\mathrm{max} I) \\mathfrak{q} = 0$ 求解四元数。更进一步地，使用吉布斯参数 $\\mathbf{p} = \\mathbf{q}/q_0$ 可以简化计算，最后结果为： $$ \\begin{aligned} \\mathbf{p} \u0026= \\Bigl( \\bigl( \\hat{\\lambda}_\\mathrm{max} + w\\bigr)I - \\bigl( W + W^\\mathrm{T} \\bigr) \\Bigr)^{-1} \\mathbf{w} \\\\ \\hat{\\mathfrak{q}} \u0026= \\frac{1}{\\sqrt{1+\\mathbf{p}^\\mathrm{T}\\mathbf{p}}} \\begin{bmatrix} 1 \\\\ \\mathbf{p} \\end{bmatrix} \\end{aligned} $$ ","date":"2023-05-31","objectID":"/attitude/:2:2","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#quest-算法"},{"categories":["数字信号处理"],"content":" 状态估计器QUEST 算法允许将多个姿态传感器的数据进行融合，使用状态估计器可以进一步将不同类型传感器的数据进行融合，如融合陀螺仪和星敏感器的数据对姿态进行估计。状态估计器的基本思路如下图所示，针对航天器的运动学模型构造实时运行的数值模型，将测得的角速度输入给数值模型，利用姿态估计误差 $\\tilde{\\mathfrak{q}}=\\hat{\\mathfrak{q}}^{-1}\\otimes \\breve{\\mathfrak{q}}$ 进行反馈，可以对状态进行修正。进一步，如果对扰动进行建模，还能够对陀螺仪的零偏进行修正，进一步提高姿态的估计精度。 姿态状态估计器示意图 图中的反馈可以使用卡尔曼增益以获得最优估计，参考之前讨论的卡尔曼滤波简介。需要注意的是，由于姿态的运动学方程是非线性的，应当基于上一次的后验估计对模型进行线性化，构成扩展卡尔曼滤波器（EKF：Extended Kalman Filter）。对于频域设计而言，可以使用适当的极点配置设计环路的灵敏度函数，这一点我们将在以后的模型嵌入控制（EMC：Embedded Model Control）中进行详细讨论。 ","date":"2023-05-31","objectID":"/attitude/:2:3","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#状态估计器"},{"categories":["数字信号处理"],"content":" 参考文献 吕振铎, 雷拥军. 卫星姿态测量与确定. 国防工业出版社. 2013. E. Canuto, C. Novara, D. Carlucci, et al. Spacecraft Dynamics and Control: The Embedded Model Control Approach. Butterworth-Heinemann. 2018. Spacecraft Sun Sensors. NASA Space Vehicle Design Criteria (Guidance and Control). 1970. F.L. Markley, J.L. Crassidis. Fundamentals of Spacecraft Attitude Determination and Control. Springer. 2014. C. Dunn, W. Bertiger, G. Franklin, et al. The Instrument on NASA’s GRACE Mission: Augmentation of GPS to Achieve Unprecedented Gravity Field Measurements. 15th International Technical Meeting of the Satellite Division of The Institute of Navigation. 2002. J. Herman, D. Presti, A. Codazzi, C. Belle. Attitude Control for GRACE the First Low-Flying Satellite Formation. 18th International Symposium on Space Flight Dynamics. 2004. L. Giulicchi, S.-F. Wu, T. Fenal. Attitude and orbit control systems for the LISA Pathfinder mission. Aerospace Science and Technology. 2013. LISA Pathfinder Spacecraft Overview. C.R. Patel. Analyzing and monitoring GRACE-FO star camera performance in a changing environment. The University of Texas at Austin. 2020. ","date":"2023-05-31","objectID":"/attitude/:3:0","series":null,"tags":["航天器","传感器","姿态测量","姿态确定"],"title":"航天器姿态测量与确定","uri":"/attitude/#参考文献"},{"categories":["MATLAB"],"content":"为了让 MATLAB 绘制的曲线好看，通常需要使用各种参数设置绘图样式，这会使得绘图代码重复且冗长。本文将介绍如何自定义 MATLAB 的默认绘图样式以简化绘图命令。 ","date":"2023-05-20","objectID":"/initplot/:0:0","series":null,"tags":["MATLAB"],"title":"MATLAB 自定义默认绘图样式","uri":"/initplot/#"},{"categories":["MATLAB"],"content":" 基本思路MATLAB 绘图相关的默认选项由 groot（Graphics root object）的属性决定，使用 get 命令可以查看相应参数的默认值。例如，plot 的默认线宽可以使用以下代码查看： matlab get(groot,'defaultLineLineWidth') 因此，自定义绘图样式的思路非常简单：只需要使用 set 命令重新设置 groot 的属性值即可。例如： matlab set(groot,'defaultLineLineWidth',2) 如此做，在关闭 MATLAB 之前，除非在绘图时显式地指定线宽，所有 plot 的线宽都将设置为 2。 ","date":"2023-05-20","objectID":"/initplot/:1:0","series":null,"tags":["MATLAB"],"title":"MATLAB 自定义默认绘图样式","uri":"/initplot/#基本思路"},{"categories":["MATLAB"],"content":" 自定义样式为了查看 groot 的所有默认属性，可以使用如下命令： matlab get(groot,'factory') 这些属性通常都是可以顾名思义的，为了修改其默认值，只需要结合 set 命令，并将属性开头的 factory 改为 default 即可，例如： matlab % factoryFigureColor = [0.9400, 0.9400, 0.9400] % 默认图片背景为灰色 set(groot,'defaultFigureColor',[1,1,1]) % 设置图片背景为白色 根据个人喜好和常用的设置，可以编写一个脚本或者函数对默认值进行设置。特别地，可以将自定义的绘图样式写在特定的 startup.m 脚本文件中从而达到 MATLAB 启动时自动配置的目的。可行的示例如下： text % 创建 startup.m 文件 edit(fullfile(userpath,'startup.m')) % setup.m 内容示例 set(groot,'defaultFigureColor',[1,1,1]) % 背景颜色 set(groot,'defaultLineLineWidth',2) % 绘图线宽 set(groot,'defaultAxesFontSize',20) % 坐标字号 set(groot,'defaultAxesXGrid','on') % 横轴网格 set(groot,'defaultAxesYGrid','on') % 纵轴网格 简要介绍几个与 plot 相关的参数： defaultFigureColor：绘图区的背景颜色，建议设置为白色以避免直接截图时出现灰色边框； defaultFigureWindowStyle：绘图窗口样式，可选项有 'normal'、'modal' 和 'docked'； defaultAxesFontName：坐标区字体； defaultAxesXGrid：横轴网格； defaultAxesYGrid：纵轴网格； defaultAxesZGrid：竖轴网格； defaultAxesColorOrder：曲线的颜色顺序，十六进制的字符串向量或 $N \\times 3$ 数值矩阵。如果是数值矩阵，每行的三个元素分别对应颜色的归一化 RGB 值。绘图时将按照该颜色顺序渲染曲线； defaultAxesFontSize：坐标区字号； defaultLineLineWidth：线宽； defaultTextFontSize：绘图区文本字号； defaultAxesTickLabelInterpreter：坐标区标注的解释器，可选项有 'tex'、'latex' 和 'none'； defaultTextInterpreter：文本解释器； defaultLegendInterpreter：图例解释器。 ","date":"2023-05-20","objectID":"/initplot/:2:0","series":null,"tags":["MATLAB"],"title":"MATLAB 自定义默认绘图样式","uri":"/initplot/#自定义样式"},{"categories":["MATLAB"],"content":" 封装函数对于不同的操作系统和屏幕分辨率，相同设置下的绘图效果可能存在差异。例如相同线宽和字号的设置下，高分辨率屏幕显示的曲线偏细、字体偏小。为了解决这个问题，可以将绘图样式封装为函数，并将这些可变的样式作为函数的输入参数。例如：将线宽和字号留作设置的接口，自定义的函数形如： matlab function InitPlot(linwidth,fontsize) set(groot,'defaultLineLineWidth',linewidth) % 绘图线宽 set(groot,'defaultAxesFontSize',fontsize) % 坐标字号 % 其他设置 % ... end 如此做，对于不同的平台，startup.m 中使用不同的参数调用该函数即可： matlab InitPlot(2,20) % Windows InitPlot(3,25) % Linux 在某些特殊的情况下，我们希望将自定义的样式恢复为默认样式，这可以将参数值设置为 ‘remove’ 来恢复，例如： matlab set(groot,'defaultAxesFontSize','remove') % 恢复默认字号 为了便于切换样式，我们可以将自定义的样式储存在 cell 数组中，每一行的两个参数分别为属性名称和自定义的属性值，通过 for 循环来批量设置和恢复，局部代码如下： matlab mystyle = { 'defaultFigureColor' , 'w' 'defaultAxesFontName' , 'Serif' 'defaultAxesXGrid' , 'on' 'defaultAxesYGrid' , 'on' 'defaultAxesZGrid' , 'on' }; % -------------------------------- % 设置自定义样式 for k = 1:size(myStyle,1) set(groot,myStyle{k,1},myStyle{k,2}) end % -------------------------------- % 恢复出厂设置 for k = 1:size(myStyle,1) set(groot,myStyle{k,1},'remove') end 最后分享一下我自用的绘图设置函数： matlab % Inilitialize plotting settings % InitPlot(linewidth,fontsize,windowstyle,interpreter) % InitPlot('remove') to restore factory settings % XiaoCY 2022-02-22 %% function InitPlot(varargin) p = inputParser; p.addOptional('linewidth',2); p.addOptional('fontsize',20); p.addOptional('windowstyle','docked',@(s)ischar(s)||isstring(s)); if ispc % Windows interpreter = 'tex'; else interpreter = 'latex'; end p.addOptional('interpreter',interpreter,@(s)ischar(s)||isstring(s)); if nargin == 1 \u0026\u0026 ( ischar(varargin{1}) || isstring(varargin{1}) ) if strcmpi(varargin{1},'remove') useMyStyle = false; p.parse; end else useMyStyle = true; p.parse(varargin{:}); end linewidth = p.Results.linewidth; fontsize = p.Results.fontsize; windowstyle = p.Results.windowstyle; interpreter = p.Results.interpreter; colorVec = [ 0.1765 0.5216 0.9412 % blue 0.9569 0.2627 0.2353 % red 0.0392 0.6588 0.3451 % green 1.0000 0.7373 0.1961 % yellow 0.9843 0.4471 0.6000 % pink 0.4980 0.4980 0.4980 % gray 0.7373 0.7412 0.1333 % olive 0.0902 0.7451 0.8118 % cyan ]; % Run get(groot,'factory') to see what you can change. myStyle = { % figure 'defaultFigureColor' , 'w' 'defaultAxesFontName' , 'Serif' 'defaultAxesXGrid' , 'on' 'defaultAxesYGrid' , 'on' 'defaultAxesZGrid' , 'on' 'defaultConstantLineAlpha' , 1 'defaultAxesColorOrder' , colorVec 'defaultFigureWindowStyle' , windowstyle 'defaultAxesFontSize' , fontsize 'defaultTextFontSize' , fontsize 'defaultConstantLineFontSize' , fontsize 'defaultLineLineWidth' , linewidth 'defaultConstantLineLineWidth' , linewidth 'defaultAnimatedlineLineWidth' , linewidth 'defaultStairLineWidth' , linewidth 'defaultStemLineWidth' , linewidth 'defaultContourLineWidth' , linewidth 'defaultFunctionlineLineWidth' , linewidth 'defaultImplicitfunctionlineLineWidth' , linewidth 'defaultErrorbarLineWidth' , linewidth 'defaultScatterLineWidth' , linewidth 'defaultAxesTickLabelInterpreter' , interpreter 'defaultConstantlineInterpreter' , interpreter 'defaultTextInterpreter' , interpreter 'defaultLegendInterpreter' , interpreter 'defaultColorbarTickLabelInterpreter' , interpreter 'defaultGraphplotInterpreter' , interpreter 'defaultPolaraxesTickLabelInterpreter' , interpreter 'defaultTextarrowshapeInterpreter' , interpreter 'defaultTextboxshapeInterpreter' , interpreter }; if useMyStyle for k = 1:size(myStyle,1) set(groot,myStyle{k,1},myStyle{k,2}) end else for k = 1:size(myStyle,1) set(groot,myStyle{k,1},'remove') end end end ","date":"2023-05-20","objectID":"/initplot/:3:0","series":null,"tags":["MATLAB"],"title":"MATLAB 自定义默认绘图样式","uri":"/initplot/#封装函数"},{"categories":["数字信号处理"],"content":"五点法是采用五个样本点对数据进行处理的一类方法，可以对数据进行平滑或微分处理。本文将讨论五点法的基本思路，并介绍 LISA 团队使用五点法处理二阶微分时的改进。 我们之前在 信号的微分 那篇文章里从控制系统的角度介绍了跟踪微分算法，那是一种满足因果性的算法，意味着当前数据的平滑（滤波）和微分不依赖于将来的数据。与之不同的是，五点法在处理当前时刻的数据时需要使用未来的数据，因此通常用于已经得到数据之后的离线处理。五点法基于当前时刻附近五个数据点的一类处理方法，本文将讨论五点法的三种设计思路，分别为泰勒级数法、参数估计法和 LISA 的二阶微分法。 ","date":"2023-04-05","objectID":"/fivepoints/:0:0","series":null,"tags":["五点法","平滑","滤波","微分"],"title":"基于五点的数据处理算法","uri":"/fivepoints/#"},{"categories":["数字信号处理"],"content":" 泰勒级数法泰勒展开为讨论数据在附近短时间内的变化规律提供了基本线索，记时域数据 $y(t)$ 的采样时间为 $T$，则 $t=nT$ 附近的低阶泰勒级数可以表述为： $$ y(nT+kT) = \\alpha_0 + \\alpha_1 kT + \\alpha_2 (kT)^2 + \\alpha_3 (kT)^3 + \\alpha_4 (kT)^4 + \\mathscr{o}(T^5) $$ 式中幂级数的系数 $\\alpha_k$ 与 $y(t)$ 的导数关系为： $$ \\left.\\frac{\\mathrm{d}^ky}{\\mathrm{d}t^k}\\right|_{t=nT} = \\alpha_k k! $$ 分别取 $k=\\{-2,-1,0,1,2\\}$ 并舍去式中的高阶小量，利用 $y(nT+kT)$ 的数据可以构造方程组： $$ Y_5(n,T) = \\begin{bmatrix} y(nT-2T) \\\\ y(nT-T) \\\\ y(nT) \\\\ y(nT+T) \\\\ y(nT+2T) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 -2T \u0026 4T^2 \u0026 -8T^3 \u0026 16T^4 \\\\ 1 \u0026 -T \u0026 T^2 \u0026 -T^3 \u0026 T^4 \\\\ 1 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 1 \u0026 T \u0026 T^2 \u0026 T^3 \u0026 T^4 \\\\ 1 \u0026 2T \u0026 4T^2 \u0026 8T^3 \u0026 16T^4 \\end{bmatrix} \\begin{bmatrix} \\alpha_0 \\\\ \\alpha_1 \\\\ \\alpha_2 \\\\ \\alpha_3 \\\\ \\alpha_4 \\end{bmatrix} $$ 由此可以对 $\\alpha_k$ 定解，进而根据系数与导数的关系，可以估计 $y(t)$ 在 $t =nT$ 附近的各阶导数为： $$ \\begin{aligned} \\hat{y}(nT) \u0026\\approx \\alpha_0 = \\begin{bmatrix} 0 \u0026 0 \u0026 1 \u0026 0 \u0026 0 \\end{bmatrix} Y_5(n,T) \\\\ \\hat{y}'(nT) \u0026\\approx \\alpha_1 = \\frac{1}{12T} \\begin{bmatrix} 1 \u0026 -8 \u0026 0 \u0026 8 \u0026 -1 \\end{bmatrix} Y_5(n,T) \\\\ \\hat{y}''(nT) \u0026\\approx 2 \\alpha_2 = \\frac{1}{12T^2} \\begin{bmatrix} -1 \u0026 16 \u0026 -30 \u0026 16 \u0026 -1 \\end{bmatrix} Y_5(n,T) \\\\ \\hat{y}^{(3)}(nT) \u0026\\approx 6 \\alpha_3 = \\frac{1}{2T^3} \\begin{bmatrix} -1 \u0026 2 \u0026 0 \u0026 -2 \u0026 1 \\end{bmatrix} Y_5(n,T) \\\\ \\hat{y}^{(4)}(nT) \u0026\\approx 24 \\alpha_4 = \\frac{1}{T^4} \\begin{bmatrix} 1 \u0026 -4 \u0026 6 \u0026 -4 \u0026 1 \\end{bmatrix} Y_5(n,T) \\end{aligned} $$ 该算法实际上是将原数据分段看作四次函数，并根据附近五个点进行定解，因而求解之后的函数在 $t = nT$ 处的数值与 $y(nT)$ 严格相等，即上面的第一个式子所示。然而，当数据存在噪声时，这种算法将因为过拟合而无法对数据进行平均，达不到平滑数据的效果。 在后面的对比中，我们将讨论的重点放在二阶导数，根据上面的第三式将相应的传递函数写为： $$ D_{\\mathrm{Taylor}}(z) = \\frac{1}{12T^2} \\left( -z^{-2} + 16 z^{-1} -30 + 16 z -z^2 \\right) $$ ","date":"2023-04-05","objectID":"/fivepoints/:1:0","series":null,"tags":["五点法","平滑","滤波","微分"],"title":"基于五点的数据处理算法","uri":"/fivepoints/#泰勒级数法"},{"categories":["数字信号处理"],"content":" 参数估计法为了达到平滑的效果，我们将泰勒展开的阶数降低，利用最小二乘法进行“平均”。考虑二次展开的情况，利用 $t=nT$ 附近的五个点构造方程组： $$ Y_5(n,T) = \\begin{bmatrix} y(nT-2T) \\\\ y(nT-T) \\\\ y(nT) \\\\ y(nT+T) \\\\ y(nT+2T) \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 -2T \u0026 4T^2 \\\\ 1 \u0026 -T \u0026 T^2 \\\\ 1 \u0026 0 \u0026 0 \\\\ 1 \u0026 T \u0026 T^2 \\\\ 1 \u0026 2T \u0026 4T^2 \\end{bmatrix} \\begin{bmatrix} \\alpha_0 \\\\ \\alpha_1 \\\\ \\alpha_2 \\end{bmatrix} = \\Gamma A $$ 最小二乘法的解为： $$ A = \\begin{bmatrix} \\alpha_0 \\\\ \\alpha_1 \\\\ \\alpha_2 \\end{bmatrix} = \\left( \\Gamma^\\mathrm{T}\\Gamma \\right)^{-1} \\Gamma^\\mathrm{T} Y_5(n,T) $$ 因而 $y(t)$ 在 $t=nT$ 处的各阶导数为： $$ \\begin{aligned} \\hat{y}(nT) \u0026\\approx \\alpha_0 = \\frac{1}{35} \\begin{bmatrix} -3 \u0026 12 \u0026 17 \u0026 12 \u0026 -3 \\end{bmatrix} Y_5(n,T) \\\\ \\hat{y}'(nT) \u0026\\approx \\alpha_1 = \\frac{1}{10T} \\begin{bmatrix} -2 \u0026 -1 \u0026 0 \u0026 1 \u0026 2 \\end{bmatrix} Y_5(n,T) \\\\ \\hat{y}''(nT) \u0026\\approx 2 \\alpha_2 = \\frac{1}{7T^2} \\begin{bmatrix} 2 \u0026 -1 \u0026 -2 \u0026 -1 \u0026 2 \\end{bmatrix} Y_5(n,T) \\end{aligned} $$ 上面的第一个式子指出，$\\hat{y}(nT)$ 的估计值是对 $y(nT)$ 附近五个数据的加权平均，因此可以达到数据的平滑效果。 同样地，二阶微分的传递函数可以写做： $$ D_{\\mathrm{fit}}(z) = \\frac{1}{7T^2} \\left( 2 z^{-2} - z^{-1} -2 - z + 2z^2 \\right) $$ ","date":"2023-04-05","objectID":"/fivepoints/:2:0","series":null,"tags":["五点法","平滑","滤波","微分"],"title":"基于五点的数据处理算法","uri":"/fivepoints/#参数估计法"},{"categories":["数字信号处理"],"content":" LISA 的二阶微分法LISA 的二次微分算法主要从传递函数的层面考虑，根据上面的讨论，不失一般性地将二次微分的传递函数设为： $$ D_{\\mathrm{LISA}}(z) = \\frac{1}{T^2} \\left( a_{-2} z^{-2} + a_{-1}z^{-1} + a_0 + a_1 z + a_2 z^2 \\right) $$ 将 $z=\\mathrm{e}^{j\\omega T}$ 带入上式，可以得到频率响应为： $$ \\begin{aligned} D_{\\mathrm{LISA}}(j\\omega) \u0026= \\frac{1}{T^2} \\Bigl[ (a_2 + a_{-2}) \\cos(2 \\omega T) + j(a_2 - a_{-2}) \\sin(2\\omega T) \\\\ \u0026\\qquad + (a_1 + a_{-1}) \\cos (\\omega T) + j(a_1 - a_{-1}) \\sin (\\omega T) + a_0 \\Bigr] \\end{aligned} $$ 理想二次微分的频率响应为： $$ D_\\mathrm{ideal}(j\\omega) = (j\\omega)^2 = -\\omega^2 $$ 将 $D_{\\mathrm{LISA}}(j\\omega)$ 与 $D_{\\mathrm{ideal}}(j\\omega)$ 进行对比，可以分别得到以下约束条件： 虚部为零： $$ a_2 = a_{-2} ,\\qquad a_1 = a_{-1} $$ 直流响应为 $0$： $$ \\left( a_2 + a_{-2} \\right) + \\left( a_1 + a_{-1} \\right) + a_0 = 2 a_2 + 2 a_1 + a_0 = 0 $$ 低频段内近似相等（低阶泰勒展开）： $$ D_{\\mathrm{LISA}}(j\\omega) %= \\frac{1}{T^2} \\Bigl[ 2a_2 \\cos (2\\omega T) + 2 a_1 \\cos (\\omega T) + a_0 \\Bigr] \\approx - (4 a_2 + a_1) \\omega^2 \\quad \\rightarrow \\quad 4 a_2 + a_1 = 1 $$ 上面的约束仍不足以定解，对于数字系统，考虑在奈奎斯特频率处增加一个零点，即令 $D_{\\mathrm{LISA}}(j \\omega)$ 在 $\\omega = \\pi f_s = \\pi/T$ 时为零，可补充方程为： $$ 2 a_2 - 2 a_1 + a_0 = 0 $$ 信息 如果取 $a_2= -1/12$ 或 $a_2 = 2/7$，基于上述三个约束条件，可以分别得到泰勒级数法和参数估计法给出的二次微分算法。 因此可以解得 $a_0 = -1/2$，$a_1 = a_{-1} = 0$，$a_2=a_{-2} = 1/4$。因此 $y(t)$ 的二阶导数在 $t=nT$ 时刻的估计值为： $$ \\hat{y}''(nT) = \\frac{1}{T^2} \\Bigl( \\frac{1}{4} y(nT-2T) - \\frac{1}{2} y(nT) + \\frac{1}{4} y(nT+2T) \\Bigr) $$ 最后，我们将三种方法给出的二阶微分传递函数的幅频响应绘制在一起，如下图所示。其中黄色曲线为理想二次微分的幅频响应；蓝色是基于泰勒展开法的二次微分，它在很大的频率范围内与理想微分的增益一致，然而其高频增益太大，容易受到实际测量噪声的影响；红色曲线对应参数估计法，其在低频范围具有二次微分的响应，而在高频兼顾了滤波效果，其零点在奈奎斯特频率之前；绿色曲线为 LISA 的二次微分方法，相较于红色曲线，将零点挪到了奈奎斯特频率处，可以有效抑制高频噪声。 不同二次微分算法的幅频响应 ","date":"2023-04-05","objectID":"/fivepoints/:3:0","series":null,"tags":["五点法","平滑","滤波","微分"],"title":"基于五点的数据处理算法","uri":"/fivepoints/#lisa-的二阶微分法"},{"categories":["数字信号处理"],"content":" 参考文献 L. Ferraioli, M. Hueller, S. Vitale. Discrete derivative estimation in LISA Pathfinder data reduction. Classical and Quantum Gravity. 26 (2009) 094013. ","date":"2023-04-05","objectID":"/fivepoints/:4:0","series":null,"tags":["五点法","平滑","滤波","微分"],"title":"基于五点的数据处理算法","uri":"/fivepoints/#参考文献"},{"categories":["LaTeX"],"content":"基于 $\\LaTeX$ 编写文档时，使用宏包不仅能够更方便地对文档格式进行调整，还可以方便正文的写作。本文分享部分常用宏包，旨在快速介绍其核心功能和一般用法。 注意 本文介绍的宏包均收录于 TeX Live。若宏包用法更新，可以在命令行使用 texdoc 宏包名 查看已安装版本的帮助文档。 本文只介绍宏包最基本的一些设置和用法，详细说明请参考相应的帮助文档。 latex % CTeX configuration \\ctexset{ tocdepth = 2, appendix/name = 附录 } % Date format yyyy-mm-dd \\usepackage{datetime2} % Page margin \\usepackage{geometry} \\geometry{ a4paper, top = 45mm, bottom = 28mm, left = 28mm, right = 28mm, headheight = 15mm, headsep = 6mm, footskip = 11mm } % Color and Google colors \\usepackage[hyperref]{xcolor} % \\definecolor{blue}{HTML}{4285F4} % \\definecolor{red}{HTML}{DB4437} % \\definecolor{yellow}{HTML}{F4B400} % \\definecolor{green}{HTML}{0F9D58} % Footer and header of page \\usepackage{fancyhdr} \\pagestyle{fancy} \\renewcommand{\\headrule}{\\makebox[0pt][l]{\\rule[0.6mm]{\\textwidth}{0.3mm}}\\rule{\\textwidth}{0.3mm}} \\renewcommand{\\footrule}{\\rule{\\textwidth}{0.3mm}} % \\renewcommand{\\footrulewidth}{0.4pt} \\lhead{} % \\chead{\\slshape\\Large \\makebox[120mm]{华\\hfill{}中\\hfill{}科\\hfill{}技\\hfill{}大\\hfill{}学\\hfill{}博\\hfill{}士\\hfill{}学\\hfill{}位\\hfill{}论\\hfill{}文}} \\chead{\\slshape\\Large \\makebox[60mm]{博\\hfill{}士\\hfill{}学\\hfill{}位\\hfill{}论\\hfill{}文}} \\rhead{} \\cfoot{\\thepage} % add bibliography to TOC \\usepackage{tocbibind} % Optimize footnotemark \\usepackage[perpage]{footmisc} % clear count per page \\usepackage{pifont} % use number with ciecle \\renewcommand{\\thefootnote}{\\ding{\\numexpr171+\\value{footnote}}} % Hyperlink \\usepackage{hyperref} % required package \\hypersetup{ hidelinks, colorlinks = false, % pdfauthor = 肖春雨, bookmarksdepth = 3 } % Math \\usepackage{amsmath} \\usepackage{amssymb} \\usepackage{nicematrix} \\usepackage{newtxmath} % times now roam font \\usepackage{bm} % bold fonts \\numberwithin{equation}{section} % SI units \\usepackage{siunitx} \\sisetup{ per-mode = symbol, uncertainty-mode = separate, range-phrase = \\ensuremath{\\,\\sim\\,}, range-units = single } % Table and figure \\usepackage{graphicx} % figure package \\usepackage{tabularx} % fixed-width table \\usepackage{multirow} % merge row \\usepackage{booktabs} % standard three-line table \\usepackage{longtable} \\usepackage{caption} \\usepackage{subcaption} \\graphicspath{{./figures/}} \\numberwithin{figure}{section} \\numberwithin{table}{section} \\captionsetup{labelsep=space} % Support user-defined styles of enumerate \\usepackage{enumitem} % Biolography style \\usepackage{gbt7714} % China standard style \\bibliographystyle{gbt7714-numerical} % numerical / author-year \\setlength{\\bibsep}{0.5ex} % vertical spacing between references \\usepackage{notoccite} % remove citations in TOC and ensure correct numbering % Cross reference \\usepackage[nameinlink]{cleveref} \\crefname{equation}{式}{式} \\crefname{table}{表}{表} \\crefname{figure}{图}{图} \\crefname{appendix}{附录}{附录} \\crefformat{section}{#2第~#1~章#3} \\crefformat{subsection}{#2第~#1~节#3} \\crefformat{subsubsection}{#2第~#1~小节#3} \\crefrangeformat{equation}{#3式~(#1)#4~\\~{}~#5式~(#2)#6} \\captionsetup[subfigure]{subrefformat=simple,labelformat=simple} \\renewcommand\\thesubfigure{\\,(\\alph{subfigure})} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % define new environment and add to contents \\newenvironment{preface}[1]{\\begin{center} \\bfseries \\large #1 \\end{center} \\phantomsection % required if using hyperref \\addcontentsline{toc}{section}{#1} \\normalsize \\par}{} % override `cleardoublepage', see `fancyhdr' doc \\makeatletter \\def\\cleardoublepage{\\clearpage\\if@twoside \\ifodd\\c@page\\else \\begingroup \\mbox{} \\vspace*{\\fill} \\begin{center} （此页留白） \\end{center} \\vspace{\\fill} \\thispagestyle{empty} \\newpage \\if@twocolumn\\mbox{}\\newpage\\fi \\endgroup\\fi\\fi} \\makeatother % support equations to display across pages \\allowdisplaybreaks[4] ","date":"2023-03-24","objectID":"/packages/:0:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#"},{"categories":["LaTeX"],"content":" 中文支持：ctex$\\text{C\\TeX}$ 宏集为编写 $\\LaTeX$ 文档提供了中文支持，其主要功能集中在 ctex 宏包及其相应的文档类（包括 ctexart、ctexrep、ctexbook、ctexbeamer）。在使用宏包和文档类时，常用的选项有： zihao：设置文档的默认字号，可选项有 -4（小四）、5（五号，默认值）； linespread：行间距的倍数，默认为 1.3； fontset：字库设置。Windows 用户通常不需要特别指定，Linux 用户通常需要安装额外字体，然后手动指定； twoside：设置文档双面排版，此时使用 \\cleardoublepage 可以确保后面内容开始于奇数页。默认情况下使用的是 oneside 选项，\\cleardoublepage 与 \\clearpage 命令相同，开始新的一页。 除了宏包选项外，可以使用 \\ctexset 命令进行额外的设置，常用选项包括： tocdepth：目录级别，例如对于 ctexart 文档类，将该参数设置为 2 时，生成的目录只包含 section 和 subsection； today：设置 \\today 显示日期的格式，可选项有 small（阿拉伯数字现实日期）、big（全汉字日期）、old（英文格式的日期）； 标题名称汉化，常用设置及其默认值有： contentsname：目录； listfigurename：插图； listtablename：表格； appendixname：附录； bibname：参考文献。 ","date":"2023-03-24","objectID":"/packages/:1:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#中文支持ctex"},{"categories":["LaTeX"],"content":" 排版优化：microtype如果你的文档由纯英文编写，简单地加载 microtype 宏包即可以实现排版细节的优化。 ","date":"2023-03-24","objectID":"/packages/:2:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#排版优化microtype"},{"categories":["LaTeX"],"content":" 页面设置：geometrygeometry 宏包提供了 \\geometry 命令可以方便地设置页面布局，常用设置包括： paper：指定纸张大小，例如 a4paper。使用时 paper=a4paper 可以直接简写为 a4paper； top、bottom、left、right：上、下、左、右的页面边距。 ","date":"2023-03-24","objectID":"/packages/:3:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#页面设置geometry"},{"categories":["LaTeX"],"content":" 页眉页脚：fancyhdr使用 fancyhdr 宏包可以方便地对页眉、页脚进行设置。在使用 \\pagestyle{fancy} 声明页面样式后，\\lhead、\\chead、\\rhead 命令分别用于定义页眉左、中、右部分内容，将命令中的 “head” 改为 “foot” 可以相应地对页脚进行定义。 在定义页眉页脚时，可以使用 \\theXXX 获取 XXX 相应的编号，例如 \\thepage 是当前页码、\\thesection 是当前节的编号。除此之外，\\leftmark 可以读取当前节的标题。 特别地，对于双面文档，使用 \\cleardoublepage 时，可以使用以下设置可以设置留白页面的内容。 latex % override `cleardoublepage', see `fancyhdr' doc \\makeatletter \\def\\cleardoublepage{\\clearpage\\if@twoside \\ifodd\\c@page\\else \\begingroup \\mbox{} \\vspace*{\\fill} \\begin{center} （此页留白） \\end{center} \\vspace{\\fill} \\thispagestyle{empty} \\newpage \\if@twocolumn\\mbox{}\\newpage\\fi \\endgroup\\fi\\fi} \\makeatother ","date":"2023-03-24","objectID":"/packages/:4:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#页眉页脚fancyhdr"},{"categories":["LaTeX"],"content":" 超链接：hyperrefhyperref 扩展了生成的 PDF 文件的超链接功能，通常情况下简单地导入即可，除此之外，可以使用 hypersetup 命令进行个性化设置。例如，该宏包默认使用方框标记超链接，可以使用下面的设置将超链接用颜色标记： latex \\hypersetup{ hidelinks, colorlinks = false } 一般情况下，生成 PDF 文件导航目录（阅读器里面的导航，不是正文目录）的级别与 ctex 宏包的 tocdepth 参数设置一致，如果希望 PDF 文件的目录级别不同，可以使用该宏包参数 bookmarksdepth 进行修改。 注意 如果使用该宏包时出现问题，尝试在导言区中将该宏包最后导入。 ","date":"2023-03-24","objectID":"/packages/:5:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#超链接hyperref"},{"categories":["LaTeX"],"content":" 交叉引用：cleverefcleveref 宏包简化了交叉引用，使得所有类型的交叉引用都可以使用命令 \\cref 完成，并且自动添加形如 “Section”、“Figure” 等前缀（对于英文写作，段落开头的交叉引用可以使用 \\Cref 以确保首字母大写且不使用缩写）。 该宏包提供以下几个常用选项： capitalise：设置交叉引用前缀的首字母大写； nameinlink：默认情况只有交叉引用的数字可以进行超链接跳转，使用该选项后超链接包含前缀和后缀； noabbrev：设置交叉引用的前缀不使用缩写。 \\cref 命令一次性可以接收多个标签，标签之间用逗号分割，例如 \\cref{fig:bodeplot,fig:stepplot}。多个引用时，还可以使用 \\crefrange 指定引用范围，例如 \\crefrange{eq:basic}{eq:conclusion} 将产生形如 “式 (3) ~ 式 (14)”形式的引用。 英文写作时通常不需要对该宏包进行额外设置，对于中文文档，需要对前后缀进行设置，参考设置如下： latex \\crefname{equation}{式}{式} \\crefname{table}{表}{表} \\crefname{figure}{图}{图} \\crefname{appendix}{附录}{附录} \\crefformat{section}{#2第~#1~章#3} \\crefformat{subsection}{#2第~#1~节#3} \\crefformat{subsubsection}{#2第~#1~小节#3} \\crefrangeformat{equation}{#3式~(#1)#4~\\~{}~#5式~(#2)#6} ","date":"2023-03-24","objectID":"/packages/:6:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#交叉引用cleveref"},{"categories":["LaTeX"],"content":" 列表设置：enumitemenumitem 提供了很多选项以优化列表环境，并可以使用 \\setlist 进行全局设置。例如默认的列表之间间距太大，使用 \\setlist{nosep} 取消额外间距。 ","date":"2023-03-24","objectID":"/packages/:7:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#列表设置enumitem"},{"categories":["LaTeX"],"content":" 国际单位制：sinunitxsiunitx 宏包大大方便了带单位数值的编写，最常用的命令有： \\qty{数值}{单位}：（老版本为 \\SI 命令）其中数值可以采用程序的写法，例如 3e-15 将渲染为 $3 \\times 10^{-15}$；单位部分可以直接采用该宏包定义的多种标准单位及其组合，例如 \\kilogram、\\metre\\per\\second 等。单位可以直接使用相应的英文字符，例如 Hz，在这种方法下，表示乘法关系的单位之家通常有一个小空格，为了确保单位正确渲染，应当添加 一个英文句点，例如力矩可以写作：\\qty{3.14e-3}{N.m}。 \\ang{数值}：角度的表述可以单独使用该命令； \\num{数值}：只渲染数值部分； \\unit{单位}：只渲染单位部分； \\qtyrange{数值}{数值}{单位}：设定某一范围内的数量。 数量的输出格式可以使用 sisetup 命令进行设置，参考示例如下： latex \\sisetup{ per-mode = symbol, uncertainty-mode = separate, range-phrase = \\ensuremath{\\,\\sim\\,}, range-units = single } 特别地，改宏包提供了 S 列格式，可以在排版表格时将竖直在小数点对齐，然后整体向在列居中。 ","date":"2023-03-24","objectID":"/packages/:8:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#国际单位制sinunitx"},{"categories":["LaTeX"],"content":" 美丽的盒子：tcolorboxtcolorbox 宏包提供了 tcolorbox 环境 和 \\tcbox 命令用于产生各种彩色的盒子。该宏包的功能非常强大，这里只展示一个简单的示例：论文修订时结合边注提醒审稿人修改内容，部分代码如下： latex % 导言区定义 \\Rev 命令，以边注的形式标记附近修订所对应的审稿意见 \\newcommand\\Rev[1]{} \\usepackage{marginnote} \\newcommand\\Rev[1]{ \\marginnote{\\tcbox[on line, arc=4pt,colback=blue!10!white,colframe=blue!50!black, boxrule=0.7pt,boxsep=0pt,left=3pt,right=3pt,top=3pt,bottom=3pt]{ \\small Rev. #1 }}} ","date":"2023-03-24","objectID":"/packages/:9:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#美丽的盒子tcolorbox"},{"categories":["LaTeX"],"content":" 跟踪修改：changeschanges 宏包提供了标记修订的接口，可以生成带标记的 PDF 文档。其中常用命令包括： \\added{new}：添加； \\deleted{old}：删除； \\replaced{new}{old}：替换； \\highlight{text}：高亮； \\comment{text}：备注。 在某些特别场景下，上述默认命令可能与其他宏包的命令冲突，可以在导入宏包时加入 commandnameprefix 选项，例如： latex % 导入宏包并将命令增加 `ch` 前缀，例如：\\added --\u003e \\chadded \\usepackage[commandnameprefix=always]{changes} 使用该宏包提供的 final 选项可以编译出“接受所有修订”之后的文档，可用于终稿的编译。 通常情况下手动标记修订是比较麻烦的，可以复制 $\\LaTeX$ 源码后直接修订，然后使用 latexdiff 命令进行差异对比并自动生成带标记的文档。为了美化，将 latexdiff 输出的文件中的差异标记命令用 changes 宏包重载即可。 ","date":"2023-03-24","objectID":"/packages/:10:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#跟踪修改changes"},{"categories":["LaTeX"],"content":" 数学相关宏包编写数学公式时，常用的宏包如下： latex \\usepackage{amsmath} \\usepackage{amssymb} % \\usepackage{nicematrix} \\usepackage{newtxmath} \\usepackage{bm} \\numberwithin{equation}{section} amsmath 提供了大量数学环境的支持；amssymb 提供了额外的数学符号；对于矩阵排版，如有特殊需求，可以使用 nicematrix 宏包提供的 NiceArray 等环境；newtxmath 宏包将数学字体设置为罗马形式的衬线体，可根据个人喜好选择性使用；bm 宏包提供了 \\bm 命令专门用于加粗数学符号。上述代码的最后一行将节编号加入到的公式编号中。 ","date":"2023-03-24","objectID":"/packages/:11:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#数学相关宏包"},{"categories":["LaTeX"],"content":" 图表相关宏包常用的图表相关宏包设置如下： latex \\usepackage{graphicx} % figure package \\usepackage{tabularx} % fixed-width table \\usepackage{multirow} % merge row \\usepackage{booktabs} % standard three-line table \\usepackage{longtable} \\usepackage{subcaption} \\usepackage{caption} \\graphicspath{{./figures/}} \\numberwithin{figure}{section} \\numberwithin{table}{section} \\captionsetup{labelsep=space} graphicx 宏包用于处理插图，其核心命令为 \\includegraphics[选项]{图的文件名}，其中，选项主要用来调整图的缩放和旋转，常用参数有 width、height、scale、angle。此外，该宏包提供了 \\scalebox 命令用于对盒子的大小进行缩放。为了在插入图片时省去文件路径，可以使用 graphicspath 命令声明搜索路径。 tabularx 宏包提供了定宽表格 tabularx 环境，使用该环境时需要在列格式前声明表格总宽度。此外，该宏包提供了 X 列格式，用于自动调整列的宽度。 multirow 宏包提供的 \\multirow[竖直位置]{合并行数}{列宽}{内容} 命令可以用于合并表格的行。其中，“竖直位置可以设置为 c 中间对齐（默认）、t 顶部对齐或 b 底部对齐；“列宽”可以设置为 * 以自动进行调整。 booktabs 宏包提供了标准三线表定义，分别是 \\toprule、\\midrule 和 \\bottomrule。特别地，使用 \\cmidrule 命令可以只绘制部分列的中间横线。 当表格特别长时，可以使用 longtable 处理跨页表格，参考用法如下，此处不做展开。 latex \\begin{longtable}{ll} \\caption{表名} \\label{tab:longtable} % 首页表头 \\\\ \\toprule \\endfirsthead % 续页表头 \\multicolumn{2}{l}{（续表）} \\\\ \\midrule \\endhead % 前页表尾 \\midrule \\multicolumn{2}{r}{（接下一页表格）} \\\\ \\endfoot % 末页表尾 \\bottomrule \\endlastfoot % 表格内容 XX \u0026 XX \\\\ XX \u0026 XX \\\\ \\end{longtable} 当需要图片并排时，可以使用 subcaption 宏包提供的 \\subcaptionbox 命令，例如： latex \\begin{figure}[!htb] \\centering \\subcaptionbox{图名A\\label{fig:figA}}{\\includegraphics[height=55mm]{图片1.pdf}} \\hspace{10mm minus 5mm} \\subcaptionbox{图名B\\label{fig:figB}}{\\includegraphics[height=55mm]{图片2.pdf}} \\caption{总图名} \\label{fig:figAB} \\end{figure} 使用 caption 宏包对图表名称的格式进行设置，例如上面利用 \\captionsetup{labelsep=space} 将图表编号与名字之间的间隔设置为了空格（其他的类似还有分号、句点等习惯）。 类似于公式的编号设置，可以使用 \\numberwithin 将节的编号添加到图表编号中。 ","date":"2023-03-24","objectID":"/packages/:12:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#图表相关宏包"},{"categories":["LaTeX"],"content":" 参考文献相关宏包英文参考文献格式可以由 natbib 宏包手动设置，或使用期刊模板提供的样式。对于中文文献，一般使用 gbt7714 自动处理，为了使用数字编号，需要在使用该宏包后采用 \\bibliographystyle{gbt7714-numerical} 指定格式。该宏包的默认样式基本可以满足要求，如果需要额外设置，可参考说明文档修改对应的 .bst 样式文件。 latex \\usepackage{gbt7714} % China standard style \\bibliographystyle{gbt7714-numerical} % numerical / author-year \\setlength{\\bibsep}{0.5ex} % vertical spacing between references \\usepackage{notoccite} % remove citations in TOC and ensure correct numbering 如果在图表的名字中插入了参考文献，可以使用 notoccite 宏包避免引用的编号出现在目录中。该宏包还进一步确保了图标标题插入引用时的编号正确。 ","date":"2023-03-24","objectID":"/packages/:13:0","series":null,"tags":["LaTeX","宏包"],"title":"LaTeX 常用宏包简介","uri":"/packages/#参考文献相关宏包"},{"categories":["优雅的算法"],"content":"之前看到过一种快速求解平方根倒数的程序，里面包含了强制类型转换和一个神奇的常数，让人摸不着头脑。最近有兴趣了解了这个算法的细节，不禁叹为观止，以此文作为学习记录。 ","date":"2022-09-03","objectID":"/typeconvert/:0:0","series":null,"tags":["数据类型转换","快速平方根倒数"],"title":"数据的强制类型转换及其应用","uri":"/typeconvert/#"},{"categories":["优雅的算法"],"content":" 浮点数与整数的储存IEEE 754 给出了浮点数的储存规范，其基本结构如下图所示（中括号内的的选项分别代表单精度数和双精度数）： 符号位（S, Sign）：占 $1$ 位，为 $0$ 时表示正数，为 $1$ 时表示负数； 指数位（E, Exponent）：表示 $2$ 的指数，可占据 $\\mu_E = [8,11]$ 位； 小数位（M, Mantissa）：科学计数法中的小数部位，可占据 $\\mu_M = [23, 52]$ 位。 IEEE 754 浮点数储存规范 为了能够更精细地表示小数，指数位应当覆盖负数。为此，指数部分应当扣除偏移： $$ E_0 = 2^{\\mu_E - 1} - 1 = \\left[ 127,\\, 1023 \\right] $$ 记 $$ M_0 = 2^{\\mu_M} = \\left[ 2^{23},\\, 2^{52} \\right] $$ 则小数部分的分辨率为 $M_0^{-1}$，浮点数 $x$ 表示为 $$ x = (-1)^S 2^{E-E_0} \\left( 1 + \\frac{M}{M_0} \\right) $$ 式中 $S$、$E$ 和 $M$ 分别表示符号位、指数位和小数位直接按二进制读取的整数。为了更好地区分数据类型，采用大写字母表示整数、小写字母表示实数。 ","date":"2022-09-03","objectID":"/typeconvert/:1:0","series":null,"tags":["数据类型转换","快速平方根倒数"],"title":"数据的强制类型转换及其应用","uri":"/typeconvert/#浮点数与整数的储存"},{"categories":["优雅的算法"],"content":" 对数计算与强制类型转换为了计算对数，我们将讨论范围局限为正实数，即假设符号位 $S=0$。于是有 $$ \\log_2 x = \\log_2 \\left( 2^{E-E_0} \\left( 1 + \\frac{M}{M_0} \\right) \\right) = E-E_0 + \\log_2 \\left( 1 + \\frac{M}{M_0}\\right) \\\\ $$ 考虑到 $\\frac{M}{M_0}\\in [0,1)$，在该区间内，对数函数可以取线性近似 $\\log_2(1+t) \\approx t + k$，例如取 $k=0.045$ 时，两者的对比如下图所示。 对数函数的线性近似 如此做，对数计算可以近似为 $$ \\log_2 x \\approx E-E_0 + \\frac{M}{M_0} + k = \\frac{1}{M_0} \\biggl( \\underbrace{EM_0 + M}_{f_{\\mathrm{int}}(x)} + \\underbrace{M_0 \\left( k-E_0 \\right)}_{R} \\biggr) $$ 式中，$EM_0 + M$ 是将浮点数 $x$ 的指数位和小数位合在一起进行二进制转化得到的整数，即所谓的强制类型转换，用函数记作 $f_{\\mathrm{int}}(x)$。 由此我们可以得到一个重要结论：浮点数的对数与其强制类型转化后的整数存在线性近似，因此可以利用强制类型转换对对数计算进行快速估计。如下图所示，在 $x\\in[10^{-10}, 10^{10}]$ 范围内的估计误差不超过 $0.05$。 近似对数计算及其误差 注意 我们在对 $\\log_2 (1+t)$ 进行线性近似时人为规定了斜率为 $1$，只有这样 $\\log_2 x$ 才与强制类型转化之后的结果 $EM_0 +M$ 相关。若取 $\\log_2(1+t) \\approx at + k, (a\\ne 1)$，$M$ 将替换为 $aM$，需要对小数部分做额外的乘法，与直接进行强制数据类型转换相比引入了额外的计算，会降低程序效率。 ","date":"2022-09-03","objectID":"/typeconvert/:2:0","series":null,"tags":["数据类型转换","快速平方根倒数"],"title":"数据的强制类型转换及其应用","uri":"/typeconvert/#对数计算与强制类型转换"},{"categories":["优雅的算法"],"content":" 快速求解平方根的倒数利用强制类型转换获得对数的初步估计值后，可以利用牛顿迭代获得更高精度的值。在此我们讨论另一种常用的应用：快速计算平方根的倒数，其有名的 C 代码如下所示。 c float Q_rsqrt( float number ) { long i; float x2, y; const float threeHalfs = 1.5f; x2 = number * 0.5f; y = number; i = * ( long * ) \u0026y; // evil floating point bit level hacking i = 0x5f3759df - ( i \u003e\u003e 1 ); // What the fuck? y = * ( float * ) \u0026i; y = y * ( threeHalfs - ( x2 * y * y ) ); // 1st iteration // y = y * ( threeHalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed return y; } 现在我们用强制类型转换与对数的关系来解释这个代码： 使用将原问题取对数变成线性问题： $$ y = \\frac{1}{\\sqrt{x}} \\quad \\rightarrow \\quad \\log_2 y = - \\frac{1}{2} \\log_2 x $$ 将对数用强制进制转化近似，更新线性关系（C 代码中，除以二可以使用右移位得到）： $$ \\left.\\begin{aligned} \\log_2 x \u0026\\approx \\frac{1}{M_0} \\left( f_{\\mathrm{int}}(x) + R \\right) \\\\ \\log_2 y \u0026\\approx \\frac{1}{M_0} \\left( f_{\\mathrm{int}}(y) + R \\right) \\end{aligned} \\right\\} \\quad \\rightarrow \\quad f_{\\mathrm{int}}(y_0) = - \\frac{3}{2} R - \\frac{1}{2} f_{\\mathrm{int}}(x) $$ 其中 $-\\frac{3}{2}R = \\frac{3}{2}M_0(E_0-k)$，对于单精度数，取 $k=0.045$ 时，用十六进制表示为 0x5f3759df，这就是代码中“魔法数”的由来。 反向使用强制进制转化得到原数（平方根的倒数）初值： $$ y_0 = f_{\\mathrm{int}}^{-1}(y_0) = f_{\\mathrm{int}}^{-1}\\left( -\\frac{3}{2} R - \\frac{1}{2} f_{\\mathrm{int}}(x) \\right) $$ 构造牛顿迭代提高求解精度： 原问题可以转化为函数 $f(y) = 1/y^2 -x$ 的零点问题，因此牛顿迭代为 $$ y_{i+1} = y_i - \\frac{f(y_i)}{f'(y_i)} = y_i \\left( \\frac{3}{2} - \\frac{x}{2} y_i^2 \\right) $$ 牛顿迭代的收敛速度很快，并且由于对数近似对初值的估计较为准确，所以只需要进行简单的一次或两次迭代就可以达到足够的精度。最后给出验证结果，如下图所示，可见利用强制类型转换已经获取足够的精度了，两次牛顿迭代后可以将误差进一步缩小到 $10^{-5}$ 以下，简单且高效。 多次迭代结果与误差 本文相关的 MATLAB 代码我放在了 GitHub 仓库，欢迎讨论交流。 ","date":"2022-09-03","objectID":"/typeconvert/:3:0","series":null,"tags":["数据类型转换","快速平方根倒数"],"title":"数据的强制类型转换及其应用","uri":"/typeconvert/#快速求解平方根的倒数"},{"categories":["优雅的算法"],"content":" 参考资料 MathWorks Inc., Floating-Point Numbers. 爱XR的麦子, 【回归本源】番外1-雷神之锤3的那段代码. Chris Lomont, Fast Inverse Square Root, 2003. ","date":"2022-09-03","objectID":"/typeconvert/:4:0","series":null,"tags":["数据类型转换","快速平方根倒数"],"title":"数据的强制类型转换及其应用","uri":"/typeconvert/#参考资料"},{"categories":["优雅的算法"],"content":"在给定的数组中进行抽取，保持元素的相对顺序不变，最长的递增序列包含多少个元素？为了求解这种递增子序列的问题，可以使用动态规划。本文简要介绍这种算法在该问题上的应用。 ","date":"2022-08-03","objectID":"/increasingsubseq/:0:0","series":null,"tags":["动态规划"],"title":"递增子序列的最大长度","uri":"/increasingsubseq/#"},{"categories":["优雅的算法"],"content":" 递增子序列给定序列 $[x_n]$ （本文假设序列的下标从 $1$ 开始），保持元素的相对顺序进行抽取（可以全部抽取），得到其子序列 $[\\breve{x}_n]$，若对于任意 $i\u003ej$ 均有 $\\breve{x}_i\u003e\\breve{x}_j$，则称 $[\\breve{x}_n]$ 是 $[x_n]$ 的递增子序列。 例如，给定序列 $[6,7,1,4,2,3,5]$，其递增子序列可以是 $[6,7]$、$[1,4]$、$[2,3,5]$ 等，其中最长的递增子序列为 $[1,2,3,5]$，其长度为 $4$，是本问题求解的目标。 递增子序列示意图 为了求解递增子序列的最大长度，最直接的思路是列举所有可能的递增子序列，找出这些子序列的最大长度即可。在给定序列的前提下，只要给出子序列最后一个数字即可确定以该数字结尾的递增子序列，据此可以遍历所有的递增子序列，从而得到所求的最大长度。然而穷举意味着大量的重复，是否可以基于之前遍历的结果进行递归？答案就是动态规划。 ","date":"2022-08-03","objectID":"/increasingsubseq/:1:0","series":null,"tags":["动态规划"],"title":"递增子序列的最大长度","uri":"/increasingsubseq/#递增子序列"},{"categories":["优雅的算法"],"content":" 动态规划求解的思路：找到以 $x_i$ 结尾的递增子序列并求解这些序列的最大长度 $y_i$，最后只要找到序列 $[y_n]$ 的最大值即可。 为了得到 $y_i$，试想将 $x_i$ 插入到任意 $x_{j\u003ci}$ 后面，考察以 $x_i$ 结尾的递增子序列的最大长度 $y_{j|i}$。为了说明这一过程，如下图所示。设 $x_i=5$，当 $j=2$ 时，$x_j = 7 \u003e x_i = 5$，此时以 $x_i$ 结尾的递增子序列为 $[5]$，长度为 $1$；当 $j=4$ 时，$x_j = 4 \u003c x_i = 5$，意味着 $x_i$ 可以插入到 $x_j$ 后面构成递增序列。在这种情况下，递增子序列的长度是以 $x_j$ 为结尾的递增子序列最大长度加一，即 $y_j + 1$。 动态规划算法示意图 由此可以归纳出递归公式： 初始化：以第一个元素结尾的序列只包含其自己，长度为 $$ y_1 = 1 $$ 将 $x_i$ 插入到 $x_j$ 之后且以 $x_i$ 为结尾的递增子序列最大长度 $$ y_{j|i} = \\left\\{ \\begin{aligned} \u0026 1 ,\u0026 x_i \\le x_j \\\\ \u0026 y_j + 1, \u0026 x_i \u003e x_j \\end{aligned} \\right. ,\\quad 1 \\le j \u003c i $$ 以 $x_i$ 结尾的递增子序列的最大长度： $$ y_i = \\max_{j\u003c i} y_{j|i} $$ 给定序列的递增子序列的最大长度 $$ y_\\mathrm{max} = \\max_i y_i $$ ","date":"2022-08-03","objectID":"/increasingsubseq/:2:0","series":null,"tags":["动态规划"],"title":"递增子序列的最大长度","uri":"/increasingsubseq/#动态规划"},{"categories":["优雅的算法"],"content":" 代码实现本题来自 LeetCode 的 300. 最长递增子序列，Python 代码如下： python class Solution: def lengthOfLIS(self, nums: List[int]) -\u003e int: N = len(nums) # 输入序列的长度 y = [1]*N # 将 x[i] 结尾的递增子序列的最大长度初始化为 1 ymax = 1 # 初始化序列的递增子序列最大长度 for i in range(N): for j in range(i): # 当 x[i] 插在 x[j] 后的递增子序列最大长度 if nums[i] \u003c= nums[j]: yji = 1 else: yji = y[j] + 1 if yji \u003e y[i]: # y[i] 是 yji 的最大值 y[i] = yji if y[i] \u003e ymax: # ymax 是 y[i] 的最大值 ymax = y[i] return ymax ","date":"2022-08-03","objectID":"/increasingsubseq/:3:0","series":null,"tags":["动态规划"],"title":"递增子序列的最大长度","uri":"/increasingsubseq/#代码实现"},{"categories":["控制理论基础"],"content":"反步法（Backstepping）通过拼凑李雅普诺夫函数得到控制律，可用于非线性被控对象的控制器设计。本文是对 DR_CAN 系列视频的学习，并以一个开环不稳定的非线性系统为例进行设计与仿真。 ","date":"2022-07-28","objectID":"/backstepping/:0:0","series":null,"tags":["反步法","非线性控制"],"title":"使用反步法设计非线性控制器","uri":"/backstepping/#"},{"categories":["控制理论基础"],"content":" 反步法基本思路为了使用李雅普诺夫函数判定系统稳定性，首先做如下定义： 对于标量函数 $V(\\bm{x})$，若有 $V(\\bm{x}) = 0, \\ \\bm{x}=0$ $V(\\bm{x}) \u003e 0,\\ \\bm{x}\\ne 0$ 则称 $V(\\bm{x})$ 为正定函数。如果 $\\bm{x}\\ne 0$ 时 $V(x)\\ge 0$，则称之为半正定函数。类似地，如果 $\\bm{x}\\ne 0$ 时 $V(x) \u003c 0$ 则将其称为负定函数；如果 $V(x) \\le 0$ 则为半负定函数。 非线性系统的稳定性可以通过李雅普诺夫直接法进行判定：如果一个关于所有状态的函数 $V(\\bm{x})$ 是正定的，其导数 $\\dot{V}(\\bm{x})$ 为半负定的，则该函数为李雅普诺夫函数，且对应的系统稳定。进一步，如果 $\\dot{V}(\\bm{x})$ 是负定的，则系统渐进稳定。 反步法的基本思路是逐级构造关于误差的正定函数，通过误差动态模型将该正定函数的导数凑成负定函数，从而获得控制律的具体表达，使系统满足稳定性需求。 ","date":"2022-07-28","objectID":"/backstepping/:1:0","series":null,"tags":["反步法","非线性控制"],"title":"使用反步法设计非线性控制器","uri":"/backstepping/#反步法基本思路"},{"categories":["控制理论基础"],"content":" 示例与公式推导假设现有非线性负刚度弹簧系统，其状态空间方程表述为 $$ \\left\\{ \\begin{aligned} \\dot{x} \u0026= v \\\\ \\dot{v} \u0026= a x^2 + u \\end{aligned} \\right. $$ 其中 $u$ 为控制命令。设控制的目标是使位移 $x$ 跟随参考位移 $x_r$，不失一般性地，控制指令应当是状态和参考的函数，即 $u=f(x,v,x_r)$。反步法的目标就是设计非线性控制律 $f(\\cdot)$ 来实现参考信号的跟随。需要说明的是，参考信号可以通过多种手段给出，因此 $x_r$ 及其导数均可以认为是已知的，可直接用于构成控制律。 控制器设计以误差收敛为目标，首先定义位移跟踪误差，并构造第一级李雅普诺夫函数 $$ \\left\\{ \\begin{aligned} e_1 \u0026= x - x_r \\\\ V_1 \u0026= \\frac{1}{2} e_1^2 \u003e 0, \\quad (e_1 \\ne 0) \\end{aligned} \\right. $$ 注意 本文所定义的误差与 DR_CAN 视频中的误差定义相反，这样做的好处是当参考信号为零时误差即为信号本身而不必取其相反数。 $V_1$ 在 $e_1\\ne 0$ 时均为正值，即为正定的。$e_1$ 渐进稳定的条件是 $\\dot{V}_1$ 是负定，考虑 $$ \\dot{V}_1 = e_1 \\dot{e}_1 = e_1 \\left( v - \\dot{x}_r \\right) $$ 为了将上式凑成负定函数，可以让 $v-\\dot{x}_r = -K_1 e_1$，将该需求进一步分解为使速度的跟踪误差收敛： $$ v - \\dot{x}_r = -K_1 e_1 \\rightarrow \\left\\{ \\begin{aligned} v_r \u0026= \\dot{x}_r - K_1 e_1 \\\\ e_2 \u0026= v-v_r = 0 \\end{aligned} \\right. $$ 此时将需求从一个误差收敛扩展到了两个误差收敛，相应的李雅普诺夫函数可选取为 $$ V = \\frac{1}{2} e_1^2 + \\frac{1}{2}e_2^2 $$ 显然它是正定的。再次考虑其导数 $$ \\begin{aligned} \\dot{V} \u0026= e_1 \\dot{e}_1 + e_2 \\left( ax^2 + u - \\left( \\ddot{x}_r - K_1 \\dot{e}_1 \\right) \\right) \\\\ \u0026= e_1 \\left( v - \\dot{x}_r \\right) + e_2 \\left( ax^2 + u -\\ddot{x}_r + K_1 \\left( v-\\dot{x}r \\right) \\right) \\\\ \u0026= e_1 \\left(-K_1 e_1 + e_2 \\right) + e_2 \\left( ax^2 + u -\\ddot{x}_r + K_1 \\left( v-\\dot{x}_r \\right) \\right) \\\\ \u0026= -K_1 e_1^2 + e_2 \\left( e_1 + ax^2 + u -\\ddot{x}_r + K_1 \\left( v-\\dot{x}_r \\right) \\right) \\end{aligned} $$ 注意，在第三行我们只将第一项的 $\\dot{e}_1$ 进行了替换： $\\dot{e}_1 = v-\\dot{x}_r = v_r + e_2 - \\dot{x}_r = -K_1e_1 + e_2$ ，这是第一次凑李雅普诺夫函数的期望；而第二项没有作此替换，是为了第二次凑负定函数。也就是说，反步法是逐级将函数凑成负定形式。显然，如果希望 $\\dot{V}$ 是负定的，可以使 $$ e_1 + ax^2 + u -\\ddot{x}_r + K_1 \\left( v-\\dot{x}_r \\right) = -K_2 e_2 $$ 由此可以解得控制律为 $$ \\begin{aligned} u \u0026= -ax^2 + \\ddot{x}_r - e_1 -K_1 \\left( v - \\dot{x}_r \\right) - K_2 e_2 \\\\ \u0026= -ax^2 + \\ddot{x}_r - \\left( x-x_r \\right) -K_1 \\left( v - \\dot{x}_r \\right) - K_2 \\left( v - \\dot{x}_r + K_1 \\left( x - x_r \\right) \\right) \\\\ \u0026= -ax^2 + \\ddot{x}_r - G_1 \\left( x-x_r \\right) - G_2 \\left( v-\\dot{x}_r \\right) \\end{aligned} $$ 其中 $G_1 = 1 + K_1K_2,, G_2 = K_1 + K_2$ 将控制律写成了一般形式的状态（误差）反馈。非线性控制律由三部分构成： 非线性动态：利用 $-ax^2$ 将模型中的非线性偶和扣除，从而达到将模型线性化的目的，是反馈显性化的重要组成； 参考指令：$\\ddot{x}_r$ 实际上是“开环控制”的指令，作为先验知识驱动被控对象跟随参考信号； 误差反馈：将状态与参考信号的误差进行反馈，是误差环路稳定的基本要素，可以通过调整控制参数调节误差的收敛动态。 最后，将误差的动态重新整理，可得 $$ \\left\\{ \\begin{aligned} \\dot{e}_1 \u0026 = -K_1e_1 + e_2 \\\\ \\dot{e}_2 \u0026 = -e_1 - K_2e_2 \\end{aligned} \\right. $$ 可见，非线性被控对象通过反馈，使得误差的动态为线性模型，称之为反馈线性化。误差动态的极点由以下方程给出 $$ \\begin{vmatrix} -K_1-\\lambda \u0026 1 \\\\ -1 \u0026 -K_2-\\lambda \\end{vmatrix} = \\lambda^2 + \\left( K_1+K_2 \\right) \\lambda + K_1K_2+1 = 0 $$ 设极点配置为 $p_1,,p_2$，相应的特征方程为 $$ \\left( \\lambda - p_1 \\right) \\left( \\lambda - p_2 \\right) = \\lambda^2 - \\left( p_1 + p_2 \\right) \\lambda + p_1 p_2 = 0 $$ 对比以上两个式子可得 $$ \\left\\{ \\begin{aligned} \u0026 K_1 + K_2 = - \\left( p_1 + p_2 \\right) \\\\ \u0026 K_1K_2 +1 = p_1p_2 \\end{aligned} \\right. \\quad \\Rightarrow \\quad K_{1,2} = \\frac{-\\left( p_1+p_2 \\right)\\pm\\sqrt{\\left( p_1 - p_2 \\right)^2+4}}{2} $$ ","date":"2022-07-28","objectID":"/backstepping/:2:0","series":null,"tags":["反步法","非线性控制"],"title":"使用反步法设计非线性控制器","uri":"/backstepping/#示例与公式推导"},{"categories":["控制理论基础"],"content":" 仿真建模与验证利用 Simulink 可以很容易验证上面的设计结果，仿真模型如下图所示： 反步法设计控制器的仿真模型 为了验证控制律，假设系统是理想的，即没有外部扰动和测量噪声、所有状态都精确可知。在实际情况下应当引入相应的噪声模型，并通过状态估计器对状态进行估计。 假设被控对象的初始位置与目标位置不同，利用该控制器将其控制到目标位置。在本例中，参考发生器使用三阶砰砰控制以对参考信号进行的微分，以使过渡过程光滑无超调。最终被控对象的位移响应如下图所示： 位移的仿真结果 上述仿真模型我分享在了 GitHub 仓库，欢迎克隆、讨论、分享。 ","date":"2022-07-28","objectID":"/backstepping/:3:0","series":null,"tags":["反步法","非线性控制"],"title":"使用反步法设计非线性控制器","uri":"/backstepping/#仿真建模与验证"},{"categories":["控制理论基础"],"content":" 参考文献 DR_CAN, Nonlinear Backstepping Control. ","date":"2022-07-28","objectID":"/backstepping/:4:0","series":null,"tags":["反步法","非线性控制"],"title":"使用反步法设计非线性控制器","uri":"/backstepping/#参考文献"},{"categories":["LaTeX"],"content":"LaTeX 文档的源码有很多格式化语法，例如插图、表格等环境。使用代码片段可以很容易地插入这种结构化代码，加快文档的编写。本文介绍代码片段插件的使用方法，并介绍我自己的设计思路。 ","date":"2022-06-16","objectID":"/latexsnips/:0:0","series":null,"tags":["LaTeX","代码片段"],"title":"使用代码片段编写 LaTeX 文档","uri":"/latexsnips/#"},{"categories":["LaTeX"],"content":" 插件介绍与使用顾名思义，代码片段就是一小段可以重复利用的代码。使用代码片段本质上类似于复制粘贴并修改的操作，但利用关键字触发可以避免复制代码的过程；不仅如此，通过插件可以对设定的代码片段进行进一步操作，大大提高编程效率。 ","date":"2022-06-16","objectID":"/latexsnips/:1:0","series":null,"tags":["LaTeX","代码片段"],"title":"使用代码片段编写 LaTeX 文档","uri":"/latexsnips/#插件介绍与使用"},{"categories":["LaTeX"],"content":" 插件简介对于 Vim 或者 NeoVim 用户，可以使用 UltiSnips，我在之前的 NeoVim 基本配置 中简要介绍了其安装方法和基本用法；对于 VS Code 用户，可以使用 HyperSnips 插件。这两款插件之间的对比如下表所示： 项目 UltiSnips HyperSnips 文件路径 \u003cvimroot\u003e/UltiSnips/ HyperSnips: Open Snippets Directory 文件命名 \u003cfiletype\u003e.snippets \u003cfiletype\u003e.hsnips 刷新插件 :call UltiSnips#RefreshSnippets() HyperSnips: Reload Snippets 编程接口 Python JavaScript 触发片段 自动触发或自定义快捷键 自动触发或 \u003cTab\u003e 键 其中，斜体表示该操作可以通过 VS Code 界面键入 \u003cCtrl\u003e\u003cShift\u003ep 打开命令面板搜索得到。 ","date":"2022-06-16","objectID":"/latexsnips/:1:1","series":null,"tags":["LaTeX","代码片段"],"title":"使用代码片段编写 LaTeX 文档","uri":"/latexsnips/#插件简介"},{"categories":["LaTeX"],"content":" 基本语法在编写代码片段时，两个插件具有非常相似的语法，基本结构如下： UltiSnips snippet trigger \"description\" options snippet body endsnippet snippet 和 endsnippet 是编写代码片段的关键字，标志着代码片段定义的开始和结尾（抱歉这里的代码暂时不支持高亮）。 trigger 是触发代码片段的关键字，当编写文档时输入关键字并满足 options 约束的触发条件后，将会展开代码片段。一般情况下，两个插件的 trigger 可以直接设置为任意字符，如 fig。如果需要使用正则表达式，UltiSnips 需要将 trigger 使用单引号或双引号括起来，并在 options 中加入 r 选项；HyperSnips 只需要将 trigger 使用反引号 ` 括起来即可。 \"description\" 是对当前代码片段功能的描述，需要使用引号括起。通常情况下该参数不是必须的，但是为了使用后面的 options 选项（对位置敏感），需要补充该简要说明。 options 是触发选项，即编辑时键入关键字后还应当满足触发条件才能够展开代码片段，可选项有： w：单词边界触发。这是默认的触发选项，当关键字两端不存在其他非空字符时可以触发代码片段； b：行首触发。当关键子出现在单独一行的行首时可以触发代码片段； i：单词内触发：只要出现关键字就可以触发代码片段； r：（只在 UltiSnips 中有该选项）启用正则表达式； A：自动展开。当关键字可以触发代码片段时自动展开，通常与其他选项结合使用。 snippet body 是自定义的代码片段，即触发关键字后展开的内容。代码片段内可以使用 $ 和数字设置跳点，这样可以使用设置的快捷键快速跳转：UltiSnips 需要自行设置，见 NeoVim 基本配置；VS Code 使用 \u003cTab\u003e 键跳至下一个跳点，使用 \u003cShift\u003e\u003cTab\u003e 跳到上一个跳点。特别地，$0 为最后一个跳点，跳至这里后无法再进行回跳。代码片段内的跳点可以进一步使用花括号和冒号设置默认值。 下面用一个例子进行解释（两个插件通用）： UltiSnips snippet beg \"begin an environment\" bA \\begin{${1:document}} $0 \\end{${1:document}} endsnippet 该片段定义了触发关键字 beg 以开始一个新的 LaTeX 环境，bA 设置该代码片段当且仅当 beg 出现在行首时自动展开。展开后，原本输入的 beg 将被代码片段的内容替换，且 \\begin{} 和 \\end{} 花括号里的内容将默认填充为 document 并以高亮选中可供替换。按下跳转键后光标将进入环境内部，由于该位置为 $0，该代码片段使用结束。 ","date":"2022-06-16","objectID":"/latexsnips/:1:2","series":null,"tags":["LaTeX","代码片段"],"title":"使用代码片段编写 LaTeX 文档","uri":"/latexsnips/#基本语法"},{"categories":["LaTeX"],"content":" 依内容触发除了使用 options 对代码片段的触发条件进行设置，两个插件还提供了 context 功能进一步限定代码片段的触发条件：在 snippet 前一行通过 context 调用 Python （或 JavaScript）函数，只有当该函数返回 True 时，后面的代码片段可以触发。利用这个功能，我们可以检测当前光标位置所处的环境，当处于数学环境中时才启用某些代码片段，以减少误触发的概率。 对于 Vim/NeoVim 用户，UltiSnips 在处理 LaTeX 文档时需要借用 vimtex 插件提供的 vimtex#syntax#in_mathzone() 函数；而将其应用于 Markdown 时，还要进一步通过 vim-markdown 插件使该能够判断 Markdown 文件的数学环境。如此做，在代码片段文件的开头做如下函数定义： UltiSnips global !p def math(): return vim.eval('vimtex#syntax#in_mathzone()') == '1' endglobal 然后在 snippet 的前一行加入 context \"math()\" 即可。 对于 VS Code 用户，可以使用 \u003cCtrl\u003e\u003cShift\u003ep 打开命令面板，搜索使用 Developer: Inspect Editor Tokens and Scopes，通过 scopes 属性查看当前光标所在的环境。相应地，HyperSnips 可以定义类似的 JavaScript 函数用于数学环境的判断： HyperSnips global function math(context){ return context.scopes.some(s =\u003e s.includes(\".math\")); } endglobal 不同于 UltiSnips 的用法， HyperSnips 在 snippet 的前一行加入的命令为 context math(context)。 ","date":"2022-06-16","objectID":"/latexsnips/:1:3","series":null,"tags":["LaTeX","代码片段"],"title":"使用代码片段编写 LaTeX 文档","uri":"/latexsnips/#依内容触发"},{"categories":["LaTeX"],"content":" 使用编程接口如前所述，UltiSnips 和 HyperSnips 分别支持在代码片段内使用 Python 和 JavaScript 作为编程接口。这通常与正则表达式联合使用，可以更加灵活地处理代码片段。UltiSnips 中使用编程接口时，Python 代码需要使用 `!p 和 ` 包裹；而 HyperSnips 的 JavaScript 代码需要用 `` 在两端包裹。两个插件提供了默认变量用于接口，常用的变量如下表所示（ UltiSnips 提供更多变量，使用 :h UltiSnips-python 查看） 关键字内容 UltiSnips HyperSnips 当前文件路径 path path 代码片段各跳点的内容 t t 正则表达式各分组匹配的内容 match.group m 编程返回的代码片段 snip.rv rv 由于本人对 JavaScript 所知甚少，下面用 Python 接口为例进行解释。 UltiSnips context \"math()\" snippet '([A-Za-z]+)rm' \"mathrm\" rA `!p snip.rv = '\\\\mathrm{' + match.group(1) + '}' `$0 endsnippet 该 UltiSnips 代码片段的第一行约束了该片段只在数学模式下生效。触发关键词使用引号，结合触发选项 r 说明使用了正则表达式：圆括号对字符串做了一个分组，匹配之后该分组的内容可以使用 match.group(1) 获取；分组内的中括号指明该分组匹配的内容为大小写字母，后面的加号表示至少有一个字母；圆括号外的字符表示该关键字必须以 rm 结尾（这就是所谓的“后缀式触发”）。该代码片段实现的效果是：在数学模式下，在字符后面加入 rm 可以将前面的字符变成 \\mathrm{} 命令包围的直立字体。更多关于正则表达式的用法可以参考 菜鸟教程 等技术教程。 ","date":"2022-06-16","objectID":"/latexsnips/:1:4","series":null,"tags":["LaTeX","代码片段"],"title":"使用代码片段编写 LaTeX 文档","uri":"/latexsnips/#使用编程接口"},{"categories":["LaTeX"],"content":" 代码片段设计示例为了偷懒，代码片段的关键字应当尽可能少，使用 2～3 个字符较为合理。并且根据 Elijan 的建议，尽可能使用自动展开加快编写速度。 为此，我定义了下列关键字用于触发 LaTeX 中的各种环境或命令： 关键字 功能 触发条件 env 新建 LaTeX 环境 行首触发 beg 新建 LaTeX 环境 行首触发 fig 新建插图环境 行首触发 tabu 新建普通表格 行首触发 tabx 新建定宽表格 行首触发 tabl 插入三线表的横线 行首触发 equ 单行公式环境 行首触发 gat 居中对齐的多行公式环境 行首触发 ali 手动对齐的多行公式环境 行首触发 gad 居中对齐公式的子环境 边界触发 ald 手动对齐公式的子环境 边界触发 pmat 圆括号包围的矩阵环境 边界触发 bmat 方括号包围的矩阵环境 边界触发 Bmat 花括号包围的矩阵环境 边界触发 vmat 单竖线包围的矩阵环境 边界触发 Vmat 双竖线包围的矩阵环境 边界触发 ff 插入数学分式 边界触发 lr( 自动大小的圆括号 边界触发 lr[ 自动大小的方括号 边界触发 lr{ 自动大小的花括号 边界触发 lr\u003c 自动大小的尖括号 边界触发 ab| 自动大小的绝对值符号 边界触发 no| 自动大小的范数符号 边界触发 b( 手动大圆括号 边界触发 b2( 手动更大的圆括号 边界触发 b3( 手动超级大的圆括号 边界触发 b4( 手动究极大的圆括号 边界触发 使用正则表达式结合词内触发可以实现更常用的后缀式触发，这在对数学符号进行修饰时非常好用。例如上面演示的触发正体命令。类似地，我做了如下定义（用 X 表示后缀前面的内容，不能出现空格）： 后缀 命令 说明 rm \\mathrm{X} 将变量变为直立体 bf \\mathbf{X} 将变量变为粗体 fk \\mathfrak{X} 将变量变为哥特体 bm \\bm{X} 使用 bm 宏包加粗变量 ii X^{-1} 求逆 sr \\sqrt{X} 开方 vec \\vec{X} 箭头（矢量符号） dot \\dot{X} 一个点（一阶导数） ddo \\ddot{X} 两个点（二阶导数） hat \\hat{X} 尖帽子（估计值） bar \\bar{X} 横线（平均值） bre \\breve{X} 圆帽子（测量值） til \\tilde{X} 波浪线（误差） 使用后缀触发可以实现更加便利的功能： 分式自动处理 1500 页数学笔记的小哥在他的 博客 中给出了自动处理分式的代码片段：在数学模式下，当输入除法 / 时，会自动将前面的字符作为 \\frac 的分子，并跳转到分母位置。当分子不止一个变量时，可以使用圆括号括起后再输入 /，此时分子会自动取消最外围用于定界的圆括号。 角标自动处理 数学通常会与角标打交道，为此，我在数学模式下定义了代码片段：任意字符;下标;上标; 。该代码片段在感受第三个封号后会自动处理角标，并且会根据字符长度选择性地添加 {}。下标或上标可以置空，但不允许出现空格。角标中处理特殊符号时可以使用空的花括号分隔命令，例如 \\omega{}t 。 上面讨论的 UltiSnips 和 HyperSnips 代码片段可以分别在我 nvim 仓库 和 LaTeX 仓库 找到，欢迎使用和分享建议。 ","date":"2022-06-16","objectID":"/latexsnips/:2:0","series":null,"tags":["LaTeX","代码片段"],"title":"使用代码片段编写 LaTeX 文档","uri":"/latexsnips/#代码片段设计示例"},{"categories":["LaTeX"],"content":" 参考资料 Gilles Castel. How I’m able to take notes in mathematics lectures using LaTeX and Vim. Elijan J. Mastnak. An UltiSnips guide for LaTeX workflows. ","date":"2022-06-16","objectID":"/latexsnips/:3:0","series":null,"tags":["LaTeX","代码片段"],"title":"使用代码片段编写 LaTeX 文档","uri":"/latexsnips/#参考资料"},{"categories":["好用的软件"],"content":"Vim 被称之为神之编辑器，与其强大的可配置性脱不了关系。NeoVim 是 Vim 的一个复刻，更多强大的插件也随之诞生。本文简要介绍 NeoVim 的配置，包括软件基本的设置和常用插件的安装与配置。 信息 本文所述的配置仅为成文时的状态，详细可以参考我的配置文件在 e50327e 处的提交。 ","date":"2022-05-06","objectID":"/neovim/:0:0","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#"},{"categories":["好用的软件"],"content":" 基本配置利用 set 等关键字可以对 Neovim 进行最基本的设置，使用 :h XXX 可以查看详细的帮助文档。 ","date":"2022-05-06","objectID":"/neovim/:1:0","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#基本配置"},{"categories":["好用的软件"],"content":" 文件类型支持init.vim 的配置是全局生效的，如果需要对特定（后缀）文件进行特定的设置，需要开启文件类型支持。相应的配置文件以 [后缀名].vim 放置在 ftplugin 文件夹下。 vim filetype on filetype plugin on filetype plugin indent on ","date":"2022-05-06","objectID":"/neovim/:1:1","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#文件类型支持"},{"categories":["好用的软件"],"content":" 行号下面两条命令分别启用行号和设置相对行号，以便于快速跳转到指定行。 vim set number set relativenumber ","date":"2022-05-06","objectID":"/neovim/:1:2","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#行号"},{"categories":["好用的软件"],"content":" 缩进autoindent 和 smartindent 启动自动智能缩进，其功能是根据上一行的缩进自动缩进下一行，并且如果下一行置空时会自动删除缩进，只保留空行。除此之外，我喜欢 4 个空格长度的缩进，并且将制表符展开为 4 个空格。因此缩进相关的设置为： vim set autoindent set smartindent set tabstop=4 set softtabstop=4 set shiftwidth=4 set expandtab ","date":"2022-05-06","objectID":"/neovim/:1:3","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#缩进"},{"categories":["好用的软件"],"content":" 编码设置 Neovim 默认编辑文本时使用 UTF-8 编码： vim set encoding=utf-8 ","date":"2022-05-06","objectID":"/neovim/:1:4","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#编码"},{"categories":["好用的软件"],"content":" 高亮Neovim 具有基本的高亮功能： vim syntax on \" 语法高亮 set showmatch \" 当光标置于成对符号（例如括号）时，高亮匹配的符号对 set hlsearch \" 搜索结果高亮 在搜索高亮的设置下，打开之前的文件会高亮之前的搜索结果，为此我们希望在打开文件时将之前的搜索高亮关闭，加入了以下设置： vim exec \"nohlsearch\" ","date":"2022-05-06","objectID":"/neovim/:1:5","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#高亮"},{"categories":["好用的软件"],"content":" 搜索使用 ignorecase 设置搜索时忽略大小写，进一步设置 smartcase。这样，当搜索时手动区分大小写时搜索结果将对大小写敏感。 vim set ignorecase set smartcase ","date":"2022-05-06","objectID":"/neovim/:1:6","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#搜索"},{"categories":["好用的软件"],"content":" 上下边距为了避免光标移动到最顶和最低时看不到附近内容，设置边距至少为 5 行： vim set scrolloff=5 ","date":"2022-05-06","objectID":"/neovim/:1:7","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#上下边距"},{"categories":["好用的软件"],"content":" 主键和 PythonNeovim 可以定义一个主键（Leader Key），这在构造组合键时非常有用。通常可以设置为空格键： vim let g:mapleader = \" \" 除此之外，Neovim 的一些功能依赖于 Python3，设置其路径： vim let g:python3_host_prog = '/usr/bin/python' 上述路径在 Linux 的各种发行版中基本不变，但使用时请确认 python 是否映射为了 python3。Windows 用户请自行设置。 ","date":"2022-05-06","objectID":"/neovim/:1:8","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#主键和-python"},{"categories":["好用的软件"],"content":" 恢复光标Neovim 在打开文件时光标默认在文件的顶部，为了恢复到上一次关闭时的位置，可以使用以下设置： vim au BufReadPost * if line(\"'\\\"\") \u003e 1 \u0026\u0026 line(\"'\\\"\") \u003c= line(\"$\") | exe \"normal! g'\\\"\" | endif ","date":"2022-05-06","objectID":"/neovim/:1:9","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#恢复光标"},{"categories":["好用的软件"],"content":" 键位映射Neovim 可以使用 map、noremap 对键位进行映射，区别在于是否递归映射。非必要情况下，我们都会使用非递归映射 noremap。更进一步，该命令还可以加入 n 或 v 等前缀指定该映射只在特定模式下生效。 ","date":"2022-05-06","objectID":"/neovim/:2:0","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#键位映射"},{"categories":["好用的软件"],"content":" 光标移动Neovim 光标的基本移动是：h 左， j 下，k 上，l 右。本配置文档保留这种移动方式。 如果一行文本太长（比如写 LaTeX 时），Neovim 显示时会默认换行（set wrap），因此屏幕现实的行与换行符区别的实际行会出现差别。Neovim 的移动默认是实际行的移动，为了使用屏幕行（gj，gk）移动，将键位映射进行了交换： vim noremap j gj noremap k gk noremap gj j noremap gk k 为了跟快速跳转，使用大写按键（Shift 加字符的组合）进行 5 行跳转： vim noremap J 5gj noremap K 5gk 特别地，0 和 $ 默认情况下分别表示实际行的行首和行尾，我只在普通模式下将其与屏幕行跳转进行交换，这是因为偶尔会需要从当前位置复制到行尾，可视模式下的 $ 保留为实际行比较实用。 vim nnoremap g0 0 nnoremap 0 g0 nnoremap $ g$ nnoremap g$ $ ","date":"2022-05-06","objectID":"/neovim/:2:1","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#光标移动"},{"categories":["好用的软件"],"content":" 搜索跳转与取消高亮Neovim 进行搜索后使用 n 和 N 分别可以向后、向前继续查找；而使用 zz 可以将当前行居中，因此结合这两个功能，并将继续查找设置为更常用（输入法常用）的 = 和 - 键： vim noremap = nzz noremap - Nzz 除此，由于设置了高亮，搜索结果会始终高亮，将取消高亮映射给空格（\u003cleader\u003e）和回车（\u003cCR\u003e）： vim noremap \u003cleader\u003e\u003cCR\u003e :nohlsearch\u003cCR\u003e ","date":"2022-05-06","objectID":"/neovim/:2:2","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#搜索跳转与取消高亮"},{"categories":["好用的软件"],"content":" 分屏分屏（split）是很常用的功能，但 Neovim 开启分屏需要使用多个组合键或输入较长的命令。为此，将 s 加移动键映射为该方向上的分屏。需要说明的是，按下 s 后会触发 Neovim 默认的替换功能（substitute，删除当前字符并进入插入模式），该操作有其他替换，所以可以将 s 的功能置空（nop：no operation）以接受后面的指令： vim noremap s \u003cnop\u003e noremap sl :set splitright\u003cCR\u003e:vsplit\u003cCR\u003e noremap sh :set nosplitright\u003cCR\u003e:vsplit\u003cCR\u003e noremap sj :set splitbelow\u003cCR\u003e:split\u003cCR\u003e noremap sk :set nosplitbelow\u003cCR\u003e:split\u003cCR\u003e 使用空格加方向键实现分屏之间的跳转： vim noremap \u003cleader\u003el \u003cc-w\u003el noremap \u003cleader\u003eh \u003cc-w\u003eh noremap \u003cleader\u003ej \u003cc-w\u003ej noremap \u003cleader\u003ek \u003cc-w\u003ek 分屏 使用空格加大写方向键将当前分屏放置到指定方向的最边缘： vim noremap \u003cleader\u003eL \u003cc-w\u003eL noremap \u003cleader\u003eH \u003cc-w\u003eH noremap \u003cleader\u003eJ \u003cc-w\u003eJ noremap \u003cleader\u003eK \u003cc-w\u003eK 分屏移动 使用上下左右键调整当前分屏的高度和宽度： text noremap \u003cup\u003e :res +5\u003cCR\u003e noremap \u003cdown\u003e :res -5\u003cCR\u003e noremap \u003cleft\u003e :vertical res -5\u003cCR\u003e noremap \u003cright\u003e :vertical res +5\u003cCR\u003e ","date":"2022-05-06","objectID":"/neovim/:2:3","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#分屏"},{"categories":["好用的软件"],"content":" 标签页如果分屏解决不了需求，还可以使用标签页（tab page），映射 ta 为新建标签页，th 和 tl 分别向左右跳转： vim noremap ta :tabe\u003cCR\u003e noremap th :-tabnext\u003cCR\u003e noremap tl :+tabnext\u003cCR\u003e ","date":"2022-05-06","objectID":"/neovim/:2:4","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#标签页"},{"categories":["好用的软件"],"content":" 常用短命令利用键位映射还可以将一些常用命令映射到给定快捷键： vim noremap \u003cleader\u003eo o\u003cEsc\u003ek “ 空格加小写字母 o：向下插入空行 noremap \u003cleader\u003eO O\u003cEsc\u003ej ” 空格加大写字母 O：向上插入空行 noremap \u003cleader\u003ew :w\u003cCR\u003e “ 空格加小写字母 w：保存文档 noremap \u003cleader\u003eq :q\u003cCR\u003e ” 空格加小写字母 q：退出 Neovim noremap Y \"+y “ 大写字母 Y：复制到系统剪切板 nnoremap R :source $MYVIMRC\u003cCR\u003e “ 普通模式下大写字母 R：刷新 Neovim 配置 ","date":"2022-05-06","objectID":"/neovim/:2:5","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#常用短命令"},{"categories":["好用的软件"],"content":" 插件简介为了使用 vim-plug 对插件进行管理，只要在配置文件中的 call plug#begin() 和 call plug#end() 之间使用关键字 Plug 声明插件仓库的地址即可（确切的说只要 GitHub 地址后半部分）。我使用了以下插件： vim call plug#begin() Plug 'SirVer/ultisnips' Plug 'lervag/vimtex' Plug 'neoclide/coc.nvim', {'branch': 'release'} Plug 'EdenEast/nightfox.nvim' Plug 'vim-airline/vim-airline' Plug 'vim-airline/vim-airline-themes' Plug 'luochen1990/rainbow' Plug 'gcmt/wildfire.vim' Plug 'mbbill/undotree' Plug 'ggandor/lightspeed.nvim' Plug 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'} Plug 'h-hg/fcitx.nvim' Plug 'rcarriga/nvim-notify' Plug 'lewis6991/gitsigns.nvim' Plug 'godlygeek/tabular' \" telescope and its dependencies Plug 'nvim-lua/plenary.nvim' Plug 'BurntSushi/ripgrep' Plug 'sharkdp/fd' Plug 'nvim-telescope/telescope.nvim' \" markdown enhancement Plug 'mzlogin/vim-markdown-toc' Plug 'dkarter/bullets.vim' call plug#end() 普通模式下输入 R 刷新配置（在前面我们配置了快捷键），然后输入 :PlugInstall 即可自动安装插件。下面我们对插件进行配置。 ","date":"2022-05-06","objectID":"/neovim/:3:0","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#插件简介"},{"categories":["好用的软件"],"content":" ultisnips：代码片段ultisnips 插件提供了简单的语法以自定义代码片段，特定文件的代码片段默认放置在配置文件目录下 UltiSnips/ 文件夹内，命名格式为 [后缀名].snippets。也可以任意命名为 *.snippets 并放置在以后缀名为名的子文件下。特别地，all.snippets 对所有文件都生效。 编写代码片段的基本语法如下（中文用于提示，中括号及其里面内容为可选项）： snippets snippet 关键字 [\"提示\"] [展开选项] 代码片段 snippets 其中关键字用于触发代码片段，当在插入模式输入代码片段后，会根据所设置的 [展开选项] （默认手动展开）判定是否展开。[\"提示\"] 用于提示当前代码片段的作用，当设置 [展开选项] 时必须设置 [\"提示\"]。可选的展开设置有： A：检测到关键字之后自动展开； r：使用正则表达式判定关键字，此时关键字需要用引号包围； w：单独出现关键词时才能触发（关键词两边不是字母）； i：与 w 相反，关键字在单词内部时才能触发； b：当关键词为行首时才能触发。 上述选项可以结合使用，例如 bA 表示关键词出现在行首时自动展开代码片段。 代码片段内部可以设置多个断点，分别用 $1、$2 等标记，同时可以使用形如 ${1:默认值} 设置相应断点位置的默认值。特别地，$0 是最后一个断点。 该插件还支持使用 Python，形如： snippets snippet 关键字 [\"提示\"] [展开选项] `!p Python 代码 snip.rv = 输出内容 ` snippets 当使用正则表达式时，匹配结果可以通过形如 match.group(1) 的方式进行调用；输出到代码片段的内容只需要赋值给变量 snip.rv 即可。 编写好代码片段文件后，在 Neovim 的配置文件中设置触发键即可。一般情况下，我们会使用 \u003ctab\u003e 展开代码片段，但测试发现这样会与后文的自动补全冲突，因此这里将触发设置成了 jk 。同时分别用 jk 和 kj 跳转到下一个或上一个断点。下面配置的最后一行手动指定（限定）代码片段的搜索路径，以加快加载速度。 vim let g:UltiSnipsExpandTrigger=\"jk\" let g:UltiSnipsJumpForwardTrigger=\"jk\" let g:UltiSnipsJumpBackwardTrigger=\"kj\" let g:UltiSnipsSnippetDirectories=[$HOME.'/.config/nvim/UltiSnips'] UltiSnip 代码片段 ","date":"2022-05-06","objectID":"/neovim/:3:1","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#ultisnips代码片段"},{"categories":["好用的软件"],"content":" vimtex：LaTeX 支持vimtex 提供了大量的 LaTeX 支持，这里我没有进行深入设置。 详细的配置可以查看最后参考资料中的 Elijan Mastnak 的博客，他的讲解非常详细。 ","date":"2022-05-06","objectID":"/neovim/:3:2","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#vimtexlatex-支持"},{"categories":["好用的软件"],"content":" nightfox.nvim：配色方案nightfox.nvim 提供了很多配色方案，个人倾向于其中的 Nord 方案，同时高亮当前的屏幕行： vim colorscheme nordfox set cursorlineopt=screenline set cursorline ","date":"2022-05-06","objectID":"/neovim/:3:3","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#nightfoxnvim配色方案"},{"categories":["好用的软件"],"content":" vim-airline：美化状态栏vim-airline 和 vim-airline-themes 提供了底部状态栏的美化方案。相应配置参考了 Vi Stack Exchange 上的方案，具体配置为： vim let g:airline_theme='deus' let g:airline_powerline_fonts = 1 if !exists('g:airline_symbols') let g:airline_symbols = {} endif \" unicode symbols let g:airline_left_sep = '»' let g:airline_left_sep = '▶' let g:airline_right_sep = '«' let g:airline_right_sep = '◀' let g:airline_symbols.linenr = '␊' let g:airline_symbols.linenr = '␤' let g:airline_symbols.linenr = '¶' let g:airline_symbols.branch = '⎇' let g:airline_symbols.paste = 'ρ' let g:airline_symbols.paste = 'Þ' let g:airline_symbols.paste = '∥' let g:airline_symbols.whitespace = 'Ξ' \" airline symbols let g:airline_left_sep = '' let g:airline_left_alt_sep = '' let g:airline_right_sep = '' let g:airline_right_alt_sep = '' let g:airline_symbols.branch = '' let g:airline_symbols.readonly = '' let g:airline_symbols.linenr = '' AirLine 状态栏美化 ","date":"2022-05-06","objectID":"/neovim/:3:4","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#vim-airline美化状态栏"},{"categories":["好用的软件"],"content":" coc.nvim：代码补全coc.nvim 提供了强大的代码补全功能，通过 :CocInstall 进一步安装相关语言的扩展就可以启用代码补全。除了必要的设置外，关键在于设置 \u003ctab\u003e 键触发自动补全，核心配置为： vim set hidden set updatetime=100 set shortmess+=c inoremap \u003csilent\u003e\u003cexpr\u003e \u003cTAB\u003e \\ pumvisible() ? \"\\\u003cC-n\u003e\" : \\ \u003cSID\u003echeck_back_space() ? \"\\\u003cTAB\u003e\" : \\ coc#refresh() inoremap \u003cexpr\u003e\u003cS-TAB\u003e pumvisible() ? \"\\\u003cC-p\u003e\" : \"\\\u003cC-h\u003e\" function! s:check_back_space() abort let col = col('.') - 1 return !col || getline('.')[col - 1] =~# '\\s' endfunction 除此之外，通过一下方式设置 coc 的自动安装插件。其中 coc-marketplace 提供了 :CocList marketplace 搜索插件的功能。 vim let g:coc_global_extensions = [ \\ 'coc-marketplace', \\ 'coc-json', \\ 'coc-python' ] 其他设置请参考资料中 TheCW 的视频教程。 ","date":"2022-05-06","objectID":"/neovim/:3:5","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#cocnvim代码补全"},{"categories":["好用的软件"],"content":" rainbow：彩色括号rainbow 提供了成对符号用颜色匹配的功能，设置中只需要激活即可： vim let g:rainbow_active = 1 ","date":"2022-05-06","objectID":"/neovim/:3:6","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#rainbow彩色括号"},{"categories":["好用的软件"],"content":" wildfire.vim：选择成对符号内字符wildfire.vim 提供了使用回车快速选择成对符号内字符的功能。嵌套使用函数时，将光标放到内部，多次按回车可以扩选括号匹配的内容。 WildFire 选择括号内容 ","date":"2022-05-06","objectID":"/neovim/:3:7","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#wildfirevim选择成对符号内字符"},{"categories":["好用的软件"],"content":" undotree：撤销历史undotree 提供了类似 Git 分支的以树形图现实的撤销历史，并可以恢复到特定节点重新开始。基本使用时只需要将触发撤销树的指令映射到给定快捷键即可，这里使用的是空格和 u （undo）： vim nnoremap \u003cleader\u003eu :UndotreeToggle\u003cCR\u003e UndoTree 撤销历史 ","date":"2022-05-06","objectID":"/neovim/:3:8","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#undotree撤销历史"},{"categories":["好用的软件"],"content":" lightspeed.nvim：快速跳转lightspeed.nvim 提供了基于数个字符在行间进行跳转的功能。其默认使用小写和大写的 s 分别向后、向前跳转。然而，如前所属，单独的小写 s 必须映射为 \u003cnop\u003e 以配合分屏操作。因此，这里将向后、向前跳转分别映射为 L 和 H，以与前面配置的 J 和 K 多行跳转相一致。 vim lua require'lightspeed'.setup{} noremap L \u003cPlug\u003eLightspeed_s noremap H \u003cPlug\u003eLightspeed_S 当在普通模式输入 L 时，以光标所在位置为界，触发向后跳转。其后向字符大部分变为灰色。部分高亮字符意味着可以直接跳转。输入目标字符的首字母后，高亮会有所改变，部分甚至会临时改变附近字符以辅助定位跳转。简言之，键入 L 后盯住目标位置，输入前几个字符即可实现跳转。 LightSpeed 快速跳转：向第二个 sum 跳转时，m 被临时替换为 s以进行区分。 ","date":"2022-05-06","objectID":"/neovim/:3:9","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#lightspeednvim快速跳转"},{"categories":["好用的软件"],"content":" nvim-treesitter：高亮强化nvim-treesitter 强化了代码高亮，其设置基于 Lua，这里只对 ensure_installed 进行了配置，强化指定文件的高亮功能。 vim lua \u003c\u003c EOF require'nvim-treesitter.configs'.setup { -- one of \"all\", \"language\", or a list of languages ensure_installed = {'bibtex', 'html', 'json', 'python', 'vim'}, highlight = { enable = true, -- false will disable the whole extension }, } EOF 在本文完成时，treesitter 的 $\\LaTeX$ 支持回导致 UltiSnip 的 context 对数学环境的判断失效，因此这里并未启用。详细的讨论可以查看 该 Issue。 ","date":"2022-05-06","objectID":"/neovim/:3:10","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#nvim-treesitter高亮强化"},{"categories":["好用的软件"],"content":" fcitx.nvim：输入法切换fcitx.nvim 提供了 Fcitx5 下自动切换输入法的的功能。利用该插件，在编辑中文文档时，进入插入模式会自动切换到中文输入法，退回到普通模式时会自动切换到英文输入，避免输入法导致使用命令的困难。 Fcitx 输入法自动切换 ","date":"2022-05-06","objectID":"/neovim/:3:11","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#fcitxnvim输入法切换"},{"categories":["好用的软件"],"content":" nvim-notify：弹窗美化nvim-notify 对 NeoVim 可能出现的弹窗进行了美化，这里使用了默认配置。 ","date":"2022-05-06","objectID":"/neovim/:3:12","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#nvim-notify弹窗美化"},{"categories":["好用的软件"],"content":" gitsigns.nvim：Git 集成gitsigns.nvim 将 Git 集成到了 NeoVim 中，我只在默认方案的基础上，只对部分功能的快捷键进行了重新映射： vim lua require'gitsigns'.setup() noremap \u003cleader\u003egd :Gitsigns preview_hunk\u003cCR\u003e noremap \u003cleader\u003egj :Gitsigns next_hunk\u003cCR\u003e noremap \u003cleader\u003egk :Gitsigns prev_hunk\u003cCR\u003e noremap \u003cleader\u003ega :Gitsigns stage_hunk\u003cCR\u003e noremap \u003cleader\u003egu :Gitsigns undo_stage_hunk\u003cCR\u003e 快捷键及其功能为： \u003cleader\u003egd：查看当前行的改动（d 理解为 diff）； \u003cleader\u003egj：查看下一处改动（j 为向下移动）； \u003cleader\u003egk：查看上一处改动（k 为向上移动）； \u003cleader\u003ega：将当前行的改动提交到暂存区（a 理解为 add）； \u003cleader\u003egu：撤销提交暂存区（u 理解为 undo）。 GitSigns 集成 Git 版本控制 ","date":"2022-05-06","objectID":"/neovim/:3:13","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#gitsignsnvimgit-集成"},{"categories":["好用的软件"],"content":" tabular：指定字符对齐文本tabular 可以指定字符串，使多行文本对齐。常用于代码中 = 对齐。 为了方便使用，映射了可选模式下 \u003cleader\u003et 作为指定对齐字符的快捷键： vim vnoremap \u003cleader\u003et :Tabular / 使用时在可视模式下选择需要对齐的文本，按下空格和 t，输入对齐的字符，回车即可。 Tabular 自动对齐 ","date":"2022-05-06","objectID":"/neovim/:3:14","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#tabular指定字符对齐文本"},{"categories":["好用的软件"],"content":" telescope.nvim：搜索文件telescope.nvim 提供了搜索文件的功能，为了正确使用，需要安装依赖：plenary.nvim，ripgrep，fd。 此配置使用了插件的默认设置，仅将查找文件界面的功能映射到了 \u003cleader\u003etf： vim nnoremap \u003cleader\u003etf \u003ccmd\u003eTelescope find_files\u003ccr\u003e lua require'telescope'.setup{} 普通模式使用空格和 tf 触发搜索窗口查找文件后，按下回车在当前窗口打开文件，或使用 \u003cc-x\u003e 分屏打开文件，也可以使用 \u003cc-t\u003e 在新标签页打开文件。 Telescope 搜索文件 ","date":"2022-05-06","objectID":"/neovim/:3:15","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#telescopenvim搜索文件"},{"categories":["好用的软件"],"content":" vim-markdown-toc：Markdown 生成目录vim-markdown-toc 插件提供了命令生成目录，这里只做了一些无关紧要的配置： vim let g:vmt_list_item_char = '-' let g:vmt_fence_text = 'TOC' let g:vmt_fence_closing_text = '/TOC' 生成目录的主要的命令有： :GenTocGFM 生成 GFM 样式的目录，可用于 GitHub； :GenTocRedcarpet 生成 Redcarpet 样式的目录； :GenTocGitLab 生成 GitLab 样式的目录； :GenTocMarked 生成用于 Marked 解析的目录。 Vim-Markdown-TOC 生成目录 ","date":"2022-05-06","objectID":"/neovim/:3:16","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#vim-markdown-tocmarkdown-生成目录"},{"categories":["好用的软件"],"content":" bullets.vim：自动列表bullets.vim 可以根据前文连续生成相应的列表样式，例如 Markwon 中 - 所引导的无序列表。使用时只需要配置该插件使用的文件类型即可： vim let g:bullets_enabled_file_types = [ \\ 'markdown', \\ 'text', \\ 'gitcommit'] ","date":"2022-05-06","objectID":"/neovim/:3:17","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#bulletsvim自动列表"},{"categories":["好用的软件"],"content":" 参考资料本配置重点参考了 David Chen 在哔哩哔哩（用户名为 TheCW）上投稿的教程视频以及他的配置文档；同时也参考了 Elijan Mastnak 关于使用 NeoVim 编辑 LaTeX 的系列文章，非常感谢这些大佬们的分享！相关参考如下： TheCW, 上古神器Vim：从恶言相向到爱不释手 - 终极Vim教程01 - 带你配置属于你自己的最强IDE TheCW, 上古神器Vim：进阶使用/配置、必备插件介绍 - 终极Vim教程02 - 带你配置属于你自己的最强IDE TheCW, 「妈妈不会告诉你的Vim技巧」 -Vim终极教程03 - 带你配置属于你自己的最强IDE TheCW, 21世纪最强代码编辑器：NeoVim ——就是这些设置让它变成了编辑器之鬼 【附配置与插件教程】 TheCW, 【硬货】让你的vim像vscode一样强大 —— coc.nvim终极指南 TheCW, Colemak 用户使用的 NeoVim 配置文件 Elijan Mastnak, Real-time LaTeX Using (Neo)Vim Elijan Mastnak, Suggested Prerequisites for Writing LaTeX in Vim Elijan Mastnak, An UltiSnips guide for LaTeX workflows Elijan Mastnak, Vim’s ftplugin system Elijan Mastnak, Getting started with the VimTeX plugin Elijan Mastnak, Compiling LaTeX Documents in a Vim-Based Workflow Elijan Mastnak, Setting Up a PDF Reader for Writing LaTeX with Vim Elijan Mastnak, A Vimscript Primer for Filetype-Specific Workflows Jacob Banks, Collections of Awesome Neovim Plugins ","date":"2022-05-06","objectID":"/neovim/:4:0","series":null,"tags":["Vim"],"title":"NeoVim 基本配置","uri":"/neovim/#参考资料"},{"categories":["MATLAB"],"content":"为了扩展自定义函数的功能，通常会将函数重载。在 MATLAB 中，这可以通过判断输入参数的数量配合条件语句来完成。然而，当可选参数较多时，解析输入参数的条件语句会特别冗长，且这种方法难以解析键值对参数。为此，MATLAB 内置了专用于参数解析的类，本文对该其用法进简要介绍。 ","date":"2022-04-29","objectID":"/matlab-inputparser/:0:0","series":null,"tags":["MATLAB","参数解析"],"title":"MATLAB 解析输入参数","uri":"/matlab-inputparser/#"},{"categories":["MATLAB"],"content":" 条件语句的限制我们在之前介绍 MATLAB 编写函数 时提到过关键字 nargin 可以用来判断函数输入参数的数量，据此可以编写条件语句实现重载，其基本格式为： matlab function varargout = fun(varargin) % 解析输入变量 switch nargin case 0 \u003c导入输入变量默认值\u003e case 1 \u003c变量1\u003e = varargin{1}; \u003c其他变量取默认值\u003e otherwise error('无效输入') end % 函数主体 % ... end 输入较少时，这种方法是十分便捷的。但如果函数提供了多个可选项，这种写法会带来不便：（1）编写程序时，switch 语句会特别冗长，以适应不同输入参数情况下解析；（2）只使用参数数目进行判断，参数通常是位置敏感的。例如，使用时想对第三个参数进行修改，必须输入第二个参数（除非第二个参数和第三个参数具有不同的数据类型，在编写 switch 时可以进一步进行数据类型判断）；（3）这种方法不容易实现形如 'Name',Value 这种键值对输入；（4）当自定义函数嵌套其他函数时，难以将多余的键值对参数传递给其他函数。因此，当自定义函数提供多个可选输入时，应当使用更好的参数解析方法。MATLAB 提供了 inputParser 类专门用于解析输入参数。 ","date":"2022-04-29","objectID":"/matlab-inputparser/:1:0","series":null,"tags":["MATLAB","参数解析"],"title":"MATLAB 解析输入参数","uri":"/matlab-inputparser/#条件语句的限制"},{"categories":["MATLAB"],"content":" 输入解析器简介我们从下面一个（局部的）例子开始说起： matlab % 声明输入解析器并进行设置 p = inputParser; p.FunctionName = 'myFunc'; p.KeepUnmatched = true; % 定义参数 p.addRequired('data'); p.addOptional('fs',1); p.addParameter('window',@hann); % 解析参数 p.parse(varargin{:}) data = p.Results.data; fs = p.Results.fs; window = p.Results.window; passOpts = p.Unmatched; ","date":"2022-04-29","objectID":"/matlab-inputparser/:2:0","series":null,"tags":["MATLAB","参数解析"],"title":"MATLAB 解析输入参数","uri":"/matlab-inputparser/#输入解析器简介"},{"categories":["MATLAB"],"content":" 声明与设置首先我们声明一个输入解析器 p = inputParser，如果不打分号将会在命令行输出其属性，其中可以进行设置的为 FunctionName：默认为空。通常设置为 inputParser 所在函数的名字，这样可以在出错是给出是在哪个函数发生的； CaseSensitive：默认为 false，即大小写不敏感。这样在输入键值对参数是，键的大小写不会影响解析； KeepUnmatched：默认为 false，即不保留未配对的参数。如此做，函数输入未定义的参数时会给出错误；当设置其为 true 时，未配对的参数会以结构体的形式汇总到 Unmatched 属性中，可以用于传递给其他函数； PartialMatching：默认为 true。如此做，键值对的键如果只有部分匹配的参数，将认为正确匹配。例如上例中定义了 'window' 参数，实际使用时只输入 'w' 依然能够正确匹配； StructExpand：默认为 true。如此做，当输入结构体时，会按照键值对的方式展开进行匹配。 ","date":"2022-04-29","objectID":"/matlab-inputparser/:2:1","series":null,"tags":["MATLAB","参数解析"],"title":"MATLAB 解析输入参数","uri":"/matlab-inputparser/#声明与设置"},{"categories":["MATLAB"],"content":" 添加参数声明输入解析器并设置完成后，开始添加参数： addRequired 用于添加必要参数，应当放在其他参数设置之前。当函数有多个必要参数时，可以多次使用该函数定义参数。需要注意的是，必要参数是位置敏感的，定义的顺序与调用函数时的输入顺序一致。例如，使用以下代码声明了函数 myFunc 的两个必要参数 matlab % 局部代码 p.addRequired('p1'); p.addRequired('p2'); 在使用 myFunc(1) 时，因为缺少必要参数 p2 会出错；使用 myFunc(1,2) 时，会按照参数顺序和定义顺序，将 $1$、$2$ 分别赋值给 p1、p2。 addOptional 用于添加可选参数，且该参数是位置敏感的，相应的位置与定义的顺序一致。由于该参数是可选的，定义时需要给出默认值。例如下面的局部代码： matlab % 局部代码 p.addRequired('p1'); p.addOptional('p2',2); p.addOptional('p3',3); 此时，如果只调用 myFunc(1,-1)，则会将 $1$ 赋值给必要参数 p1；$-1$ 赋值给可选参数 p2；而由于没有第三个输入，可选参数 p3 将保持默认值 $3$。 由于参数对位置敏感，这种方法无法只输入 p1 和 p3，与前面讨论的 nargin 加条件语句的限制一致。为此，可以使用位置不敏感的键值参数。 addParameter 用于添加键值对参数，其对位置不敏感，特别适合输入参数较多的情况。同样由于该参数是可选的，定义时需要给出默认值。我们将上面的可选输入改为键值参数，有 matlab % 局部代码 p.addRequired('p1'); p.addParameter('p2',2); p.addParameter('p3',3); 这样，如果只想输入 p1 和 p3，只要形如 myFunc(1,'p3',2) 调用即可。 ","date":"2022-04-29","objectID":"/matlab-inputparser/:2:2","series":null,"tags":["MATLAB","参数解析"],"title":"MATLAB 解析输入参数","uri":"/matlab-inputparser/#添加参数"},{"categories":["MATLAB"],"content":" 解析输入设置好 inputParser 之后，只需要使用 p.parse(varargin{:}) 对输入进行解析即可。解析的结果将以结构体的形式汇总在 p.Results 中。 这里应当注意的是，parse 函数接受逗号分隔的列表输入，而关键字 varargin 是 cell 数组，应当使用花括号加 : 的形式进行转换。 如前所述，inputParser 默认接受结构体输入，而未配对成功的参数将会以结构体的形式存放在 p.Unmatched 中，因此可以将其传递给子函数。例如我自编用于画功率谱的 iLPSD 函数，内部调用了 loglog 画图，为了将绘图选项传递给该函数，我用到了下面的方法： matlab % 外部调用 iLPSD iLPSD(data,fs,'LineWidth',2) % iLPSD 内部的 inputParser 没有定义 'LineWidth' 参数，将其传递给 loglog loglog(f,sqrt(pxx),p.Unmatched) ","date":"2022-04-29","objectID":"/matlab-inputparser/:2:3","series":null,"tags":["MATLAB","参数解析"],"title":"MATLAB 解析输入参数","uri":"/matlab-inputparser/#解析输入"},{"categories":["MATLAB"],"content":" 参数有效性验证添加参数时，可以同时对参数的有效性进行验证，这只需要在定义参数时额外给出验证函数的函数句柄即可，例如 matlab % 局部代码 p.addRequired('p1',@(x)isnumeric(x)); 需要说明的是，用于验证参数有效性的函数必须只接收一个输入，且输出必须是逻辑变量 true 或 false。我们可以根据需求自定义验证函数，也可以使用 MATLAB 内置的函数，详细可以查看 状态检测，这些函数基本上都可以顾名思义，因此这里不再展开。 最后介绍两个非常好用的内置函数：validateattributes 用于验证参数的类型和属性；validatestring 用于在给定范围内匹配字符。 validateattributes(A,classes,attributes) 用于验证给定参数 A 是否在允许的 class 类型中，且其属性（例如矩阵的维度）是否满足 attributes 中的某个约束。 matchedStr = validatestring(str,validStrings) 将字符串 str 与选项 validStrings 进行对比，当匹配某个选项时将该选项输出。特别地，该函数可以设置忽略大小写，且可以局部匹配，可以避免使用时输入不准确导致程序无法运行。 ","date":"2022-04-29","objectID":"/matlab-inputparser/:3:0","series":null,"tags":["MATLAB","参数解析"],"title":"MATLAB 解析输入参数","uri":"/matlab-inputparser/#参数有效性验证"},{"categories":["奇妙的数学"],"content":"开普勒定律揭示了行星围绕中心天体运动的规律，随后牛顿提出的运动学定律和万有引力定律进一步从原理上进行了解释。本文从牛顿方程的角度出发，基于限制性二体问题推导开普勒运动定律，被简要介绍轨道六要素和开普勒方程。 ","date":"2022-03-26","objectID":"/newton2kepler/:0:0","series":null,"tags":["牛顿方程","开普勒定律","开普勒方程"],"title":"从牛顿方程到开普勒定律","uri":"/newton2kepler/#"},{"categories":["奇妙的数学"],"content":" 限制性二体问题设两个质点 $m_0$、$m_1$ 的位置矢量分别为 $\\vec{r}_0$ 和 $\\vec{r}_1$。记万有引力常数为 $G$，并将质点的相对位置记为 $\\vec{r}=\\vec{r}_1 - \\vec{r}_0$，则质点之间的万有引力分别为： $$ \\vec{G}_0 = \\frac{Gm_0m_1}{r^2} \\frac{\\vec{r}}{r} ,\\qquad \\vec{G}_1 = -\\frac{Gm_0m_1}{r^2} \\frac{\\vec{r}}{r} $$ 进一步考虑质点受到其他的作用力 $\\vec{F}_0$ 和 $\\vec{F}_1$，根据牛顿第二定律，有 $$ \\left\\{\\begin{aligned} \\ddot{\\vec{r}}_0 \u0026= \\frac{Gm_1}{r^2} \\frac{\\vec{r}}{r} + \\frac{\\vec{F}_0}{m_0} \\\\ \\ddot{\\vec{r}}_1 \u0026= -\\frac{Gm_0}{r^2} \\frac{\\vec{r}}{r} + \\frac{\\vec{F}_1}{m_1} \\end{aligned}\\right. $$ 因此相对运动方程为 $$ \\ddot{\\vec{r}} = \\ddot{\\vec{r}}_1 - \\ddot{\\vec{r}}_0 = -\\frac{G(m_0+m_1)}{r^2} \\frac{\\vec{r}}{r} + \\frac{\\vec{F}_1}{m_1} - \\frac{\\vec{F}_0}{m_0} $$ 当 $m_0 \\gg m_1$ 时，上述方程可以简化为 $$ \\ddot{\\vec{r}} = -\\frac{\\mu}{r^2} \\frac{\\vec{r}}{r} + \\frac{\\vec{F}_1}{m_1} $$ 称之为限制性二体问题。为了表述的方便，将引力常数重新记为 $\\mu = Gm_0$。更进一步，当 $\\vec{F}_0 = \\vec{0}$ 时，上述微分方程的通解称为轨道的自由响应，满足开普勒运动定律。后文将基于此假设推导开普勒定律。 更进一步，二体的质心运动满足 $$ \\ddot{\\vec{r}}_c = \\frac{\\mathrm{d}^2}{\\mathrm{d}t^2} \\left( \\frac{m_0}{m_0+m_1}\\vec{r}_0 + \\frac{m_0}{m_0+m_1}\\vec{r}_1 \\right) = \\frac{1}{m_0 + m_1} \\left(\\vec{F}_0 + \\vec{F}_1\\right) $$ 当外力 $\\vec{F}_0 = \\vec{F}_1 = \\vec{0}$ 时，质心加速度为零，可以作为惯性参考系的原点。对于限制性二体问题，系统质心取为较大质量质点的质心，即中心天体的质心。 ","date":"2022-03-26","objectID":"/newton2kepler/:1:0","series":null,"tags":["牛顿方程","开普勒定律","开普勒方程"],"title":"从牛顿方程到开普勒定律","uri":"/newton2kepler/#限制性二体问题"},{"categories":["奇妙的数学"],"content":" 角动量守恒由于限制性二体问题在外力 $\\vec{F}_0 = \\vec{0}$ 时只受到连线方向的引力作用，合力矩为零，因此其角动量 $\\vec{h} = \\vec{r} \\times \\vec{v}$ 守恒。我们可以从其导数为零（零向量）进行证明： $$ \\dot{\\vec{h}} = \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\vec{r} \\times \\vec{v} \\right) = \\dot{\\vec{r}} \\times \\vec{v} + \\vec{r} \\times \\dot{\\vec{v}} = \\vec{v} \\times \\vec{v} + \\vec{r} \\times \\left( - \\frac{\\mu}{r^2} \\frac{\\vec{r}}{r} \\right) = \\vec{0} $$ 角动量守恒可以从两方面来看，首先，角动量的方向不变，意味着该方向可以作为（轨道）惯性参考系的基矢。习惯上取该方向为第三基矢 $\\vec{p}_3=\\vec{h}/h$，因此在该参考系下可以将角动量记为坐标形式，即 $\\bm{h}^p = [0, 0, h]^\\mathrm{T}$。 其次，角动量的大小不变。为了说明该性质的物理含义，考察下图所示在 $\\mathrm{d}t$ 时间内运动质点与中心质点连线扫过的面积为 质点瞬时运动示意图 $$ \\mathrm{d}A = \\frac{1}{2} |\\vec{r}| \\left( |\\vec{v}| \\mathrm{d}t \\right) \\sin\\phi = \\frac{1}{2} |\\vec{r} \\times \\vec{v}| \\mathrm{d}t = \\frac{1}{2} h \\mathrm{d}t \\quad \\Rightarrow \\quad \\frac{\\mathrm{d}A}{\\mathrm{d}t} = \\frac{1}{2} h $$ 这意味着单位时间内连线扫过的面积为常数，用实例表述为：行星和太阳连线在相同的时间内扫过的面积相等。这就是开普勒第二定律。 ","date":"2022-03-26","objectID":"/newton2kepler/:2:0","series":null,"tags":["牛顿方程","开普勒定律","开普勒方程"],"title":"从牛顿方程到开普勒定律","uri":"/newton2kepler/#角动量守恒"},{"categories":["奇妙的数学"],"content":" 离心率守恒根据限定性二体问题的运动方程，移项后与角动量进行叉乘，有 $$ \\begin{aligned} \\vec{0} \\times \\vec{h} \u0026= \\left( \\ddot{\\vec{r}} + \\frac{\\mu}{r^3} \\vec{r} \\right) \\times \\vec{h} \\\\ \u0026= \\dot{\\vec{v}} \\times \\vec{h} + \\frac{\\mu}{r^3} \\vec{r} \\times \\left( \\vec{r} \\times \\vec{v} \\right) \\\\ \u0026= \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left(\\vec{v}\\times \\vec{h} \\right) + \\frac{\\mu}{r^3} \\bigl( \\left(\\vec{r}\\cdot\\vec{v}\\right) \\vec{r} - \\left(\\vec{r}\\cdot\\vec{r}\\right)\\vec{v} \\bigr) \\\\ \u0026= \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left(\\vec{v}\\times \\vec{h} \\right) + \\frac{\\mu}{r^3} \\left( r\\vec{r} \\frac{\\mathrm{d}r}{\\mathrm{d}t} - r^2 \\frac{\\mathrm{d}\\vec{r}}{\\mathrm{d}t} \\right) \\\\ \u0026= \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left(\\vec{v}\\times \\vec{h} \\right) - \\mu \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left(\\frac{\\vec{r}}{r} \\right) \\\\ \u0026= \\mu \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\frac{\\vec{v}\\times \\vec{h}}{\\mu} - \\frac{\\vec{r}}{r} \\right) \\end{aligned} $$ 上式最后一行将 $\\mu$ 放到括号外，括号内部为无量纲矢量且导数为 $\\vec{0}$。因此该矢量也是守恒量，记为 $\\vec{e}$，可以作为轨道惯性系的基矢 $\\vec{p}_1 = \\vec{e}/e$（最后的基矢可以由 $\\vec{p}_2 = \\vec{p}_3 \\times \\vec{p}_1$ 得到）。考虑位移矢量 $\\vec{r}$ 与 $\\vec{e}$ 的点积，有 $$ \\begin{aligned} \\vec{r} \\cdot \\vec{e} \u0026= r e \\cos\\theta \\\\ \u0026= \\vec{r} \\cdot \\left( \\frac{\\vec{v}\\times \\vec{h}}{\\mu} - \\frac{\\vec{r}}{r} \\right) \\\\ \u0026= \\frac{\\vec{h} \\cdot \\left(\\vec{r}\\times \\vec{v}\\right)}{\\mu} - \\frac{\\vec{r} \\cdot \\vec{r}}{r} \\\\ \u0026= \\frac{h^2}{\\mu} - r \\\\ \u0026= p - r \\end{aligned} $$ 其中 $p = h^2/\\mu$，解得 $$ r = \\frac{p}{1+e\\cos\\theta} $$ 这正是椭圆的表达式，且 $e = |\\vec{e}|$ 为离心率，$\\theta$ 称为真近点角。因此：行星的轨道是以太阳为一个焦点的椭圆轨道。这就是开普勒第一定律。 在椭圆的近拱点，速度与位置垂直，可知离心率矢量 $\\vec{e}$ 的方向与半长轴方向相同。在椭圆中心建立如下图所示的 $\\vec{x}$-$\\vec{y}$ 平面参考系，当 $\\theta = \\pi/2$ 时，带入坐标 $[c,p]^\\mathrm{T}$ 到椭圆方程，有 平面参考系下的椭圆轨道示意图 $$ \\frac{c^2}{a^2} + \\frac{p^2}{b^2} = 1 \\quad \\Rightarrow \\quad p = \\frac{h^2}{\\mu} = a(1-e^2) \\quad \\Rightarrow \\quad h = \\sqrt{\\mu a(1-e^2)} $$ 结合椭圆面积的计算公式和前面推导的 $\\dot{A} = h/2$，积分一周得到运动周期为 $$ A = \\pi ab = \\frac{h}{2} T \\quad \\Rightarrow \\quad T = 2\\pi \\sqrt{\\frac{a^3}{\\mu}} $$ 于是可以验证开普勒第三定律：行星绕太阳运动周期的平方与其半长轴的三次方成比例。 至此，我们从牛顿方程推导了开普勒运动定律。 ","date":"2022-03-26","objectID":"/newton2kepler/:3:0","series":null,"tags":["牛顿方程","开普勒定律","开普勒方程"],"title":"从牛顿方程到开普勒定律","uri":"/newton2kepler/#离心率守恒"},{"categories":["奇妙的数学"],"content":" 开普勒方程开普勒运动定律揭示了行星运动是以中心天体为焦点的椭圆，且角动量和离心率守恒决定了轨道平面的方向和椭圆的形状。只有真近点角 $\\theta$ 是时间的变量，用于唯一地确定行星的位置。考察轨道参考系内，行星的位置坐标可以分解为 $$ \\bm{r}^p = r \\begin{bmatrix} \\cos\\theta \\\\ \\sin\\theta \\\\ 0 \\end{bmatrix} $$ 因此有 $$ \\bm{v}^p = \\dot{\\bm{r}}_p = \\dot{r} \\begin{bmatrix} \\cos\\theta \\\\ \\sin\\theta \\\\ 0 \\end{bmatrix} + r \\dot{\\theta} \\begin{bmatrix} -\\sin\\theta \\\\ \\cos\\theta \\\\ 0 \\end{bmatrix} $$ 带入角动量守恒 $$ \\bm{h}^p = \\bm{r}^p \\times \\bm{v}^p = \\begin{bmatrix} 0 \\\\ 0 \\\\ h \\end{bmatrix} $$ 得 $$ r^2 \\dot{\\theta} = h \\quad \\Rightarrow \\quad \\dot{\\theta} = \\frac{h}{r^2} = \\sqrt{\\frac{\\mu}{p^3}} \\left(1+e\\cos\\theta\\right)^2 $$ 这是一个非线性微分方程，求解比较复杂。为此，如上图，构造与椭圆中心重合且半径为 $a$ 的圆，矢量 $\\vec{r}$ 在 $\\vec{y}$ 方向投影的延长线与圆相交于 $Q$ 点。记 $\\overrightarrow{OQ}$ 与 $\\vec{x}$ 的夹角为 $E$。 考察 $\\vec{r}$ 在 $\\vec{x}$ 方向的投影，有 $$ r \\cos\\theta = a\\cos E - c = a (\\cos E -e) $$ 根据几何关系，将 $[a\\cos E, r \\sin\\theta]^\\mathrm{T}$ 代入 $\\vec{x}$-$\\vec{y}$ 平面内椭圆方程，有 $$ \\cos^2 E + \\frac{r^2 \\sin^2 E}{b^2} = 1 \\quad \\Rightarrow \\quad r\\sin\\theta = b \\sin E = a \\sqrt{1-e^2} \\sin E $$ 将上面两个等式代入 $\\bm{r}^p$ 中，可以得到用角度 $E$ 表述的坐标： $$ \\bm{r}^p = a \\begin{bmatrix} (\\cos E -e) \\\\ \\sqrt{1-e^2} \\sin E \\\\ 0 \\end{bmatrix} $$ 因此 $$ \\bm{v}^p = \\dot{\\bm{r}}_p = a \\dot{E} \\begin{bmatrix} -\\sin E \\\\ \\sqrt{1-e^2} \\cos E \\\\ 0 \\end{bmatrix} $$ 代入 $\\bm{h}^p = \\bm{r}^p \\times \\bm{v}^p$，整理可得 $$ \\dot{E} \\left( 1-e\\cos E\\right) = \\frac{h}{a^2\\sqrt{1-e^2}} = \\sqrt{\\frac{\\mu}{a^3}} := \\omega_0 $$ 这个微分方程称为开普勒方程。两边积分可得 $$ E(t) - e \\sin E(t) = \\omega_o t + E_0 $$ 如此做，将原本关于 $\\theta(t)$ 的非线性微分方程转化为了关于 $E(t)$ 的非线性方程，避免了数值积分的累计误差。为了求解该方程，可以利用不动点法或牛顿迭代等数值解法以满足所需的精度。 ","date":"2022-03-26","objectID":"/newton2kepler/:4:0","series":null,"tags":["牛顿方程","开普勒定律","开普勒方程"],"title":"从牛顿方程到开普勒定律","uri":"/newton2kepler/#开普勒方程"},{"categories":["奇妙的数学"],"content":" 参考文献 E. Canuto, C. Novara, D. Carlucci, C.P. Montenegro, L. Massotti, Spacecraft Dynamics and Control: The Embedded Model Control Approach, Butterworth-Heinemann, 2018. ","date":"2022-03-26","objectID":"/newton2kepler/:5:0","series":null,"tags":["牛顿方程","开普勒定律","开普勒方程"],"title":"从牛顿方程到开普勒定律","uri":"/newton2kepler/#参考文献"},{"categories":["奇妙的数学"],"content":"复数在处理平面内旋转时具有很简洁的形式，然而复数只有两个自由度，无法处理三维空间内的旋转。为了将复数用于旋转的思想扩展到三维情况，四元数由此诞生。本文简要介绍四元数及其运算规则，推导四元数处理三维旋转的一般形式。 ","date":"2022-03-16","objectID":"/quaternion/:0:0","series":null,"tags":["四元数","旋转"],"title":"四元数与三维旋转","uri":"/quaternion/#"},{"categories":["奇妙的数学"],"content":" 复数与二维旋转在平面参考系 $\\mathscr{E} = \\{\\vec{e}_1, \\vec{e}_2 \\}$ 中，设矢量 $\\vec{a}$ 的坐标为 $\\bm{a} = [a_1, a_2]^\\mathrm{T}$。先将参考系基矢分别映射为复平面的实轴和虚轴，则矢量的坐标可以用复数表示为 $$ \\bm{a} = a_1 + a_2 i = a \\mathrm{e}^{i \\alpha} $$ 提示 我们之前在 坐标变换与矢量旋转 中指出矢量的坐标应当与参考系联系起来，即将参考系作为坐标的上标。在本文的大部分讨论中只涉及一个参考系，故省略上标表示，仅在有必要的情况下显式标记。 其中 $a$ 为矢量 $\\vec{a}$ 的模长，$\\alpha$ 为其与实轴（即 $\\vec{e}_1$）的夹角。利用指数的计算规则，将 $\\vec{a}$ 逆时针旋转 $\\varphi$ 后得到的向量 $\\vec{b}$ 在同一参考系下的坐标可以表示为 $$ \\bm{b} = a \\mathrm{e}^{i (\\alpha+\\varphi)} = \\mathrm{e}^{i \\varphi} a \\mathrm{e}^{i \\alpha} = \\mathrm{e}^{i \\varphi} \\bm{a} $$ 显然，单位模长的复数 $\\mathrm{e}^{i\\varphi}$ 可以很方便地处理平面内矢量的旋转。通常的复数只有一个实部和一个虚部，也就是只有两个自由度。然而空间旋转为三个自由度，因此需要对复数进行扩充，就有了本文将重点讨论的四元数。 ","date":"2022-03-16","objectID":"/quaternion/:1:0","series":null,"tags":["四元数","旋转"],"title":"四元数与三维旋转","uri":"/quaternion/#复数与二维旋转"},{"categories":["奇妙的数学"],"content":" 矩阵形式的旋转在正式讨论四元数之前，有必要先推导矩阵形式下的矢量旋转，其结论将与后面四元数形式的旋转紧密结合。 欧拉定理告诉我们，空间内的任意旋转都可以等价为绕一个方向旋转一个角度。设任意矢量 $\\vec{a}$ 绕单位矢量 $\\vec{v}$ 旋转 $\\varphi$ 角度后得到 $\\vec{b}$，如下图所示 向量旋转的分解 我们将矢量 $\\vec{a}$ 分解为平行于 $\\vec{v}$ 的 $\\vec{a}_\\parallel$ 和垂直于 $\\vec{v}$ 的 $\\vec{a}_\\perp$，分别将其旋转后组合即可得到 $\\vec{b}$。 平行于转轴的分量 $\\vec{a}_\\parallel$ 旋转后保持不变，即 $$ \\vec{b}_\\parallel = \\vec{a}_\\parallel = (\\vec{v} \\cdot \\vec{a}) \\vec{v} $$ 任意选定参考系，上式的坐标形式可以写为 $$ \\bm{b}_\\parallel = \\bm{a}_\\parallel = (\\bm{v}^\\mathrm{T} \\bm{a}) \\bm{v} = \\bm{v}(\\bm{v}^\\mathrm{T} \\bm{a}) = (\\bm{v} \\bm{v}^\\mathrm{T} )\\bm{a} $$ 垂直于转轴的分量 $\\vec{a}_\\perp$ 旋转后，根据上图所示，在 $\\vec{a}_\\perp$ 和 $\\vec{v}\\times\\vec{a}$ 构成的平面内（注意这两个基矢正交，且模长相等），有 $$ \\vec{b}_\\perp = \\vec{a}_\\perp \\cos\\varphi + \\vec{v}\\times\\vec{a}_\\perp \\sin\\varphi = \\vec{a}_\\perp \\cos\\varphi + \\vec{v}\\times\\vec{a} \\sin\\varphi $$ 两个等号分别考虑了投影面第二基矢的等价表述，即 $\\vec{v}\\times\\vec{a}_\\perp = \\vec{v}\\times\\vec{a}$，写成坐标形式，有 $$ \\begin{aligned} \\bm{b}_\\perp \u0026= \\cos\\varphi \\bm{a}_\\perp + \\sin\\varphi \\bm{v} \\times \\bm{a}_\\perp = \\left( \\cos\\varphi + \\sin\\varphi \\bm{v} \\times \\right) \\bm{a}_\\perp \\\\ \u0026= \\cos\\varphi (\\bm{a} - \\bm{a}_\\parallel ) + \\sin\\varphi \\bm{v} \\times \\bm{a} = \\left( \\cos\\varphi \\left(I - \\bm{v} \\bm{v}^\\mathrm{T}\\right) + \\sin\\varphi \\bm{v} \\times \\right) \\bm{a} \\end{aligned} $$ 上式第一行将与后面四元数推导进行对比，联立第二行结果与平行转轴分量的结果，旋转前后矢量的坐标关系为 $$ \\bm{b} = \\bm{b}_\\parallel + \\bm{b}_\\perp = \\left[ \\left(1-\\cos\\varphi\\right)\\bm{v} \\bm{v}^\\mathrm{T} + \\cos\\varphi I + \\sin\\varphi \\bm{v}\\times \\right] \\bm{a} $$ 于是由 $\\vec{a}$ 向 $\\vec{b}$ 的转动对应的矩阵为 $$ R_b^a = \\left(1-\\cos\\varphi\\right)\\bm{v} \\bm{v}^\\mathrm{T} + \\cos\\varphi I + \\sin\\varphi \\bm{v}\\times $$ ","date":"2022-03-16","objectID":"/quaternion/:2:0","series":null,"tags":["四元数","旋转"],"title":"四元数与三维旋转","uri":"/quaternion/#矩阵形式的旋转"},{"categories":["奇妙的数学"],"content":" 四元数基本运算四元数由一个实部和三个虚部构成，设三个虚部分别为 $i,j,k$，其满足 $$ i^2 = j^2 = k^2 = ijk = -1 $$ 我们用花体的变量表示四元数，可以写为 $$ \\mathfrak{q} = q_0 + q_1 i + q_2 j + q_3 k \\quad \\rightarrow \\quad \\begin{bmatrix} q_0 \\\\ \\bm{q} \\end{bmatrix} $$ 箭头右侧为四元数的哈密顿表述，其将实部作为列向量的第一个参数，三个虚部构成四元数的矢量部分。 在后文中，我们将使用符号 $\\otimes$ 表示四元数乘法，并且约定当 $\\otimes$ 作用于三维向量时，应当将三维向量扩充为实部为零的纯四元数，再根据四元数计算规则进行计算。利用四元数虚部的性质，我们可以将四元数乘法写成矩阵的形式，即 $$ \\mathfrak{a} \\otimes \\mathfrak{b} = \\begin{bmatrix} \\begin{array}{c:ccc} a_0 \u0026 -a_1 \u0026 -a_2 \u0026 -a_3 \\\\ \\hdashline a_1 \u0026 a_0 \u0026 -a_3 \u0026 a_2 \\\\ a_2 \u0026 a_3 \u0026 a_0 \u0026 -a_1 \\\\ a_3 \u0026 -a_2 \u0026 a_1 \u0026 a_0 \\end{array} \\end{bmatrix} \\begin{bmatrix} b_0 \\\\ \\hdashline b_1 \\\\ b_2 \\\\ b_3 \\end{bmatrix} = \\begin{bmatrix} a_0 \u0026 -\\bm{a}^\\mathrm{T} \\\\ \\bm{a} \u0026 a_0 I + \\bm{a}\\times \\end{bmatrix} \\begin{bmatrix} b_0 \\\\ \\bm{b} \\end{bmatrix} $$ 类似于矩阵乘法，四元数乘法满足结合律，但一般不满足交换律。同样地，若两个四元数相乘得到 $1$，则称两个四元数互逆，记为 $\\mathfrak{q} \\otimes \\mathfrak{q}^{-1} = \\mathfrak{q}^{-1} \\otimes \\mathfrak{q} = 1$。四元数的模定义为四个分量的平方和开方，即 $$ |\\mathfrak{q}| = \\sqrt{q_0^2 + q_1^2 + q_2^2 + q_3^2} = \\sqrt{ q_0^2 + \\bm{q}^\\mathrm{T}\\bm{q}} = \\sqrt{\\mathfrak{q} \\otimes \\mathfrak{q}^*} $$ 其中 $\\mathfrak{q}^* = [q_0, -\\bm{q}]$ 为 $\\mathfrak{q} = [q_0, \\bm{q}]$ 的共轭。特别地，单位四元数 $|\\mathfrak{q}| = 1$ 的逆与共轭相等，即 $\\mathfrak{q}^{-1}=\\mathfrak{q}^*$，这另上式最后的等号为 $1$ 即可以得出。 ","date":"2022-03-16","objectID":"/quaternion/:3:0","series":null,"tags":["四元数","旋转"],"title":"四元数与三维旋转","uri":"/quaternion/#四元数基本运算"},{"categories":["奇妙的数学"],"content":" 四元数下的旋转为了推导四元数与旋转之家的关系，不妨分别看看四元数乘以不同矢量的效果。在给定参考系下，设四元数矢量部分的坐标为 $\\bm{q}$ ，将四元数表示为 $\\mathfrak{q} = [q_0, \\bm{q}]$。同样，将矢量 $\\bm{a}$ 分解为平行于 $\\bm{q}$ 的分量 $\\bm{a}_\\parallel$ 和垂直分量 $\\bm{a}_\\perp$。 四元数平行分量的乘积为： $$ \\mathfrak{q} \\otimes \\bm{a}_\\parallel = \\begin{bmatrix} q_0 \u0026 -\\bm{q}^\\mathrm{T} \\\\ \\bm{q} \u0026 q_0 I + \\bm{q}\\times \\end{bmatrix} \\begin{bmatrix} 0 \\\\ \\bm{a}_\\parallel \\end{bmatrix} = \\begin{bmatrix} - \\bm{q}^\\mathrm{T} \\bm{a}_\\parallel \\\\ q_0 \\bm{a}_\\parallel \\end{bmatrix} = \\begin{bmatrix} 0 \u0026 -\\bm{a}_\\parallel^\\mathrm{T} \\\\ \\bm{a}_\\parallel \u0026 \\bm{a}_\\parallel \\times \\end{bmatrix} \\begin{bmatrix} q_0 \\\\ \\bm{q} \\end{bmatrix} = \\bm{a}_\\parallel \\otimes \\mathfrak{q} $$ 这个公式虽然没有表现出对 $\\bm{a}_\\parallel$ 的旋转作用，但得到了一个重要结论：如果矢量与四元数的矢量部分平行，那么两者的四元数乘法满足交换律，即 $\\mathfrak{q} \\otimes \\bm{a}_\\parallel = \\bm{a}_\\parallel \\otimes \\mathfrak{q}$。 四元数垂直分量的乘积为： $$ \\mathfrak{q} \\otimes \\bm{a}_\\perp = \\begin{bmatrix} q_0 \u0026 -\\bm{q}^\\mathrm{T} \\\\ \\bm{q} \u0026 q_0 I + \\bm{q}\\times \\end{bmatrix} \\begin{bmatrix} 0 \\\\ \\bm{a}_\\perp \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\left(q_0 + \\bm{q} \\times \\right)\\bm{a}_\\perp \\end{bmatrix} = \\begin{bmatrix} 0 \u0026 -\\bm{a}_\\perp^\\mathrm{T} \\\\ \\bm{a}_\\perp \u0026 \\bm{a}_\\perp \\times \\end{bmatrix} \\begin{bmatrix} q_0 \\\\ -\\bm{q} \\end{bmatrix} = \\bm{a}_\\perp \\otimes \\mathfrak{q}^* $$ 从最两端的等号可以得到“共轭交换律”：如果矢量与四元数的矢量部分垂直，那么两者的四元数乘法满足“共轭交换律”，即 $\\mathfrak{q} \\otimes \\bm{a}_\\perp = \\bm{a}_\\perp \\otimes \\mathfrak{q}^*$。现在我们仔细观察中间结果，可以发现 $\\mathfrak{q} \\otimes \\bm{a}_\\perp$ 依然是纯四元数，其矢量部分与上述矩阵形式下的旋转具有非常相似的结构： $$ \\left(q_0 + \\bm{q} \\times \\right)\\bm{a}_\\perp \\sim \\left( \\cos\\varphi + \\sin\\varphi \\bm{v} \\times \\right) \\bm{a}_\\perp $$ 由此可知，若取 $\\mathfrak{q} = [\\cos\\varphi, \\sin\\varphi \\bm{v}]$，则 $\\mathfrak{q} \\otimes \\bm{a}_\\perp$ 的矢量部分就是将 $\\bm{a}_\\perp$ 沿着矢量 $\\bm{v}$ 转动 $\\varphi$ 角度之后的结果。因此，形如 $\\mathfrak{q}(\\theta) = [\\cos\\theta, \\sin\\theta \\bm{v}]$ （$\\bm{v}$ 为单位矢量）的四元数可以用于矢量的旋转操作，容易证明这是一个单位四元数，且存在以下等式 $$ \\mathfrak{q}(\\theta) \\otimes \\mathfrak{q}(\\theta) = \\begin{bmatrix} \\cos\\theta \u0026 -\\sin\\theta\\bm{v}^\\mathrm{T} \\\\ \\sin\\theta\\bm{v} \u0026 \\cos\\theta I + \\sin\\theta\\bm{v}\\times \\end{bmatrix} \\begin{bmatrix} \\cos\\theta \\\\ \\sin\\theta \\bm{v} \\end{bmatrix} = \\begin{bmatrix} \\cos 2\\theta \\\\ \\sin 2\\theta \\bm{v} \\end{bmatrix} = \\mathfrak{q}(2\\theta) $$ 最后，为了得到更一般矢量的四元数旋转，结合上面的结论可知，将 $\\bm{a}$ 绕 $\\bm{v}$ 旋转 $\\varphi$ 后的矢量的坐标 $\\bm{b}$ 为 $$ \\begin{aligned} \\bm{b} \u0026= \\bm{b}_\\parallel + \\bm{b}_\\perp \\\\ \u0026= \\bm{a}_\\parallel + \\mathfrak{q}(\\varphi) \\otimes \\bm{a}_\\perp \\\\ \u0026= \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\mathfrak{q}^{-1}(\\frac{1}{2}\\varphi) \\otimes \\bm{a}_\\parallel + \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\bm{a}_\\perp \\\\ \u0026= \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\bm{a}_\\parallel \\otimes \\mathfrak{q}^{-1}(\\frac{1}{2}\\varphi) + \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\bm{a}_\\perp \\otimes \\mathfrak{q}^*(\\frac{1}{2}\\varphi) \\\\ \u0026= \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\bm{a}_\\parallel \\otimes \\mathfrak{q}^{-1}(\\frac{1}{2}\\varphi) + \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\bm{a}_\\perp \\otimes \\mathfrak{q}^{-1}(\\frac{1}{2}\\varphi) \\\\ \u0026= \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\left( \\bm{a}_\\parallel + \\bm{a}_\\perp \\right)\\otimes \\mathfrak{q}^{-1}(\\frac{1}{2}\\varphi) \\\\ \u0026= \\mathfrak{q}(\\frac{1}{2}\\varphi) \\otimes \\bm{a} \\otimes \\mathfrak{q}^{-1}(\\frac{1}{2}\\varphi) \\end{aligned} $$ 上式的推导中用到了四元数与平行、垂直矢量相乘的交换律，以及“单位四元数的逆与其共轭相等”的结论。由此可见，任意矢量绕 $\\bm{v}$ 旋转 $\\varphi$ 应当由四元数 $\\mathfrak{q}(\\varphi/2) = [\\cos(\\varphi/2), \\sin(\\varphi/2) \\bm{v}]$ 表述。由 $\\bm{a}$ 到 $\\bm{b}$ 的旋转可以由矩阵和四元数分别表示为 $$ \\bm{b} = R_b^a \\bm{a} = \\mathfrak{q}_b^a \\otimes \\bm{a} \\otimes (\\mathfrak{q}_b^a)^{-1} = \\mathfrak{q}_b^a \\otimes \\bm{a} \\otimes (\\mathfrak{q}_a^b) $$ 最后，考虑旋转矩阵与四元数之间的关系为 $$ \\begin{aligned} R(\\mathfrak{q}_b^a) = R_b^a \u0026= \\left(1-\\cos\\varphi\\right)\\bm{v} \\bm{v}^\\mathrm{T} + \\cos\\varphi I + \\sin\\varphi \\bm{v}\\times \\\\ \u0026= 2 \\sin^2\\frac{\\varphi}{2} \\bm{v} \\bm{v}^\\mathrm{T} + \\left(\\cos^2\\frac{\\varphi}{2} - \\sin^2\\frac{\\varphi}{2}\\right) I +","date":"2022-03-16","objectID":"/quaternion/:4:0","series":null,"tags":["四元数","旋转"],"title":"四元数与三维旋转","uri":"/quaternion/#四元数下的旋转"},{"categories":["奇妙的数学"],"content":" 连续旋转的讨论一个物体多次旋转，旋转矩阵（或四元数）应当是左乘还是右乘？在 坐标变换与矢量旋转 中我们给出的结论是右乘（同参考资料1），而按照这次推导的逻辑：$\\bm{v}_0$ 旋转一次得到 $\\bm{v}_1 = R_1 \\bm{v}_0$，再将 $\\bm{v}_1$ 旋转得到 $\\bm{v}_2 = R_2 \\bm{v}_1 = R_2 R_1 \\bm{v}_0$……以此类推，连续转动时似乎应当左乘（同参考资料2），与之前的结论相反。这应当作何解释？ 两者的关注点不同 如果将连续旋转按右乘的方式并和，最终得到的是矩阵，描述的是参考系（基矢）之间的关系：$\\vec{B} = \\vec{A} R^a_b$；而如果连续左乘，最右边项一定是某个待旋转的矢量的坐标，最后得到的结果是旋转之后的矢量在同一个坐标系下的坐标。 连续旋转的方向矢量坐标不同 在得到“连续左乘”的结论时，我们实际上选定了同一个参考系。从四元数 $\\mathfrak{q} = [\\cos(\\varphi/2), \\sin(\\varphi/2) \\bm{v}]$ 的角度来看，每一次旋转的转轴方向 $\\vec{v}$ 的坐标 $\\bm{v}$ 都是在同一个参考系 $\\mathscr{E}$ 进行表达的；而连续右乘时，后一次旋转的转轴方向是在上一次转动之后的参考系中表达的。 $$ $$ ","date":"2022-03-16","objectID":"/quaternion/:5:0","series":null,"tags":["四元数","旋转"],"title":"四元数与三维旋转","uri":"/quaternion/#连续旋转的讨论"},{"categories":["奇妙的数学"],"content":" 参考文献 E. Canuto, C. Novara, D. Carlucci, C.P. Montenegro, L. Massotti, Spacecraft Dynamics and Control: The Embedded Model Control Approach, Butterworth-Heinemann, 2018. Krasjet, A brief introduction to the quaternions and its applications in 3D geometry. 3Blue1Brown, 四元数的可视化. ","date":"2022-03-16","objectID":"/quaternion/:6:0","series":null,"tags":["四元数","旋转"],"title":"四元数与三维旋转","uri":"/quaternion/#参考文献"},{"categories":["奇妙的数学"],"content":"在多体动力学建模中，通常会建立多个坐标系，其中会涉及大量的坐标变换。坐标变换是由于参考系的姿态差异导致，因此与旋转存在联系。本文旨在讨论坐标变换与旋转之间的数学关系与区别，并推导坐标变换矩阵的动力学特性。 ","date":"2022-03-08","objectID":"/vectortransform/:0:0","series":null,"tags":["坐标变换","矢量旋转"],"title":"坐标变换与矢量旋转","uri":"/vectortransform/#"},{"categories":["奇妙的数学"],"content":" 矢量的坐标表示有大小和方向的物理量称为矢量（Vector），通常用带箭头的符号表示，如 $\\vec{r}$。为了定量描述与计算，需要选定基矢构成参考系，利用矢量合成原理进行表述。如下图所示，参考系 $\\mathscr{A} = \\{O,\\,\\vec{a}_1,\\,\\vec{a}_2 \\}$ 以 $O$ 为原点，$\\vec{a}_1$ 和 $\\vec{a}_2$ 为基矢。任意矢量 $\\vec{r}$ 可以写作 矢量的坐标分解 $$ \\vec{r} = r_1^a \\vec{a}_1 + r_2^a \\vec{a}_2 = \\begin{bmatrix} \\vec{a}_1 \u0026 \\vec{a}_2 \\end{bmatrix} \\begin{bmatrix} r_1^a \\\\ r_2^a \\end{bmatrix} = \\vec{A} \\bm{r}^a $$ 这里我们使用带箭头的大写字母表示参考系基矢构成的行向量，即 $\\vec{A} = [\\vec{a}_1, \\vec{a}_2]$；选定基矢后，基矢的组合系数构成列向量，为矢量的坐标（Coordinate），用加粗的字母表示，并将参考系标记在上标的位置，本例中为 $\\bm{r}^a= [r_1^a, r_2^a]^\\mathrm{T}$。在此记号下，我们可以使用矩阵的计算方法将适量表示为基矢与坐标的组合，即上式最后的等号。在后文的推导中，我们将使用更一般的三维形式，而为了方便理解，示意图保持为二维形式。 注解 在实际操作中，如果只涉及一个参考系，通常没有必要严格区分矢量与坐标之间的关系，因此在一般的教科书中会将上图所示的矢量直接记做 $\\vec{r} = [r_1, r_2]^\\mathrm{T}$。本文涉及多个参考系，务必区分矢量与坐标之间的关系：矢量是一个“不变量”，与参考系无关，而其坐标因参考系的不同而发生改变。因此，严格意义上说，只有将参考系（基矢）和坐标合起来才能准确表示一个矢量。 如无特别说明，参考系的基矢通常选为单位正交基，其点积满足 $$ \\vec{A}^\\mathrm{T} \\cdot \\vec{A} = \\begin{bmatrix} \\vec{a}_1 \\\\ \\vec{a}_2 \\\\ \\vec{a}_3 \\end{bmatrix} \\cdot \\begin{bmatrix} \\vec{a}_1 \u0026 \\vec{a}_2 \u0026 \\vec{a}_3 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \\end{bmatrix} = I_{3 \\times 3} $$ 由此我们可以获知坐标的计算方法： $$ \\bm{r}^a = I_{3 \\times 3} \\bm{r}^a = \\left( \\vec{A}^\\mathrm{T} \\cdot \\vec{A} \\right) \\bm{r}^a = \\vec{A}^\\mathrm{T} \\cdot \\left( \\vec{A} \\bm{r}^a \\right) = \\vec{A}^\\mathrm{T} \\cdot \\vec{r} = \\begin{bmatrix} \\vec{a}_1 \\cdot \\vec{r} \\\\ \\vec{a}_2 \\cdot \\vec{r} \\\\ \\vec{a}_3 \\cdot \\vec{r} \\\\ \\end{bmatrix} $$ 上式指出，为了获取矢量在给定参考系下的坐标，只需计算矢量与参考各基矢之间的点积即可，即：坐标是矢量在基矢方向的投影。 ","date":"2022-03-08","objectID":"/vectortransform/:1:0","series":null,"tags":["坐标变换","矢量旋转"],"title":"坐标变换与矢量旋转","uri":"/vectortransform/#矢量的坐标表示"},{"categories":["奇妙的数学"],"content":" 坐标变换选取的参考系不同，相同矢量的坐标不同。参考系之间的平移可以简单地通过矢量加法实现，因此这里的坐标变换重点关注参考系之间的转动，设它们的原点重合（因此后文直接用基矢表示各参考系），如下图所示。 坐标变换示意图 矢量 $\\vec{r}$ 可以在两个参考系中分别表述为 $$ \\vec{r} = \\vec{A} \\bm{r}^a = \\vec{B} \\bm{r}^b $$ 考察坐标之间的关系，不难得到 $$ \\bm{r}^b = \\vec{B} \\cdot \\vec{r} = \\vec{B}^\\mathrm{T} \\cdot \\left( \\vec{A} \\bm{r}^a \\right) = \\left( \\vec{B}^\\mathrm{T} \\cdot \\vec{A} \\right) \\bm{r}^a = R_a^b \\bm{r}^a $$ 其中 $R_a^b$ 为坐标变换矩阵，其表示从参考系 $\\vec{A}$ 到参考系 $\\vec{B}$ 的坐标变换（从下往上读）。从上式的两端可以发现，在这种表述方式下，角标形式上具有“相互抵消”的性质，即：如果左侧变量的下标与右侧变量的上标相同，则抵消两个角标并根据左侧变量的上标替换掉右侧变量的上标。后面讨论的连续坐标变换能够充分体现这种特性。 坐标变换矩阵 $R_a^b$ 具体展开为 $$ \\begin{aligned} R_a^b \u0026= \\begin{bmatrix} \\vec{B}^\\mathrm{T} \\cdot \\vec{a}_1 \u0026 \\vec{B}^\\mathrm{T} \\cdot \\vec{a}_2 \u0026 \\vec{B}^\\mathrm{T} \\cdot \\vec{a}_3 \\end{bmatrix} = \\begin{bmatrix} \\bm{a}_1^b \u0026 \\bm{a}_2^b \u0026 \\bm{a}_2^b \\end{bmatrix} \\\\ \u0026= \\begin{bmatrix} \\vec{b}_1 \\cdot \\vec{A} \\\\ \\vec{b}_2 \\cdot \\vec{A} \\\\ \\vec{b}_3 \\cdot \\vec{A} \\\\ \\end{bmatrix} = \\begin{bmatrix} \\left(\\bm{b}_1^a\\right)^\\mathrm{T} \\\\ \\left(\\bm{b}_2^a\\right)^\\mathrm{T} \\\\ \\left(\\bm{b}_3^a\\right)^\\mathrm{T} \\end{bmatrix} \\end{aligned} $$ 上式中，第一行说明坐标变换矩阵可以按列解释：每一列分别由参考系 $\\vec{A}$ 的各基矢在参考系 $\\vec{B}$ 中的坐标组成；第二行说明该矩阵也可以按行解释：每一行为参考系 $\\vec{B}$ 的各基矢在参考系 $\\vec{A}$ 中的坐标（的转制）组成 。我们通常倾向于按列解释，这样可以保持上标的一致性。由于单位向量的点积等于夹角的余弦，因此坐标变换矩阵也称作方向余弦矩阵（DCM, Direction Cosine Matrix）。 考虑矢量 $\\vec{r}$ 按照 $\\vec{A} \\rightarrow \\vec{B}_1 \\rightarrow \\vec{B}_2 \\rightarrow \\cdots \\rightarrow \\vec{B}_n$ 的顺序进行 $n$ 次坐标变换，有 $$ \\bm{r}^{b_n} = R_{b_{n-1}}^{b_n} \\bm{r}^{b_{n-1}} = R_{b_{n-1}}^b \\left( R_{b_{n-2}}^{b_{n-1}}\\bm{r}^{b_{n-2}} \\right) = \\cdots = \\left( R_{b_{n-1}}^b R_{b_{n-2}}^{b_{n-1}} \\cdots R_a^{b_{1}} \\right) \\bm{r}^a $$ 即 $$ R_a^{b_n} = R_{b_{n-1}}^{b_n} R_{b_{n-2}}^{b_{n-1}} \\cdots R_a^{b_{1}} $$ 说明连续坐标变换矩阵为各坐标变换矩阵按顺序左乘的结果。 最后，我们重新将坐标变换矩阵代回到矢量表达式中，得 $$ \\vec{r} = \\vec{A} \\bm{r}^a = \\vec{B} \\bm{r}^b = \\vec{B} R_a^b \\bm{r}^a \\quad \\Rightarrow \\quad \\vec{A} = \\vec{B} R_a^b $$ 最后的等号暗示了坐标系之间的关系，将在后文矢量旋转那里做进一步说明。利用基矢的正交性，有 $$ I_{3 \\times 3} = \\vec{A}^\\mathrm{T} \\cdot \\vec{A} = \\left( \\vec{B} R_a^b \\right)^\\mathrm{T} \\cdot \\left( \\vec{B} R_a^b \\right) = \\left(R_a^b \\right)^\\mathrm{T} \\left(\\vec{B}^\\mathrm{T} \\cdot \\vec{B}\\right) R_a^b = \\left(R_a^b \\right)^\\mathrm{T} R_a^b $$ 这说明坐标变换矩阵 $R_a^b$ 为正交矩阵，即 $\\left(R_a^b \\right)^{-1} = \\left(R_a^b \\right)^\\mathrm{T}$。我们可以令 $R_b^a = \\left(R_a^b \\right)^{-1}$，则 $R_a^b R_b^a = R_b^a R_a^b = I$ 意味着来回变换之后坐标保持不变（这里可以再次看到角标之间的“抵消”性质）。 ","date":"2022-03-08","objectID":"/vectortransform/:2:0","series":null,"tags":["坐标变换","矢量旋转"],"title":"坐标变换与矢量旋转","uri":"/vectortransform/#坐标变换"},{"categories":["奇妙的数学"],"content":" 矢量旋转将目光限定在参考系 $\\vec{A}$ 中，现在将矢量 $\\vec{r}_1$ 进行一定的旋转，得到 $\\vec{r}_2$ ，如何得到它们坐标 $\\bm{r}_1^a$ 和 $\\bm{r}_2^a$ 之间的关系？ 矢量旋转示意图 考虑 $\\vec{r}_1$ 连同参考系（的基矢） $\\vec{A}$ 一起旋转，当 $\\vec{r}_1$ 转到 $\\vec{r}_2$ 的位置时 $\\vec{A}$ 相应地变成 $\\vec{B}$。由于是一起旋转，相对关系保持不变，即 $\\vec{r}_2$ 在 $\\vec{B}$ 的坐标等于 $\\vec{r}_1$ 在 $\\vec{A}$ 的坐标，即 $\\bm{r}_2^b = \\bm{r}_1^a$，考虑到坐标变换有 $\\bm{r}_2^a = R_b^a \\bm{r}_2^b$，可以得到 $$ \\bm{r}_2^a = R_b^a \\bm{r}_1^a $$ 这就说明，坐标变换矩阵同时具有旋转的含义，也可称之为旋转矩阵， $R_b^a$ 表示从参考系 $\\vec{A}$ 到参考系 $\\vec{B}$ 的旋转（从上往下读，注意这里交换了角标）。 在对实际物体旋转的描述中，通常使用本体坐标系之间的关系。在上文我们实际上已经得到了 $\\vec{A} = \\vec{B} R_a^b$，这同样可以“从上往下”地解读为 $\\vec{B}$ 旋转到 $\\vec{A}$。 考虑参考系 $\\vec{r}$ 按照 $\\vec{A} \\rightarrow \\vec{B}_1 \\rightarrow \\vec{B}_2 \\rightarrow \\cdots \\rightarrow \\vec{B}_n$ 的顺序进行 $n$ 次旋转，有 $$ \\vec{B}_n = \\vec{B}_{n-1} R_{b_{n}}^{b_{n-1}} = \\vec{B}_{n-2} R_{b_{n-1}}^{b_{n-2}} R_{b_{n}}^{b_{n-1}} = \\cdots = \\vec{A} R_{b_1}^a \\cdots R_{b_{n-1}}^{b_{n-2}} R_{b_{n}}^{b_{n-1}} $$ 即 $\\vec{A}$ 到 $\\vec{B}_n$ 的连续旋转结果为 $$ R_{b_n}^a = R_{b_1}^a R_{b_2}^{b_1} \\cdots R_{b_{n}}^{b_{n-1}} $$ 最终的旋转矩阵 $R_b^a$ 为各次旋转矩阵按顺序右乘的结果。 ","date":"2022-03-08","objectID":"/vectortransform/:3:0","series":null,"tags":["坐标变换","矢量旋转"],"title":"坐标变换与矢量旋转","uri":"/vectortransform/#矢量旋转"},{"categories":["奇妙的数学"],"content":" 转动的描述最后我们来看一下坐标变换矩阵（或者说转动矩阵）的运动学特性。首先如下图所示，假设参考系 $\\vec{B}$ （通常为刚体的本体参考系）的角速度为 $\\bm{\\omega}_b^b = [\\omega_1,\\omega_2,\\omega_3]^\\mathrm{T}$（注意角速度都是在本体坐标系下建立的，各分量省略了上标），以基矢 $\\vec{b}_1$ 为例，在 $\\mathrm{d}t$ 时间内其变化量为 转动角速度示意图 $$ \\mathrm{d}\\vec{b}_1 = (\\omega_3 \\mathrm{d} t) \\vec{b}_2 -(\\omega_2 \\mathrm{d}t)\\vec{b}_3 + \\quad \\Rightarrow \\quad \\dot{\\vec{b}}_1 = \\omega_3 \\vec{b}_2 -\\omega_2 \\vec{b}_3 $$ 类似地，将三个基矢的导数整理为 $$ \\begin{aligned} \\dot{\\vec{B}} \u0026= \\begin{bmatrix} \\omega_3 \\vec{b}_2 -\\omega_2 \\vec{b}_3 \u0026 -\\omega_3 \\vec{b}_1 + \\omega_1 \\vec{b}_3 \u0026 \\omega_2 \\vec{b}_1 - \\omega_1 \\vec{b}_2 \\end{bmatrix} \\\\ \u0026= \\begin{bmatrix} \\vec{b}_1 \u0026 \\vec{b}_2 \u0026 \\vec{b}_3 \\end{bmatrix} \\begin{bmatrix} 0 \u0026 -\\omega_3 \u0026 \\omega_2 \\\\ \\omega_3 \u0026 0 \u0026 -\\omega_1 \\\\ -\\omega_2 \u0026 \\omega_1 \u0026 0 \\end{bmatrix} \\\\ \u0026= \\vec{B} \\bm{\\omega}_b^b \\times \\end{aligned} $$ 我们将上式最后的 $3 \\times 3$ 矩阵记做 $\\bm{\\omega}_b^b \\times$，这样的表述与矢量的叉乘一致，且 $(\\bm{\\omega}_b^b \\times)^\\mathrm{T} = -\\bm{\\omega}_b^b \\times$ 为反对称矩阵。最后，我们考察任意参考系 $\\vec{A}$ 向本体系 $\\vec{B}$ 的转动矩阵 $R_b^a$ 的导数，得 $$ \\begin{aligned} \\dot{R}_b^a \u0026= \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\vec{A}^\\mathrm{T} \\cdot \\vec{B} \\right) \\\\ \u0026= \\dot{\\vec{A}}{}^\\mathrm{T} \\cdot \\vec{B} + \\vec{A}^\\mathrm{T} \\cdot \\dot{\\vec{B}} \\\\ \u0026= (\\bm{\\omega}_a^a \\times)^\\mathrm{T} \\vec{A}^\\mathrm{T} \\cdot \\vec{B} + \\vec{A}^\\mathrm{T} \\cdot \\vec{B} (\\bm{\\omega}_b^b \\times) \\\\ \u0026= -(\\bm{\\omega}_a^a \\times) R_b^a + R_b^a \\bm{\\omega}_b^b \\times \\\\ \u0026= -R_b^a (\\bm{\\omega}_a^b \\times) + R_b^a \\bm{\\omega}_b^b \\times \\\\ \u0026= R_b^a \\bm{\\omega}_{ab}^b \\times \\end{aligned} $$ 式中 $\\bm{\\omega}_{ab}^b = \\bm{\\omega}_b^b - \\bm{\\omega}_a^b$ 表示参考系之间的相对角速度在 $\\vec{B}$ 参考系下的坐标。推导的倒数第二行使用了如下等式 $$ \\bm{\\omega}_a^b \\times = \\left( R_a^b \\bm{\\omega}_a^a \\right) \\times = R_a^b (\\bm{\\omega}_a^a \\times) R_b^a $$ 该等式的简单证明可以从角速度叉乘 $\\vec{\\omega}_a \\times \\vec{\\omega}_b$ 在两个参考系下的表达获得： $$ \\left\\{\\begin{aligned} \\vec{\\omega}_a \\times \\vec{\\omega}_b \u0026= \\vec{A} \\bm{\\omega}_a^a \\times \\bm{\\omega}_b^a = \\vec{A} (\\bm{\\omega}_a^a \\times) R_b^a \\bm{\\omega}_b^b \\\\ \\vec{\\omega}_a \\times \\vec{\\omega}_b \u0026= \\vec{B} \\bm{\\omega}_a^b \\times \\bm{\\omega}_b^b =\\vec{A}R_b^a \\bm{\\omega}_a^b \\times \\bm{\\omega}_b^b \\end{aligned}\\right. \\\\ \\Downarrow \\\\ (\\bm{\\omega}_a^a \\times) R_b^a = R_b^a \\bm{\\omega}_a^b \\times \\\\ \\Downarrow \\\\ \\bm{\\omega}_a^b \\times = \\left( R_a^b \\bm{\\omega}_a^a \\right) \\times = R_a^b (\\bm{\\omega}_a^a \\times) R_b^a $$ ","date":"2022-03-08","objectID":"/vectortransform/:4:0","series":null,"tags":["坐标变换","矢量旋转"],"title":"坐标变换与矢量旋转","uri":"/vectortransform/#转动的描述"},{"categories":["奇妙的数学"],"content":" 参考文献 E. Canuto, C. Novara, D. Carlucci, C.P. Montenegro, L. Massotti, Spacecraft Dynamics and Control: The Embedded Model Control Approach, Butterworth-Heinemann, 2018. ","date":"2022-03-08","objectID":"/vectortransform/:5:0","series":null,"tags":["坐标变换","矢量旋转"],"title":"坐标变换与矢量旋转","uri":"/vectortransform/#参考文献"},{"categories":["数字信号处理"],"content":"级联积分梳状（CIC, Cascaded Integrator–Comb）滤波器是一种非常“经济”的滤波器。它的实现所需资源少、具有线性相位，同时实现采样率的改变，通常可用于模数转换器（ADC, Analog to Digital Converter）的抗混叠滤波。本文简要介绍 CIC 滤波器的基本原理及其实现方法，分析该滤波器的频率响应，然后给出 CIC 滤波器在降采样（抽取）和升采样（插值）的应用，最后给出降采样倍数的一般设计方法。 ","date":"2022-02-13","objectID":"/introcic/:0:0","series":null,"tags":["CIC","滤波器","降采样","升采样"],"title":"CIC 滤波器简介","uri":"/introcic/#"},{"categories":["数字信号处理"],"content":" 从降采样说起如何将高速采集的数据按照一定的倍数 $R$ 降低采样率？最简单的方法就是从每 $R$ 个数中直接抽取。然而，我们之前在 傅立叶变换与频域分析 讨论过直接抽取所引入的频率混叠问题，为了避免降采样引起的混叠，必须对数据进行滤波处理。考虑到滤波就是一种平均，那么，简单起见，我们只需要对 $R$ 个数取算数平均值作为输出即可。该系统的表达式可以写为： $$ y(i) = \\frac{1}{R} \\left( x(iR) + x(iR-1) + \\cdots + x((i-1)R+1) \\right) = \\frac{1}{R} \\sum_{k=0}^{R-1} x(iR-k) $$ 如果我们省略掉归一化系数 $R^{-1}$ ，如果直接实现上述过程，需要 $R-1$ 个寄存器进行单位延时，系统如下图所示。 使用串联寄存器实现降采样 容易想象，当我们需要进行高倍数的降采样时，所需要的寄存器（单位延时）数量会大大增加，这对数字系统设计是非常不“经济”的。下面我们就来讨论 CIC 是如何使用更“经济”的方法实现上述系统。 ","date":"2022-02-13","objectID":"/introcic/:1:0","series":null,"tags":["CIC","滤波器","降采样","升采样"],"title":"CIC 滤波器简介","uri":"/introcic/#从降采样说起"},{"categories":["数字信号处理"],"content":" CIC 滤波器的实现省略归一化系数，算数平均值（或者说 $R$ 项累加器）的传递函数可以用 $z$ 变换表示为 $$ H(z) = \\sum_{k=0}^{R-1} z^{-k} = \\frac{1-z^{-R}}{1-z^{-1}} = \\underbrace{\\frac{1}{1-z^{-1}}}_{H_I(z)} \\underbrace{\\left(1-z^{-R}\\right)}_{H_C(z)} $$ 我们把传递函数人为地分为了两部分：$H_I(z)$ 为数字积分（累加）部分，只需要一个 $z^{-1}$ 就可以实现；$H_C(z)$ 为梳状（差分）部分，原则上需要使用 $R$ 个 $z^{-1}$。神奇之处就在这里，CIC 滤波器在进行差分之前，先进行了 $R$ 倍的降采样，因此降采样之后的一个单位延时 $z_R^{-1}$ 就能实现 $z^{-R}$ 的效果。如此做，CIC 滤波器将原本应当使用 $R-1$ 个寄存器减少到了只需要使用两个寄存器！ 注意 在 $z$ 变换中，$z^{-1}$ 代表一个单位时间的延时，由一个寄存器实现，而这个“单位时间”的实际长度取决于数据的采样速率，一般的设计中都是同一个常数而不会引起混淆。由于本文的讨论中涉及到采样率的改变，因此我使用了 $z_R^{-1}$ 来表示低速数据的单位延时。也就是说，将高速数据的单位时间记做 $T_s$ （采样率记做 $f_s=1/T_s$ ），$z^{-1}$ 表示 $T_s$ 时间的延时，而 $z_R^{-1} = z^{-R}$ 表示 $RT_s$ 时间的延时。显式地使用 $z_R^{-1}$ 是为了强调只用了一个在“低速”寄存器而不是 $R$ 个“高速”寄存器。 进一步地，如果只使用 $R$ 个数据的算数平均无法满足滤波的需求怎么办？我们可以从两方面入手：首先从数学上，我们可以使用更长的数据进行平均（求和）。考虑后级 $1-z_R^{-1} = 1-z^{-R}$ 是从前级的累加中进行差分，即“前 $iR$ 次数据的累加和减去前 $(i-1)R$ 个数据的累加和”而得到“最近 $R$ 个数据的累加和”，也就是说 $z_R^{-1}$ 和 $1=z_R^0$ 是求和数据的区间。如果将 $1-z_R^{-1}$ 改为 $1-z_R^{-M}$ ，就变成了最近 $MR$ 长度的数据进行累加，也就是我们所说使用更长的数据进行平均。另一方面，从系统的角度将，我们还可以将传递函数进行 $N$ 次方以实现“多次重复”滤波。 综合上述两种考虑，一般形式的 CIC 滤波器具有以下形式的传递函数，其中 $R$、$M$、$N$ 为滤波器参数。 $$ H(z) = \\left( \\frac{1-z^{-RM}}{1-z^{-1}} \\right)^N = \\left(\\frac{1}{1-z^{-1}}\\right)^N \\left( 1-z_R^{-M} \\right)^N = H_I^N(z) H_C^N(z) $$ 工程实践中一般取 $M=1,2$ 。 CIC 滤波器用于降采样时的系统框图如下 CIC 抽取器结构示意图 用于升采样时，只需要将梳状部分和积分部分交换即可，如下图所示 CIC 插值器结构示意图 小结：CIC 滤波器使用高速度累加和低速率差分，使用时根据降/升采样目标调整积分部分和梳状部分的顺序即可。 ","date":"2022-02-13","objectID":"/introcic/:2:0","series":null,"tags":["CIC","滤波器","降采样","升采样"],"title":"CIC 滤波器简介","uri":"/introcic/#cic-滤波器的实现"},{"categories":["数字信号处理"],"content":" CIC 滤波器的频率响应为了得到 CIC 滤波器的频率响应，将 $z=\\mathrm{e}^{j\\omega}$ 带入传递函数即可。需要注意的是，这里的 $z$ 代表的是高速采样率 $f_s$ 下的算子，数字频率 $\\omega$ 与实际频率 $f$ 的关系为 $$ \\omega = 2 \\pi \\frac{f}{f_s} $$ 考虑到 $$ \\begin{aligned} 1- \\mathrm{e}^{-j\\theta} \u0026= 1- \\left(\\cos\\theta - j \\sin\\theta\\right) \\\\ \u0026= 1-\\cos\\theta + 2j \\sin\\frac{\\theta}{2}\\cos\\frac{\\theta}{2} \\\\ \u0026= 2\\sin^2\\frac{\\theta}{2} + 2j \\sin\\frac{\\theta}{2}\\cos\\frac{\\theta}{2} \\\\ \u0026= 2j \\sin\\frac{\\theta}{2} \\left(-j\\sin\\frac{\\theta}{2} + \\cos\\frac{\\theta}{2} \\right) \\\\ \u0026= 2j \\sin\\frac{\\theta}{2} \\mathrm{e}^{-j\\frac{\\theta}{2}} \\end{aligned} $$ CIC 滤波器的传递函数可以写为 $$ H(\\mathrm{e}^{j\\omega}) = \\left( \\frac{1-\\mathrm{e}^{ -jRM\\omega }}{1-\\mathrm{e}^{- j\\omega}} \\right)^N = \\left( \\frac{\\sin\\frac{RM}{2}\\omega}{\\sin\\frac{1}{2}\\omega} \\right)^N \\mathrm{e}^{-j\\frac{RM-1}{2}N\\omega} $$ 因此幅频响应为 $$ \\left| H(\\mathrm{e}^{j\\omega})\\right| = \\left| \\frac{\\sin\\frac{RM\\omega}{2}}{\\sin\\frac{\\omega}{2}} \\right|^N \\xrightarrow{R\\rightarrow \\infty} (RM)^N \\left(\\frac{\\sin\\frac{RM\\omega}{2}}{\\frac{\\omega}{2}} \\right)^N = (RM)^N \\left| \\mathrm{sinc}\\, \\frac{RM\\omega}{2} \\right|^N $$ 当 $R\\rightarrow\\infty$ 时幅频响应趋近于 $\\mathrm{sinc}$ 函数，因此 CIC 滤波器也称为 SINC 滤波器。 从传递函数 $\\mathrm{e}$ 指数的虚部可以看出 CIC 滤波器的相频响应为 $$ \\varphi(\\omega) = -\\frac{RM-1}{2}N\\omega $$ 其具有线性相位，群延时为常数 $$ \\tau = -\\frac{\\partial \\varphi (\\omega)}{\\partial \\omega} = \\frac{RM-1}{2}N $$ 即 CIC 滤波器对信号有 $\\tau$ 个采样点的延时，即 $\\Delta t = \\tau T_s$ 。 ","date":"2022-02-13","objectID":"/introcic/:3:0","series":null,"tags":["CIC","滤波器","降采样","升采样"],"title":"CIC 滤波器简介","uri":"/introcic/#cic-滤波器的频率响应"},{"categories":["数字信号处理"],"content":" 降采样倍数的设计最后我们讨论一下降采样倍数的设计，这实际上是指过采样设计，可以描述为这么一个问题：已知 ADC 的位数 为 $\\mu_y$ ，参考电压为 $\\pm V_\\mathrm{ref}$，记输出的采样率为 $f_s$。为了减小 ADC 的量化误差，通常先进行高速采样（过采样，oversampling）将量化误差分布在更宽的频带从而减小其功率谱密度，然后再降采样。若要求 ADC 量化误差的功率谱密度不超过 $S_{w,\\max} \\, [\\mathrm{V/\\sqrt{Hz}}]$，降采样倍数（或者说过采样倍数）$R$ 最小应当取多少？ 首先，ADC 对正负电压进行采样，其量化的电压分辨率为 $$ \\rho_y = \\frac{V_\\mathrm{ref}}{2^{\\mu_y-1}} $$ 假设量化误差在时域上均匀分布，则方差为 $$ \\sigma_w^2 = = \\int_{-\\rho_y/2}^{\\rho_y/2} x^2 \\frac{1}{\\rho_y} \\,\\mathrm{d}x = \\frac{1}{12} \\rho_y^2 $$ 进一步假设量化误差在频域上为白噪声。过采样的采样率为 $Rf_s$ ，则噪声将均匀分布在 $Rf_s/2$ 频带内，根据 Parseval 等式有 $$ S_w^2 \\frac{Rf_s}{2} = \\sigma_w^2 \\quad \\Rightarrow \\quad S_w^2 = \\frac{2\\sigma_w^2}{Rf_s} \\le S_{w,\\mathrm{max}}^2 $$ 根据谱密度需求，有 $$ R \\ge R_\\mathrm{min} = \\left \\lceil \\frac{2\\sigma_w^2}{f_sS_{w,\\mathrm{max}}^2 } \\right \\rceil = \\left \\lceil \\frac{1}{6f_s S_{w,\\mathrm{max}}^2} \\left(\\frac{V_\\mathrm{ref}}{2^{\\mu_y-1}}\\right)^2 \\right \\rceil $$ ","date":"2022-02-13","objectID":"/introcic/:4:0","series":null,"tags":["CIC","滤波器","降采样","升采样"],"title":"CIC 滤波器简介","uri":"/introcic/#降采样倍数的设计"},{"categories":["数字信号处理"],"content":" 参考文献 E. Hogenauer, An Economical Class of Digital Filters for Decimation and Interpolation, IEEE Transactions on Acoustics, Speech, and Signal Processing. 29 (1981) 155–162. ","date":"2022-02-13","objectID":"/introcic/:5:0","series":null,"tags":["CIC","滤波器","降采样","升采样"],"title":"CIC 滤波器简介","uri":"/introcic/#参考文献"},{"categories":["生命在于折腾"],"content":"最近有兴趣折腾了一下 Arch Linux，并在虚拟机中成功安装。将安装步骤记录于此，下一次就真机实战。 ","date":"2021-12-26","objectID":"/installarch/:0:0","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#"},{"categories":["生命在于折腾"],"content":" 安装命令汇总为了方便查阅，将本次涉及到的所有命令先汇总如下，以便查阅。 注意 命令中缩进的部分表示进入了交互模式或者打开了文件，文件只给出关键部分的设置以供参考。由中括号如 [hostname] 给出的变量可能会因机器而不同，使用时应当连同中括号一起替换掉。 bash # 确认 UEFI 模式 ls /sys/firmware/efi/efivars # 有输出即可 # 连接网络 ip link # 检查网络接口 iwctl # 交互式连接无线网络 device list # 列出无线网卡设备名 station [wlan0] scan # 扫描网络 [] 内部待替换 station [wlan0] get-networks # 列出所有 wifi 网络 station [wlan0] connect [wifi-name] # 进行连接 exit # 退出交互模式 ping bilibili.com # 检查网络连接 # 同步时间 timedatectl set-ntp true # 将系统时间与网络时间进行同步 timedatectl status # 检查服务状态 # 更改软件镜像源 vim /etc/pacman.d/mirrorlist Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch pacman -Syy # 分区 fdisk -l fdisk /dev/sd[a] # SATA协议：sd[a]，NVME 协议：nvme[1]n1 # 交互式新建 EFI 分区、根目录、swap 等 mkfs.fat -F32 /dev/sda[1] # 格式化 EFI 分区 mkfs.ext4 /dev/sda[2] # 根目录 mkfs.ext4 /dev/sda[3] # 其他目录，如 /home mkswap /dev/sda[4] # 创建 swap 分区 fdisk -l # 挂载 mount /dev/sda[2] /mnt # 一定要先挂载根目录 mkdir /mnt/boot mount /dev/sda[1] /mnt/boot mkdir /mnt/home mount /dev/sda[3] /mnt/home swapon /dev/sda[4] # 安装系统 pacstrap /mnt base linux linux-firmware # 安装系统 genfstab -U /mnt \u003e\u003e /mnt/etc/fstab # 生成 fstab 文件 # 切换到新系统 arch-chroot /mnt # 主机配置 echo '[hostname]' \u003e /etc/hostname # 设置主机名 pacman -S vim # 安装 vim vim /etc/hosts # 填入以下内容 127.0.0.1 localhost ::1 localhost 127.0.1.1 [hostname].localdomain [hostname] # 时间设置 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 设置时区 hwclock --systohc # 同步时间 # 区域设置 vim /etc/locale.gen # 去掉注释 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 locale-gen echo 'LANG=en_US.UTF-8' \u003e /etc/locale.conf # root 密码 passwd # GRUB 设置 pacman -S intel-ucode # AMD CPU 使用 amd-ucode pacman -S grub efibootmgr os-prober uname -m # 查看 CPU 架构 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH vim /etc/default/grub # 适当调整，可以跳过 grub-mkconfig -o /boot/grub/grub.cfg # 网络管理软件 pacman -S dhcpcd iwd # 重启 exit umount -R /mnt reboot # 进入新系统 systemctl enable --now dhcpcd systemctl start iwd # 无线网络 iwctl # 交互式连接无线网络 device list # 列出无线网卡设备名 station [wlan0] scan # 扫描网络 [] 内部待替换 station [wlan0] get-networks # 列出所有 wifi 网络 station [wlan0] connect [wifi-name] # 进行连接 exit # 退出交互模式 ping bilibili.com # 使用 Ctrl+C 停止测试 pacman -Syyu # 更新系统 # 创建普通用户 pacman -S sudo useradd -m -G wheel [username] passwd [username] EDITOR=vim visudo # 去掉注释（保留%） %wheel ALL=(ALL) ALL # 安装 KDE 桌面环境 pacman -S plasma-meta konsole dolphin git base-devel systemctl enable sddm reboot # 进入桌面环境 sudo systemctl disable iwd # 关闭 iwd 开机自启 sudo systemctl stop iwd # 立即关闭 iwd 服务 sudo systemctl enable --now NetworkManager # 启动 NetworkManager 并确保开机自启 ping bilibili.com # 修改软件镜像源设置 sudo vim /etc/pacman.conf # 删除 [multilib] 注释 [multilib] Include = /etc/pacman.d/mirrorlist sudo pacman -Syu # 安装 AUR 管理软件 yay git clone https://aur.archlinux.org/yay --depth 1 cd yay export GO111MODULE=on # 临时 GO 换源 export GOPROXY=https://goproxy.cn makepkg -si # 中文配置 sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra sudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-pinyin-zhwiki vim ~/.pam_environment INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=\\@im=fcitx5 SDL_IM_MODULE DEFAULT=fcitx ","date":"2021-12-26","objectID":"/installarch/:1:0","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#安装命令汇总"},{"categories":["生命在于折腾"],"content":" 安装步骤说明插入 U 盘启动盘，或者虚拟机中使用安装镜像文件，进入 Arch Linux 的安装环境，我们将看到黑底白字的命令行……那就准备开始吧！ ","date":"2021-12-26","objectID":"/installarch/:2:0","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#安装步骤说明"},{"categories":["生命在于折腾"],"content":" 确认启动模式首先确认启动模式，运行下面的命令： bash ls /sys/firmware/efi/efivars # 有输出即可 运行后如果有很多变量输出，说明处于 UEFI 模式。如果出现错误，说明处于 BIOS（或 CSM）模式。这虽然不会都后面的步骤产生影响，但了解一下系统的启动方式还是有必要的。 ","date":"2021-12-26","objectID":"/installarch/:2:1","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#确认启动模式"},{"categories":["生命在于折腾"],"content":" 连接网络Arch Linux 的安装必须联网，有线网络应当会自动连接，可以直接使用 ping 来验证网络连接。若使用无线网，需要通过 iwctl 手动操作，具体步骤如下（缩进的代码表示进入交互模式）： bash ip link # 检查网络接口 iwctl # 交互式连接无线网络 device list # 列出无线网卡设备名 station [wlan0] scan # 扫描网络 [] 内部待替换 station [wlan0] get-networks # 列出所有 wifi 网络 station [wlan0] connect [wifi-name] # 进行连接 exit # 退出交互模式 首先，使用 ip link 检查网络接口设置，通常情况下网络接口都是默认开启的。如果无法连接，可以使用命令 ip link set [wlp0s20f3] up 激活对应的网卡，然后重复联网操作。 使用 iwtcl 命令后，命令行会进入到相应的交互模式，这时候依次运行上面缩进部分的代码，扫描并连接网络即可。 最后，我们来 ping 一下哔哩哔哩，看看网络是否连通。 bash ping bilibili.com # 检查网络连接 如果出现“64 bytes from …”之类的提示，则表示网络正常，使用组合键 Ctrl + C 停止连接测试即可。 ","date":"2021-12-26","objectID":"/installarch/:2:2","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#连接网络"},{"categories":["生命在于折腾"],"content":" 同步时间时间同步蛮重要的，具体我也说不清，跟着教程运行下面两个命令就可以了： bash timedatectl set-ntp true # 将系统时间与网络时间进行同步 timedatectl status # 检查服务状态 ","date":"2021-12-26","objectID":"/installarch/:2:3","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#同步时间"},{"categories":["生命在于折腾"],"content":" 更改软件镜像源为了获得更快的下载速度，应当更换软件镜像源。我蛮喜欢 清华大学开源软件镜像站 的，为此，首先运行下面的命令打开配置文件： bash vim /etc/pacman.d/mirrorlist 可以看到很多默认配置，但这些源并不是都要使用的，优先级是从上往下递减，因此我们只需要将下面的配置放在最上面即可（# 是 Linux 配置文件的注释符）： text Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch 技巧 Vim 编辑器中，使用 j,k,h,l 分别对光标进行下、上、左、右的移动；按 i 可以插入文字。为了退出 Vim, 首先按 Esc 切换到普通模式，然后输入 :wq 回车即可保存并退出。 注意 这里我们使用了 Vim 编辑器，这是个非常强大的上古神器。我之前写过 Vim 简介，对它的冰山一角进行了拙劣的说明。虽不足以进阶，应付一下这里的基本编辑还是没问题的。 更换软件镜像源后别忘了使用以下命令刷新一下： bash pacman -Syy ","date":"2021-12-26","objectID":"/installarch/:2:4","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#更改软件镜像源"},{"categories":["生命在于折腾"],"content":" 分区安装系统之前对硬盘进行分区，可以将不同的数据存放在不同的位置。例如，我在使用 Linux 时通常会将 /home 单独分区，这样在重装系统时很多配置和软件都可以保留并继续使用。Linux 分区与 Windows 有很大的不同，这里我不想多说，有兴趣的同学可以参看 鸟叔的 Linux 私房菜。 首先我们使用下面的命令查看当前的硬盘 bash fdisk -l 你会看到所有的硬盘都以 /dev/xxx 的形式，看上去就像一个个文件。我们忽略 /dev/loop 开头的东西，如果硬盘使用 SATA 协议，我们将看到形如 sda、sdb 等信息；如果硬盘是 NVME 协议，则会看到形如 nvme0n1、nvme1n1 等。如果硬盘已经分区，还会进一步列出各个分区信息。 我们以 SATA 协议的硬盘为例，并设这个硬盘的编号为 sda，那么我们可以运行下面的命令（再次提醒中括号内的内容，包括中括号本身，表示可变的参数，不同机器的参数可能不同）： bash fdisk /dev/sd[a] # SATA协议：sd[a]，NVME 协议：nvme[1]n1 运行这个命令后将进入交互模式，根据提示，按 m 可以查看用法，按 n 可以新建分区等等。 在本例中，我在虚拟机中使用了空白的虚拟硬盘，因此我的操作如下，仅供参考： bash # fdisk 交互命令 g # 新建 GPT 分区表（忽略已有分区，重新分区） n # 回车选择默认起始点，然后输入 +512M 创建 EFI 分区 n # 回车选择默认起始点，然后输入 +20G 创建根目录分区 n # 回车选择默认起始点，然后输入 +20G 创建 /home 分区 n # 回车选择默认起始点，然后输入 +1G 创建 swap 分区（一般为内存的一半左右即可） w # 保存并退出 执行完上述命令后，再次使用 fdisk -l 可以看到 sda 下面多出了 sda1、sda2 等分区。至此我们实际上只是对各个目标分区的大小进行了设置，真正使用还需要对各分区格式化，具体命令如下（sda后面的编号与分区创建的顺序相关，本例编号如中括号内容所示）： bash mkfs.fat -F32 /dev/sda[1] # 格式化 EFI 分区 mkfs.ext4 /dev/sda[2] # 根目录 mkfs.ext4 /dev/sda[3] # 其他目录，如 /home mkswap /dev/sda[4] # 创建 swap 分区 fdisk -l # 查看分区结果 ","date":"2021-12-26","objectID":"/installarch/:2:5","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#分区"},{"categories":["生命在于折腾"],"content":" 挂载为了将系统安装进上面分区好的硬盘，需要将硬盘挂载到当前系统。初次接触 Linux 的同学可能对挂载这个操作有所疑惑，这里打个比方：比如你插了 U 盘，系统虽然知道你插了 U 盘，但是它不显示，你必须手动挂载，告诉系统把 U 盘的内容“映射”到某个文件夹下，这样在指定文件夹内就可以访问 U 盘内容了。如果用大家熟悉的 Windows 对比，当你插入 U 盘后，Windows 会自动将 U 盘“挂载”到一个新的分区，例如“F：可移动硬盘”；当你右键弹出 U 盘，但是还没有拔出时，“F：可移动硬盘”消失不见了，这就好像是 Linux 插入 U 盘但是没有挂载事的状态。 按照前人的经验，挂载时一定要先挂载根目录，常用的挂载点是 /mnt 。我们在上面分区时根目录是第二个分区（sda2），因此挂载顺序如下： bash mount /dev/sda[2] /mnt # 一定要先挂载根目录 mkdir /mnt/boot # 新建 /boot 文件夹 mount /dev/sda[1] /mnt/boot # 挂载 EFI 分区 mkdir /mnt/home # 新建 /home 文件夹 mount /dev/sda[3] /mnt/home # 挂载 /home 分区 swapon /dev/sda[4] # 启用 swap 分区 至此，我们已经做好全部的安装准备了，开始正式安装 Arch Linux！ ","date":"2021-12-26","objectID":"/installarch/:2:6","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#挂载"},{"categories":["生命在于折腾"],"content":" 安装系统前面准备那么久，激动了大半天，但说来还是有点小失望。因为安装 Arch Linux 只需要下面两条命令就可以了： bash pacstrap /mnt base linux linux-firmware # 安装系统 genfstab -U /mnt \u003e\u003e /mnt/etc/fstab # 生成 fstab 文件 但是别急，这只是安装了最基本的内容，要想成功启动，还需要进行基本配置工作。为此，我们使用下面的命令切换到新系统去 bash arch-chroot /mnt # 切换到新系统 ","date":"2021-12-26","objectID":"/installarch/:2:7","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#安装系统"},{"categories":["生命在于折腾"],"content":" 主机配置装好系统之后，得给系统起个好听的名字吧？使用下面的命令（替换掉中括号以及中括号里面的内容喔）： bash echo '[hostname]' \u003e /etc/hostname # 设置主机名 然后我们需要编辑 hosts 文件，我们发现新系统没有内置 Vim，因此还需要使用下面的命令安装 Vim bash pacman -S vim # 安装 vim 问题 pacman 是 Arch 的软件管理（package mannager），唔，也是吃豆人啦。 然后使用 Vim 打开 hosts 文件 bash vim /etc/hosts 在里面填入以下内容，注意替换掉自己的主机名喔 text 127.0.0.1 localhost ::1 localhost 127.0.1.1 [hostname].localdomain [hostname] ","date":"2021-12-26","objectID":"/installarch/:2:8","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#主机配置"},{"categories":["生命在于折腾"],"content":" 时间设置Arch 内置了很多时区，我们只需要使用下面的命令创建相应的链接即可。注意国内的时区是上海而不是北京（我也不知道为什么）。 bash ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 设置时区 hwclock --systohc # 同步时间 ","date":"2021-12-26","objectID":"/installarch/:2:9","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#时间设置"},{"categories":["生命在于折腾"],"content":" 区域设置区域设置实际上是为了配置应用程序的默认格式，我们首先使用 Vim 打开配置文件： bash vim /etc/locale.gen 找到 en_US.UTF-8 UTF-8 和 zh_CN.UTF-8 UTF-8 ，去掉前面的注释即可。 技巧 简要说明一下这里的 Vim 使用：首先输入 /en_US 后回车，并按 n 查找下一处；光标到达目标位置后按 0 跳转到行首，按 x 删除注释（有空格的话再按一次 x 把空格也删掉，否则会逼死强迫症）。然后再输入 /zh_CN 回车，重复上述操作。最后输入 :wq 保存并退出即可。 最后使用下面的命令生成相应配置即可。第二行表示使用英文，听说设置中文容易导致乱码。使用英文的另一个好处就是：如果程序出错，英文的错误提示更容易在网上搜到相关的解答方案。 bash locale-gen echo 'LANG=en_US.UTF-8' \u003e /etc/locale.conf ","date":"2021-12-26","objectID":"/installarch/:2:10","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#区域设置"},{"categories":["生命在于折腾"],"content":" root 密码超级管理员，得悄悄设置个别人不知道的密码： bash passwd 注意 Linux 终端在输入密码时屏幕上不会出现任何字符，不要觉得是键盘坏了…… ","date":"2021-12-26","objectID":"/installarch/:2:11","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#root-密码"},{"categories":["生命在于折腾"],"content":" GRUB 设置一般的电脑都是 x86_64 架构，只需要根据 CPU 的不同安装不同的 ucode 即可。按照下面的命令一般不会出错： bash pacman -S intel-ucode # AMD CPU 使用 amd-ucode pacman -S grub efibootmgr os-prober uname -m # 查看 CPU 架构 grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH vim /etc/default/grub # 适当调整，可以跳过 grub-mkconfig -o /boot/grub/grub.cfg ","date":"2021-12-26","objectID":"/installarch/:2:12","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#grub-设置"},{"categories":["生命在于折腾"],"content":" 重启并进入新系统至此，系统已经基本配置完成，在正式重启进入系统之前，千万别忘了安装网络管理软件。 bash pacman -S dhcpcd iwd exit umount -R /mnt reboot 关机后拔掉 U 盘，或者在启动选项上稍微留心一下，确认进入了新安装的系统。 ","date":"2021-12-26","objectID":"/installarch/:2:13","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#重启并进入新系统"},{"categories":["生命在于折腾"],"content":" 进入新系统现在我们进入新系统啦，还是一片黑白的命令行……不管如何，先连上网再说。有线网络使用下面的命令一般就可以顺利上网了： bash systemctl enable --now dhcpcd 无线网络还是通过 iwctl 连接，不过在使用前还需要启动 iwd 服务（新系统默认关闭） bash systemctl start iwd # 启动无线网络服务 iwctl # 交互式连接无线网络 device list # 列出无线网卡设备名 station [wlan0] scan # 扫描网络 [] 内部待替换 station [wlan0] get-networks # 列出所有 wifi 网络 station [wlan0] connect [wifi-name] # 进行连接 exit # 退出交互模式 最后确认一下网络链接，顺便更新一下系统： bash ping bilibili.com # 使用 Ctrl+C 停止测试 pacman -Syyu # 更新系统 ","date":"2021-12-26","objectID":"/installarch/:2:14","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#进入新系统"},{"categories":["生命在于折腾"],"content":" 创建普通用户如果稍微留心一下，你会发现命令行的提示符是 #，这代表目前你使用的是超级管理员账户（root）。这个账户的权限非常高，为了避免误操作导致系统问题，我们通常使用权限稍微低一点的普通用户；为了偶尔提升一下普通用户的权限，需要对普通用户进行设置，按照下面的操作即可： bash pacman -S sudo useradd -m -G wheel [username] passwd [username] EDITOR=vim visudo 最后一行将会打开 Vim 编辑器，我们使用 /wheel 定位到 #%wheel ALL=(ALL) ALL，删除前面的注释符 # 即可。 危险 超级管理员用户具有非常高的权限，不信你可以在 root 账户下运行 rm -rf /。前提是运行完了别打我（狗头保命）。 ","date":"2021-12-26","objectID":"/installarch/:2:15","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#创建普通用户"},{"categories":["生命在于折腾"],"content":" 安装 KDE 桌面环境终于到了最激动人心的时刻了，我们已经基本配置好了系统，现在为了日常使用，将安装图形界面。我个人比较喜欢 KDE 桌面，使用以下命令即可： bash pacman -S plasma-meta konsole dolphin git base-devel systemctl enable sddm reboot 从这里开始，大家就可以完全跟随自己的爱好对系统进行配置，完全可以使用 GNOME、DDE 等各种桌面环境。这里介绍我自己的安装经历，仅作为参考。 ","date":"2021-12-26","objectID":"/installarch/:2:16","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#安装-kde-桌面环境"},{"categories":["生命在于折腾"],"content":" 进入桌面环境后的配置重启后可以看到界面，使用上面创建的普通用户登陆即可。 进入桌面环境后，首当其冲的还是联网设置。安装 KDE 后默认你会安装 NetworkManager，这个服务与之前的 iwd 似乎存在冲突，因此我们要确保 iwd 关闭和 NetworkManager 启动，运行下面的命令（哦对，要使用 Ctrl + Alt + T 打开终端）： bash sudo systemctl disable iwd # 关闭 iwd 开机自启 sudo systemctl stop iwd # 立即关闭 iwd 服务 sudo systemctl enable --now NetworkManager # 启动 NetworkManager 并确保开机自启 然后就可以从桌面左下角的 WiFi 图标进行网络连接了，接着测试网络连接： bash ping bilibili.com 为了避免后面安装微信等软件是依赖的问题，我们要对镜像源配置文件进行修改。由于这次使用了普通用户，修改镜像源这种系统配置时需要使用 sudo 临时提高权限： bash sudo vim /etc/pacman.conf 找到 [multilib] 删除相关注释，形如： text [multilib] Include = /etc/pacman.d/mirrorlist 然后再随手更新一下系统： bash sudo pacman -Syu ","date":"2021-12-26","objectID":"/installarch/:2:17","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#进入桌面环境后的配置"},{"categories":["生命在于折腾"],"content":" 安装 AUR 管理软件 yay使用 Arch 的重要因素之一就是它的用户仓库（AUR, Arch User Repository）提供了非常多优秀的软件（例如可以一条命令安装微信）。为了使用 AUR，我们要手动安装其包管理器 yay。 bash git clone https://aur.archlinux.org/yay --depth 1 cd yay export GO111MODULE=on # 临时 GO 换源 export GOPROXY=https://goproxy.cn makepkg -si 安装 yay 需要从 GO 和 GitHub 下载相关依赖。受限于网络环境，两个网站可能无法访问。GO 的仓库可以通过上面的换源方法完成，GitHub 可能要修改 hosts，具体可以参考 yay安装失败的解决方案。 然后就可以用 yay 自由地玩耍了。 ","date":"2021-12-26","objectID":"/installarch/:2:18","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#安装-aur-管理软件-yay"},{"categories":["生命在于折腾"],"content":" 中文配置最后简要分享一下中文的配置： bash sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra sudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-pinyin-zhwiki vim ~/.pam_environment 前面三条命令分别是安装相应的中文字体、安装输入框架，最后需要对 fcitx5 进行配置，在打开的文件中写入以下内容即可： text INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=\\@im=fcitx5 Arch Linux 的可玩性不限于此，剩下的请大家自行折腾～ ","date":"2021-12-26","objectID":"/installarch/:2:19","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#中文配置"},{"categories":["生命在于折腾"],"content":" 参考文献 【残酷难度】最全Arch Linux安装教程——打造真正属于你的操作系统. VirtualBox 安装 Arch Linux: 从新建虚拟机到图形界面. archlinux 基础安装 Installation guide yay安装失败的解决方案 ","date":"2021-12-26","objectID":"/installarch/:3:0","series":null,"tags":["Arch","Linux","操作系统"],"title":"Arch Linux 系统安装","uri":"/installarch/#参考文献"},{"categories":["生命在于折腾"],"content":"最近女朋友的电脑被她玩挂了，我决定写一篇文章教她如何重装系统。 ","date":"2021-12-17","objectID":"/installwindows/:0:0","series":null,"tags":["Windows","操作系统"],"title":"Windows 系统安装","uri":"/installwindows/#"},{"categories":["生命在于折腾"],"content":" 安装前的准备重装系统之前，最重要的事情就是备份了：遍历一下自己经常使用的文件夹，把重要的文件拷贝到 U 盘或者移动硬盘里备份，以免重装系统时丢失或损坏。 危险 一定要备份！一定要备份！一定要备份！ 备份好数据后，就可以正式准备安装系统了。首先需要下载系统镜像，可以从 I Tell You 下载。然后有两种方法安装系统： 将下载好的镜像文件（.iso 文件）通过烧写软件（例如 Rufus）写入 U 盘，重启电脑，将 U 盘作为光盘安装系统； 将 U 盘制作成 PE 系统，重启后进入 U 盘的 PE 系统进行安装。 一般来说，我比较建议使用第二种方法。一方面，优秀的 PE 自带很多工具可以辅助系统安装；另一方面，PE 盘还可以用于 Windows 系统救急，比如利用其内置的工具可以很容易修改 Windows 密码（可见 Windows 系统密码并不安全）。 在我试过的各种 PE 制作软件中，微 PE 工具箱 是我最爱的一款，至少具有工具齐全、无广告、无捆绑软件等优点。鉴于我经常白嫖它的便利，不妨在此为其做个广告。 为了制作 PE 盘，需要准备 U 盘。应当注意，制作 PE 盘会格式化 U 盘，因此重要文件不要放在 U 盘里（千万别把前面备份的 U 盘拿来做启动盘）。插入 U 盘，使用管理员权限运行微 PE 工具箱，选择安装进 U 盘后，按照提示选择 U 盘、文件系统（推荐 NTFS）等即可完成安装。PE 盘制作完成后，记得将下载好的系统镜像拷贝到该 U 盘内。 ","date":"2021-12-17","objectID":"/installwindows/:1:0","series":null,"tags":["Windows","操作系统"],"title":"Windows 系统安装","uri":"/installwindows/#安装前的准备"},{"categories":["生命在于折腾"],"content":" 通过 PE 安装系统制作好 PE 盘后，重启系统。一般在电脑出现 LOGO 后立马按 F12 键选择启动盘，但不同电脑的快捷键可能有所不同。操作正常的话，电脑应当会出现硬盘/U 盘列表，选择刚才制作的 U 盘，按回车进入 PE 系统。 PE 系统主界面 微 PE 工具箱内置了很多工具，这里我们打开 Windows 安装器。在不做任何操作时，右侧 EFI 旁边的灯通常不是绿色，说明分区存在问题。这是先暂时退出 Windows 安装器，打开分区助手重新进行分区（因为涉及到重新分区，所以原硬盘的数据可能会格式化，这也是一再强调备份的主要原因）。 Windows 安装器界面 从分区助手的硬盘列表可以看到当前的所有硬盘和 U 盘信息，熟悉分区的老手可以自行分区，不熟悉的同学可以直接右键硬盘，选择快速分区，如下图所示。 快速分区示例 我们来看看分区设置。首先确认下硬盘是我们所选的硬盘，即需要安装系统的硬盘。分区的数量根据个人喜好进行选择。一般我比较推荐单独使用一个分区安装系统和软件，使用额外的分区单独存放数据，例如新建一个数据分区存放个人重要文件，新建一个文件分区存放一般性文件等。这里我使用两个分区进行示意，右侧适当调整分区大小，并起个好听的名字就可以了。 硬盘的类型可以无脑选择 GPT, 这是一种新的分区表，有兴趣的同学可以自行查阅相关内容。其他选项可以参考我的设置，勾选“重建 MBR”和“创建 ESP 和 MSR 分区”，这是前面 EFI 黄灯的主要原因。对于固态硬盘，应当将分区对齐到 4096 扇区。 OK，准备就绪，执行分区操作即可。 分区完成后推出分区助手，重新打开 Windows 安装器，依次执行： 选择 Windows 安装文件的位置：点击搜索，选择之前下载的系统镜像文件即可； 选择引导驱动器的位置：点击搜索，选择待装系统硬盘上的 FAT32 分区，这个分区是上面分区时自动创建的，通常没有 C、D、E 这种盘符。这时候右侧 EFI 应当变为绿灯； 选择安装驱动器的位置：点击搜索，选择待装系统硬盘上的系统分区，这是分区时手动创建的，盘符一般为 C,但不重要（Windows 安装好了后会重置为 C）； 选项：选择 Windows 版本。一个系统镜像通常具有多个版本，应当注意选择合适的版本。 Windows 安装设置 点击安装，等待、重启，就完事了。 在我写这篇博客时，发现了微 PE 官方提供的 微 PE 安装系统教程，如果此文无法解决你的问题，不妨参考一下这个教程。 ","date":"2021-12-17","objectID":"/installwindows/:2:0","series":null,"tags":["Windows","操作系统"],"title":"Windows 系统安装","uri":"/installwindows/#通过-pe-安装系统"},{"categories":["生命在于折腾"],"content":" 推荐一些实用软件系统安装完成后，最麻烦的就是安装软件了。不过 Windows 下还是有很多有趣的软件，这里简要列举其中一二，有兴趣的同学可以自行折腾。 Dism++：对 Windows 进行深度配置； Everything：快速查找电脑里的文件； Snipaste：截图与贴图工具； 坚果云：超好用的同步网盘； PotPlayer：最好的视频播放软件（官网经常无法打开）； Motrix：美丽的下载软件； Capslock+：更改大写锁定键功能； PowerToys：Windows 强化工具； Cmder：Windows 终端美化。 ","date":"2021-12-17","objectID":"/installwindows/:3:0","series":null,"tags":["Windows","操作系统"],"title":"Windows 系统安装","uri":"/installwindows/#推荐一些实用软件"},{"categories":["数字信号处理"],"content":"广义的傅立叶变换是指时域信号在频域内的分解，具体包括周期信号的傅立叶级数、非周期信号的傅立叶变换、离散信号的离散时间傅立叶变换和离散傅立叶变换。本文介绍这几种变换，旨在梳理其中的关系并简要讨论信号离散化带来的的问题。 ","date":"2021-12-02","objectID":"/introspectrum/:0:0","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#"},{"categories":["数字信号处理"],"content":" 连续信号频域分析","date":"2021-12-02","objectID":"/introspectrum/:1:0","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#连续信号频域分析"},{"categories":["数字信号处理"],"content":" 傅立叶级数首先我们从一个问题开始：假设现在有一个周期信号，不妨假设为下图蓝色曲线所示的方波。凭借朴素的直觉，这个周期信号应当能够分解为另一系列周期信号的叠加。如果选择正弦信号为基准，如何将给定的方波信号分解为正弦信号的叠加？ 周期信号的正弦分解示意图 提到分解，不免会想到矢量的分解。对于一个给定的矢量，如果想将它分解为不同矢量的叠加，通常需要选择一组正交的单位基矢（坐标系），然后通过内积计算向量在不同基矢上的投影（坐标），最后就可以通过投影和基矢来表达原来的矢量。 矢量的分解 于是，我们可以类比地选择 $\\cos n \\omega_0 t$ 和 $\\sin n \\omega_0 t$ 为函数空间的基；矢量内积的相乘、相加运算类比过来就是相乘、积分，而由于是周期信号，因此积分区间只取一个周期即可；最后只要按照内积的定义计算相应的“坐标”即可知道各个正弦信号对应的幅值。这就是函数的 正交投影。 注意 可以通过内积进行验证：倍频正弦（包括余弦）是在周期内是正交的，即任意两个相乘在周期内积分为零。实际上这样的正交基并不局限于正弦，由于傅立叶变换是基于正弦信号展开，故此处仅讨论正弦的情况。 根据这个思路，实际上我们已经自己推导出了傅立叶变换，用公式表示为 综合公式 $$ x(t) = \\frac{a_0}{2} + \\sum_{k=1}^{+\\infty} \\left(a_k \\cos k\\omega_0t + b_k \\sin k\\omega_0t\\right) $$ 分析公式 $$ \\left\\{\\begin{aligned} a_k \u0026= \\frac{2}{T} \\int_T x(t) \\cos k\\omega_0t \\,\\mathrm{d}t \\\\ b_k \u0026= \\frac{2}{T} \\int_T x(t) \\sin k\\omega_0t \\,\\mathrm{d}t \\\\ \\end{aligned}\\right. $$ 其中综合公式类比于矢量用基矢的表示，而分析公式则给出基矢的投影（坐标）。$T$ 为信号的周期，$\\omega_0=\\frac{1}{T}$ 是正弦的基频。虽然这些正弦函数相互正交，但是它们不是归一化的，因此分析公式中存在系数 $\\frac{2}{T}$ 进行归一化。在这种表达中，频率索引 $k$ 非负，意味着频域是“单边”的，如果我们允许负频率的存在，并将相应的 $b_k$ 反号以与上式保持一致，就能得到更加统一的表达式： $$ x(t) = \\sum_{k=-\\infty}^{+\\infty} \\left(a_k \\cos k\\omega_0t + b_k \\sin k\\omega_0t\\right) \\quad \\left\\{\\begin{aligned} a_k \u0026= \\frac{1}{T} \\int_T x(t) \\cos k\\omega_0t \\,\\mathrm{d}t \\\\ b_k \u0026= \\frac{1}{T} \\int_T x(t) \\sin k\\omega_0t \\,\\mathrm{d}t \\\\ \\end{aligned}\\right. $$ 但是这样还不足够简洁。进一步考虑欧拉公式将 $\\mathrm{e}$ 的复指数分解成了正弦和余弦，如果采用这种表达，可以得到最漂亮的傅立叶级数（Fourier Series）表达式（注意 $\\mathrm{e}$ 指数的符号）： $$ x(t) = \\sum_{k=-\\infty}^{+\\infty} A_k \\mathrm{e}^{\\mathrm{j}k\\omega_0t} \\qquad A_k = \\frac{1}{T} \\int_T x(t) \\mathrm{e}^{-\\mathrm{j}k\\omega_0t}\\,\\mathrm{d}t $$ 方波的傅立叶级数分解如下图所示。 方波的傅里叶级数示意图 傅立叶级数存在收敛条件，实际上是约束信号真实存在，这里我不做过多解释，直接给出（后边的傅立叶变换也有相似的条件）： 在一个周期内信号绝对可积 不存在第二类间断点（无穷间断点、震荡间断点） 在开始下一部分之前，小结一下傅立叶级数的特点： 适用于连续、周期信号 频率间隔 $\\Delta f = \\frac{1}{T}$ $A_k$ 共轭对称 时域周期对应频域离散 ","date":"2021-12-02","objectID":"/introspectrum/:1:1","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#傅立叶级数"},{"categories":["数字信号处理"],"content":" 傅立叶变换为了将傅立叶级数应用到非周期信号，只需要重新理解一下什么是非周期信号即可：非周期嘛，不就是周期无限大吗？将傅立叶变换的综合公式取极限，有 $$ \\begin{aligned} x(t) \u0026= \\sum_{k=-\\infty}^{+\\infty} A_k \\mathrm{e}^{\\mathrm{j}k\\omega_0t} \\\\ \u0026= \\lim_{T \\to \\infty} \\sum_{k=-\\infty}^{+\\infty} \\frac{1}{T}\\mathrm{e}^{\\mathrm{j}k\\omega_0t} \\underbrace{\\int_{-\\infty}^{+\\infty} x(t) \\mathrm{e}^{-\\mathrm{j}k\\omega_0t}\\,\\mathrm{d} t }_{X(\\mathrm{j}\\omega)} \\\\ \u0026= \\lim_{\\omega_0 \\to 0} \\sum_{k = -\\infty}^{+\\infty} X(\\mathrm{j}\\omega) \\mathrm{e}^{\\mathrm{j}k\\omega_0t} \\omega_0 \\\\ \u0026= \\int_{-\\infty}^{+\\infty} X(\\mathrm{j}\\omega) \\mathrm{e}^{\\mathrm{j}\\omega t}\\, \\mathrm{d}\\omega \\end{aligned} $$ 当周期 $T$ 趋于无穷大，基频 $\\omega_0$ 就趋近于 $0$，离散频率 $k\\omega_0$ 就变成了连续的频率 $\\omega$。整理上式就可以得到非周期信号的傅立叶变换（Fourier Transform）： $$ x(t) = \\frac{1}{2\\pi} \\int_{-\\infty}^{+\\infty} X(\\mathrm{j}\\omega) \\mathrm{e}^{\\mathrm{j}\\omega t}\\,\\mathrm{d}\\omega \\qquad X(\\mathrm{j}\\omega) = \\int_{-\\infty}^{+\\infty} x(t) \\mathrm{e}^{-\\mathrm{j}\\omega t}\\,\\mathrm{d}t $$ 下图给出了傅立叶变换的示意，其具有以下基本性质： $X(\\mathrm{j}\\omega)$ 共轭对称 时域非周期对应于频域连续 非周期信号的傅里叶变换示意图 至此，我们得到了两个非常重要的定性的结论：周期对应离散，非周期对应连续。实际上这个结论是“对称”的。例如在后面我们会讨论到，如果时域是离散的，那么频域就是周期的。 ","date":"2021-12-02","objectID":"/introspectrum/:1:2","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#傅立叶变换"},{"categories":["数字信号处理"],"content":" 两者的统一现在我们有了傅立叶级数用于处理连续的周期信号，还有傅立叶变换处理连续的非周期信号。然而，无论是数学“抽象归纳”的思想，或者逻辑上傅立叶变换是傅立叶级数的延拓，我们都希望这两者能够在表达上统一。为此，引入狄拉克函数，用 $\\delta (t)$ 表示。它是一个广义函数，形式上可以定义为单位阶跃函数 $u(t)$ 的导数： $$ u(t) = \\left\\{\\begin{array}{cl} 0 \u0026 t \u003c 0 \\\\ 1 \u0026 t \u003e 0 \\end{array}\\right. \\quad \\rightarrow \\quad \\delta (t) := \\frac{\\mathrm{d}}{\\mathrm{d}t} u(t) = \\left\\{\\begin{array}{cl} \\infty \u0026 t = 0 \\\\ 0 \u0026 t \\ne 0 \\end{array}\\right. $$ 狄拉克函数有以下两个重要性质，将在后面的讨论中使用： 采样性质：$\\int f(t) \\delta (t-t_0) \\mathrm{d} t = \\int f(t_0) \\delta (t-t_0) \\mathrm{d} t = f(t_0)$ 卷积性质：$f(t) \\ast \\delta (t-t_0) = \\int f(\\tau) \\delta (t-t_0-\\tau) \\mathrm{d} \\tau = f(t-t_0)$ 根据上面的采样性质，傅立叶级数可以以傅立叶变换的形式统一表示为 $$ \\begin{gathered} X(\\mathrm{j}\\omega) = \\sum_{k=-\\infty}^{+\\infty} 2 \\pi A_k \\delta (\\omega - k\\omega_0)\\\\ \\frac{1}{2\\pi} \\int_{-\\infty}^{+\\infty} X(\\mathrm{j}\\omega) \\mathrm{e}^{\\mathrm{j}\\omega t}\\,\\mathrm{d}\\omega \\Leftrightarrow \\sum_{k=-\\infty}^{+\\infty} A_k \\mathrm{e}^{\\mathrm{j}k\\omega_0t} \\end{gathered} $$ 注意 需要注意的是，这种表述方法常用于分析频谱。对于实际的周期信号，还是应当使用傅里叶级数计算系数，然后改写成狄拉克函数。直接依据傅立叶变换计算会得到无穷大，无法获知狄拉克函数的系数。 正弦函数利用傅立叶变换得到的无穷大可以作为狄拉克函数的另一种定义方法。 ","date":"2021-12-02","objectID":"/introspectrum/:1:3","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#两者的统一"},{"categories":["数字信号处理"],"content":" 离散信号频域分析","date":"2021-12-02","objectID":"/introspectrum/:2:0","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#离散信号频域分析"},{"categories":["数字信号处理"],"content":" 时域采样与频率混叠为了将连续信号离散化，可以采用冲击串进行采样，冲击串用狄拉克函数表达为 $$ p(t) = \\sum_{n=-\\infty}^{+\\infty} \\delta (t - n T_s) $$ 时域信号的采样 代入傅立叶变换的表达式，进一步可以整理出离散时间傅立叶变换（Discrete-Time Fourier Transform）： $$ x(n) = \\frac{1}{2\\pi} \\int_{2\\pi} X(\\mathrm{e}^{\\mathrm{j}\\omega}) \\mathrm{e}^{\\mathrm{j}\\omega n}\\,\\mathrm{d}\\omega \\qquad X(\\mathrm{e}^{\\mathrm{j}\\omega}) = \\sum_{n=-\\infty}^{+\\infty} x(n) \\mathrm{e}^{-\\mathrm{j}\\omega n} $$ 应当注意，上式中的 $\\omega$ 是数字频率，它被采样率 $f_s$ 归一化，是数字信号处理的常用方式。对于实际频率为 $f$ 的信号，其对应的数字频率为 $\\omega = 2 \\pi \\frac{f}{f_s}$ 。 采样会引入一个非常重要的效应：频谱混叠。在对此进行解释之前，两个小结论需要读者自行证明： 时域乘积对应频域卷积 时域冲击串的频谱也是冲击串，且频域冲击间隔为采样率。 根据这两个结论，我们可以从下图直观地感受到频谱混叠的含义：首先，第一个图中的三角形假设为原连续信号的频谱，冲击串为采样函数的频谱；当进行采样，时域相乘，频域卷积。根据前面提到狄拉克函数的卷积性质，实际上是将原来的频谱按照采样率为间隔进行复制粘贴，如第二个图所示；如果原信号的带宽过大，复制粘贴之后的频谱重叠，合成之后的频谱就会发生改变，如第三个图所示，这就是所谓的频谱混叠。 频率混叠示意图 可见，要想避免混叠，信号的带宽不应当超过采样率的一半。对于实际数据，如果混叠来自高频噪声，可以使用滤波器进行滤除，相应的滤波器称为抗混叠滤波器；如果是由于信号的频率较大，那么应当适当提高采样率。 ","date":"2021-12-02","objectID":"/introspectrum/:2:1","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#时域采样与频率混叠"},{"categories":["数字信号处理"],"content":" 有限窗长与频率泄露除了频谱混叠，由于实际采样的时间有限，还会有频率泄露的效应。为了说明这个问题，定义一个窗函数，其在采样持续时间内为正值，否则为零。最常见的窗函数就是矩形窗，如下图所示 实际信号的有限窗长示意图 同样，时域上信号与窗函数相乘，频域表现为原信号的频谱与窗函数频谱做卷积，这会在一定程度上影响原信号的频谱，使采样后的结果存在误差。这也是通常我们说谱估计而不是谱计算的原因。 一般情况下，窗函数具有如下图所示的频谱特征：其具有一个主瓣和多个旁瓣。为了好理解，假设原始信号就是正弦，那么与窗函数相乘之后的频谱的形状与窗函数的频谱相同（但中心频率点不同）。显然，窗函数的主瓣宽度会影响单频信号的频率分辨率，而旁瓣则容易产生出“误解”，错误地认为存在对应频率点的信号。 频率泄露示意图 由于采样总是有限时常，窗函数引入的频率泄露无法避免。为了尽可能减小这个效应，可以使用非矩形窗如汗宁窗、海明窗等，它们通常表现为窗的两端小，中间大。具体可以在 MATLAB 中使用 hann 等函数查看。 ","date":"2021-12-02","objectID":"/introspectrum/:2:2","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#有限窗长与频率泄露"},{"categories":["数字信号处理"],"content":" 频域采样与栅栏效应至此我们已经分析了时域离散的情况，距离使用计算机计算之差最后一步：频域离散化。前面讨论了离散化是冲击串相乘，时域离散对应着频域周期延拓。反过来，频域离散对应这时域周期延拓，如下图所示，为了避免利用采样后的频谱恢复时域数据时发生混叠，频率间隔应当不大于采样时长的倒数。 频域采样与栅栏效应示意图 取 $\\Delta f = \\frac{1}{T}$ 时，恰好不发生混叠，频域样本点数与时域数据点数相同。此时有离散傅立叶变换（Discrete Fourier Transform） $$ x(n) = \\frac{1}{N} \\sum_{k=0}^{N-1} X(k) \\mathrm{e}^{\\mathrm{j} 2\\pi\\frac{k}{N} n} \\qquad X(k) = \\sum_{n=0}^{N-1} x(n) \\mathrm{e}^{-\\mathrm{j} 2\\pi\\frac{k}{N} n} $$ 此时，频域离散，得到的频谱都是离散的点，似乎是通过栅栏在进行观察，因此叫做栅栏效应。 ","date":"2021-12-02","objectID":"/introspectrum/:2:3","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#频域采样与栅栏效应"},{"categories":["数字信号处理"],"content":" 频率分辨率与计算分辨率最后，对两个概念进行梳理 离散时间傅立叶变换中能够分辨的最小频率间隔 $f_{\\rm res} = \\frac{1}{T}$ 离散傅立叶变换的频率间隔（栅栏效应）$\\Delta f = \\frac{f_s}{N}$ 两个概念可以用下面的图粗糙地进行示意。 频率分辨率示意图 在大多数情况下，两个概念并不需要进行区分，这是有 $\\Delta f = \\frac{f_s}{N} = \\frac{1}{N T_s} = \\frac{1}{T} = f_{\\rm res}$ 。快速傅立叶变化的算法得到的频率点数与时域样本点数相同，可以在时域数据后补若干 $0$ 增加计算点数，从而改善计算分辨率。但是这种补 $0$ 的操作并不影响离散时间傅立叶变换，因此不会改变实际的频率分辨率。 此外，通常的频域采样是为了确保采样后的数据能够根据逆变换公式反演出时域数据，如果只关注频域特性，对频域采样不会具有太高的要求。例如 LPSD 功率谱估计 就采用了非均匀的频域采样。 ","date":"2021-12-02","objectID":"/introspectrum/:2:4","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#频率分辨率与计算分辨率"},{"categories":["数字信号处理"],"content":" 参考文献 Alan V. Oppenheim 等, 刘树棠译. 信号与系统. 第二版. 电子工业出版社. 2014. 程佩清. 数字信号处理. 第四版. 清华大学出版社. 2013. ","date":"2021-12-02","objectID":"/introspectrum/:3:0","series":null,"tags":["傅立叶变换","频域分析"],"title":"傅立叶变换与频域分析简介","uri":"/introspectrum/#参考文献"},{"categories":["控制理论基础"],"content":"最近在 DR_CAN 的视频中学到了模型预测控制，于是打算写篇博客记记笔记，权当公式推导的练习。 ","date":"2021-11-26","objectID":"/modelpreditivecontrol/:0:0","series":null,"tags":["模型预测控制","MPC"],"title":"模型预测控制简介","uri":"/modelpreditivecontrol/#"},{"categories":["控制理论基础"],"content":" 基本原理之前在 状态反馈 里简单介绍了 LQR 设计法，这是一种最优设计，旨在使控制命令与误差的\"功率\"加权之和最小。然而，实际系统在扰动的影响下无法按照我们期望的那样运行，也就说外扰打破了理想的最优状态。为了解决这个问题，我们可以使用一个\"滑动的窗口\"，在这个窗口内进行类似 LQR 的最优设计，这便是 MPC 的基本思路。 如下图所示，上面的绿色曲线表示被控对象的输出，蓝色曲线为参考信号；下面的橙色曲线为相应施加的控制信号。在数字控制中，被控对象的输出和控制器的控制命令都被离散化，样本值如散点所示。 控制指令与误差响应示意图 在 $k$ 时刻，模型预测控制根据当前被控对象的输出对后面的 $N$ 步进行预测，在将来的 $N$ 步内，要求控制命令和误差的平方加权和最小。即：寻找 $N$ 步控制命令（$u(i),\\, i=k,\\,k+1,\\,\\dots,\\,k+N-1$ ），使得下面的代价函数达到最小值 $$ J = \\sum_{i=0}^{N-1} \\left( e^\\mathrm{T}(k+i|k) Q e(k+i|k) + u^\\mathrm{T}(k+i|k) R u(k+i|k) \\right) + e^\\mathrm{T}(k+N|k) F e(k+N|k) $$ 式中，使用 $(k+i|k)$ 表示 $k$ 时刻对 $k+i$ 时刻的预测值。 $Q$ 和 $R$ 分别误差和控制的加权矩阵。应当注意的是，预测的状态比控制命令多一个右端边界的点，因此多一个端值误差的加权矩阵 $F$ 。 求解该优化问题即可得到后 $N$ 步的控制命令，但是 MPC 只施加当前时刻的命令 $u(k)$ ，下一时刻的控制命令将重复上述操作重新进行优化估计。所以说 MPC 可以认为是基于\"滑动窗口\"的最优设计。 上述优化问题的解决方案是使用二次规划，因此后面的推导旨在将代价函数写成如下二次规划的标准形式 $$\\min_x \\left( \\frac{1}{2} x^\\mathrm{T}Hx + f^\\mathrm{T}x \\right)$$ ","date":"2021-11-26","objectID":"/modelpreditivecontrol/:1:0","series":null,"tags":["模型预测控制","MPC"],"title":"模型预测控制简介","uri":"/modelpreditivecontrol/#基本原理"},{"categories":["控制理论基础"],"content":" 公式推导本文只介绍 MPC 的基本原理，并做如下假设 假设系统将输出所有状态，即 $y=x$ ； 假设参考信号恒为零（调节器设计），即 $r=0$ ，则有 $e=y-r=x$ 。 于是代价函数可以写作 $$ J = \\sum_{i=0}^{N-1} \\left( x^\\mathrm{T}(k+i|k) Q x(k+i|k) + u^\\mathrm{T}(k+i|k) R u(k+i|k) \\right) + x^\\mathrm{T}(k+N|k) F x(k+N|k) $$ 设系统的离散状态空间方程为 $$x(k+1) = A x(k) + B u(k)$$ 于是在预测的控制命令下，系统状态的预测值为 $$ \\begin{aligned} x(k|k) \u0026= x(k) \\\\ x(k+1|k) \u0026= A x(k|k) + B u(k|k) = A x(k) + B u(k|k) \\\\ x(k+2|k) \u0026= A x(k+1|k) + B u(k+1|k) = A^2 x(k) + AB u(k|k) + B u(k+1|k)\\\\ \u0026\\vdots \\\\ x(k+N|k) \u0026= A^N x(k) + \\sum_{i=0}^{N-1} A^{N-1-i}B u(k+i|k) \\end{aligned} $$ 用矩阵可以将上述 $N+1$ 个方程表示为 $$ \\underbrace{\\begin{bmatrix} x(k|k) \\\\ x(k+1|k) \\\\ \\vdots \\\\ x(k+N|k) \\end{bmatrix}}_{\\bm{X}(k)} = \\underbrace{\\begin{bmatrix} I \\\\ A \\\\ A^2 \\\\ \\vdots \\\\ A^N \\end{bmatrix}}_{M} x(k) + \\underbrace{\\begin{bmatrix} 0 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ B \u0026 0 \u0026 0 \u0026 \\cdots \u0026 0 \\\\ AB \u0026 B \u0026 0 \u0026 \\cdots \u0026 0 \\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 0 \\\\ A^{N-1}B \u0026 A^{N-2}B \u0026 A^{N-3}B \u0026 \\cdots \u0026 B \\end{bmatrix}}_{C} \\underbrace{\\begin{bmatrix} u(k|k) \\\\ u(k+1|k) \\\\ \\vdots \\\\ u(k+N-1|k) \\end{bmatrix}}_{\\bm{U}(k)} $$ 注意 形式上这里有 $N+1$ 个方程 ，但应当注意状态量 $x$ 可以是 $n$ 维的，因此实际上有 $n(N+1)$ 个方程。 即有 $\\bm{X}(k) = Mx(k) + C\\bm{U}(k)$。如此做，代价函数可以表示为 $$ \\begin{aligned} J \u0026= \\begin{bmatrix} x(k|k) \\\\ x(k+1|k) \\\\ \\vdots \\\\ x(k+N|k) \\end{bmatrix}^\\mathrm{T} \\underbrace{\\begin{bmatrix} Q \u0026 0 \u0026 \\cdots \u0026 0 \u0026 0\\\\ 0 \u0026 Q \u0026 \\cdots \u0026 0 \u0026 0\\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 \\cdots \u0026 Q \u0026 0\\\\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 F\\\\ \\end{bmatrix}}_{\\bar{Q}} \\begin{bmatrix} x(k|k) \\\\ x(k+1|k) \\\\ \\vdots \\\\ x(k+N|k) \\end{bmatrix} + \\begin{bmatrix} u(k|k) \\\\ u(k+1|k) \\\\ \\vdots \\\\ u(k+N-1|k) \\end{bmatrix}^\\mathrm{T} \\underbrace{\\begin{bmatrix} R \u0026 0 \u0026 0 \u0026 \\cdots \u0026 0\\\\ 0 \u0026 R \u0026 0 \u0026 \\cdots \u0026 0\\\\ 0 \u0026 0 \u0026 R \u0026 \\cdots \u0026 0\\\\ \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 R \\end{bmatrix}}_{\\bar{R}} \\begin{bmatrix} u(k|k) \\\\ u(k+1|k) \\\\ \\vdots \\\\ u(k+N-1|k) \\end{bmatrix} \\\\ \u0026= \\bm{X}^\\mathrm{T}(k) \\bar{Q} \\bm{X}(k) + \\bm{U}^\\mathrm{T}(k)\\bar{R}\\bm{U}(k) \\\\ \u0026= \\left(Mx(k) + C\\bm{U}(k)\\right)^\\mathrm{T} \\bar{Q} \\left(Mx(k) + C\\bm{U}(k)\\right) + \\bm{U}^\\mathrm{T}(k)\\bar{R}\\bm{U}(k) \\\\ \u0026= x^\\mathrm{T}(k) M^\\mathrm{T} \\bar{Q} M x(k) + x^\\mathrm{T}(k) M^\\mathrm{T} \\bar{Q} C \\bm{U}(k) + \\bm{U}^\\mathrm{T}(k) C^\\mathrm{T} \\bar{Q} M x(k) + \\bm{U}^\\mathrm{T}(k) C^\\mathrm{T} \\bar{Q} C \\bm{U}(k) + \\bm{U}^\\mathrm{T}(k) \\bar{R}\\bm{U}(k) \\\\ \u0026= \\bm{U}^\\mathrm{T}(k) \\underbrace{\\left(C^\\mathrm{T} \\bar{Q} C + \\bar{R}\\right)}_{H} \\bm{U}(k) + 2 \\underbrace{x^\\mathrm{T}(k) M^\\mathrm{T} \\bar{Q} C }_{f^\\mathrm{T}} \\bm{U}(k) + x^\\mathrm{T}(k) M^\\mathrm{T} \\bar{Q} M x(k) \\end{aligned} $$ 优化的对象为 $\\bm{U}(k)$ 。注意代价函数的最后一项 $x^\\mathrm{T}(k) M^\\mathrm{T} \\bar{Q} M x(k)$ 为常数，不影响优化结果，可以不做考虑。与二次规划的标准形式相比，代价函数存在二倍关系，应当注意 $H$ 和 $f^\\mathrm{T}$ 的选择。最后使用 MATLAB quadprog 进行优化计算即可获得 $\\bm{U}(k)$ 。 我在 GitHub 上传了一个简单的 MPC 例子，欢迎留言、讨论。 ","date":"2021-11-26","objectID":"/modelpreditivecontrol/:2:0","series":null,"tags":["模型预测控制","MPC"],"title":"模型预测控制简介","uri":"/modelpreditivecontrol/#公式推导"},{"categories":["控制理论基础"],"content":" 参考文献 DR_CAN, 【MPC模型预测控制器】1_最优化控制和基本概念. DR_CAN, 【MPC模型预测控制器】2_最优化数学建模推导. ","date":"2021-11-26","objectID":"/modelpreditivecontrol/:3:0","series":null,"tags":["模型预测控制","MPC"],"title":"模型预测控制简介","uri":"/modelpreditivecontrol/#参考文献"},{"categories":null,"content":" 嗨，欢迎光临我的博客～ 我平日喜欢进行各种折腾，常常对一些浅尝辄止的知识感到有趣却又不想忘记，为了记录自己的理解并在一定程度上锻炼写作能力，这个博客就诞生了。 由于博客由我个人主宰，写作风格反而逐渐放肆了起来。如果你在阅读中遇到困难或者发现错误，尽可以把锅甩给作者。当然，我也希望能够在 邮件 中收到你的反馈。 如果这个博客的部分内容能够得到你的认可，请在 CC BY-SA 4.0 共享协议下自由分享。 献给我家的小可爱 ","date":"2021-11-24","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于","uri":"/about/#"},{"categories":["控制理论基础"],"content":"卡尔曼滤波是一种最优滤波器，通过对系统的输入和输出进行数据融合来获得状态的最优估计。本文介绍卡尔曼滤波的基本原理并推导其核心公式。 ","date":"2021-08-19","objectID":"/kalmanfilter/:0:0","series":null,"tags":["卡尔曼滤波","滤波器"],"title":"卡尔曼滤波简介","uri":"/kalmanfilter/#"},{"categories":["控制理论基础"],"content":" 基本思想卡尔曼滤波的基本思想如下图所示：首先构建系统的动态模型，根据测得的输入对状态进行先验估计，然后依据测得的输出进行加权平均以获得最优状态估计。这种思想类似于“不等精度测量时以方差的倒数为权求加权平均”。与之不同的是，卡尔曼滤波将“各测量量加权求和”转化为“测量误差对先验估计的校正”，并且将输出折算到状态。 卡尔曼滤波结构示意图 ","date":"2021-08-19","objectID":"/kalmanfilter/:1:0","series":null,"tags":["卡尔曼滤波","滤波器"],"title":"卡尔曼滤波简介","uri":"/kalmanfilter/#基本思想"},{"categories":["控制理论基础"],"content":" 公式推导设线性系统的离散状态空间方程为 $$ \\left\\{ \\begin{aligned} \\bm{x}_k \u0026= A\\bm{x}_{k-1} + B \\bm{u}_k + \\bm{w}_k \\\\ \\bm{y}_k \u0026= C \\bm{x}_k + \\bm{v}_k \\end{aligned} \\right. $$ 其中 $\\bm{w}$ 和 $\\bm{v}$ 分别是状态噪声和测量噪声，假设他们都服从高斯分布，协方差矩阵分别为 $$\\mathrm{E}(\\bm{w}\\bm{w}^T) = Q, \\quad \\mathrm{E}(\\bm{v}\\bm{v}^T) = R$$ 由于噪声是不可知的，只能通过模型对输出估计，状态的先验估计（上标带有负号）为 $$\\hat{\\bm{x}}_k^- = A \\hat{\\bm{x}}_{k-1} + B \\bm{u}_k$$ 应当注意，下一步状态的先验估计由上一步状态的后验估计（上标没有负号）迭代计算，而后验估计则依据模型误差进行数据融合得到，为 $$\\hat{\\bm{x}}_{k} = \\hat{\\bm{x}}_{k}^- + K \\left(y_k-C\\hat{\\bm{x}}_{k}^- \\right)$$ 定义状态估计误差：先验估计误差为 $\\bm{e}_k^- = \\bm{x}_k -\\hat{\\bm{x}}_k^-$ ，后验估计误差为 $\\bm{e}_k = \\bm{x}_k -\\hat{\\bm{x}}_k$ 。卡尔曼滤波（数据融合）的目的是使得后验估计误差最小，即 $$\\mathop{\\mathrm{argmin}}\\limits_{K}\\, \\mathrm{tr}\\left(P_k\\right),\\quad P_k = \\mathrm{E}\\left(\\bm{e}_k\\bm{e}_k^T \\right)$$ 下面来讨论卡尔曼增益的计算。为了迭代，将后验估计误差写成先验估计误差的迭代形式 $$ \\begin{aligned} \\bm{e}_k \u0026= \\bm{x}_k - \\left( \\hat{\\bm{x}}_{k}^- + K \\left( y_k-C\\hat{\\bm{x}}_{k}^- \\right) \\right) \\\\ \u0026= \\bm{x}_k -\\hat{ \\bm{x}}_k^- -KC \\left(\\bm{x}_k -\\hat{ \\bm{x}}_k^- \\right) -KC\\bm{v}_k \\\\ \u0026= \\left(I-KC \\right)\\bm{e}_k^- - K\\bm{v}_k \\end{aligned} $$ 则后验估计的协方差矩阵为 $$ \\begin{aligned} P_k \u0026= \\mathrm{E}\\left( \\left((I-KC)\\bm{e}_k^- - K\\bm{v}_k\\right) \\left((I-KC)\\bm{e}_k^- - K\\bm{v}_k\\right)^T \\right) \\\\ \u0026= (I-KC)\\mathrm{E}\\left(\\bm{e}_k^- (\\bm{e}_k^-)^T\\right)(I-KC)^T + K \\mathrm{E}\\left(\\bm{v}_k\\bm{v}_k^T\\right)K^T \\\\ \u0026\\quad - (I-KC)\\mathrm{E}\\left(\\bm{e}_k^- \\bm{v}_k^T\\right)K^T - K\\mathrm{E}\\left(\\bm{v}_k(\\bm{e}_k^-)^T\\right)(I-KC)^T \\\\ \u0026=(I-KC)P_k^-(I-KC)^T + KRK^T \\end{aligned} $$ 而先验估计误差的协方差矩阵为 $$ \\begin{aligned} P_k^- \u0026= \\mathrm{E}\\left(\\left(\\bm{x}_k-\\hat{\\bm{x}}_k^-\\right)\\left(\\bm{x}_k-\\hat{\\bm{x}}_k^-\\right)^T \\right) \\\\ \u0026= \\mathrm{E}\\left(\\left(A\\bm{e}_{k-1}+\\bm{w}_{k-1}\\right)\\left(A\\bm{e}_{k-1}+\\bm{w}_{k-1}\\right)^T \\right) \\\\ \u0026= A\\mathrm{E}\\left(\\bm{e}_{k-1}\\bm{e}_{k-1}^T \\right) A^T + \\mathrm{E}\\left(\\bm{w}_{k-1}\\bm{w}_{k-1}^T \\right) \\\\ \u0026\\quad + A\\mathrm{E}\\left(\\bm{e}_{k-1}\\bm{w}_{k-1}^T \\right) +\\mathrm{E}\\left(\\bm{w}_{k-1}\\bm{e}_{k-1}^T \\right)A^T \\\\ \u0026= AP_{k-1}A^T + Q \\end{aligned} $$ 为了求解最小值问题，令 $\\mathrm{tr}(P_k)$ 对 $K$ 的导数为零，其中用到矩阵论的一般结论 $$\\frac{\\mathrm{d\\,tr}(AB) }{\\mathrm{d}A} = B^T, \\quad \\frac{\\mathrm{d\\,tr}(ABA^T) }{\\mathrm{d}A} = 2AB$$ 因而卡尔曼增益为 $$\\frac{\\mathrm{d\\,tr}(P_k) }{\\mathrm{d}K} = -2(I-KC)P_k^-C^T + 2KR = 0 \\quad \\Rightarrow \\quad K = P_k^-C^T\\left(CP_k^-C^T+R\\right)^{-1}$$ 将卡尔曼增益代回 $P_k$ 可将其化简为 $$P_k = \\left(I-KC\\right)P_k^-$$ ","date":"2021-08-19","objectID":"/kalmanfilter/:2:0","series":null,"tags":["卡尔曼滤波","滤波器"],"title":"卡尔曼滤波简介","uri":"/kalmanfilter/#公式推导"},{"categories":["控制理论基础"],"content":" 公式汇总卡尔曼滤波的五个核心公式总结如下： $$ \\left\\{ \\begin{aligned} \u0026\\left. \\begin{aligned} \\hat{\\bm{x}}_k^- \u0026= A \\hat{\\bm{x}}_{k-1} + B \\bm{u}_k \\\\ P_k^- \u0026= AP_{k-1}A^T+Q \\end{aligned} \\quad \\right\\} \\text{预测} \\\\ \u0026\\left. \\begin{aligned} K \u0026= P_k^-C^T\\left(CP_k^-C^T+R\\right)^{-1}\\\\ \\hat{\\bm{x}}_{k} \u0026= \\hat{\\bm{x}}_{k}^- + K\\left(y_k-C\\hat{\\bm{x}}_{k}^- \\right) \\\\ P_k \u0026= \\left(I-KC\\right)P_k^- \\end{aligned} \\quad \\right\\} \\text{更新} \\end{aligned} \\right. $$ ","date":"2021-08-19","objectID":"/kalmanfilter/:3:0","series":null,"tags":["卡尔曼滤波","滤波器"],"title":"卡尔曼滤波简介","uri":"/kalmanfilter/#公式汇总"},{"categories":["控制理论基础"],"content":" 参考文献 DR_CAN 卡尔曼增益超详细推导. R. Faragher. Understanding the Basis of the Kalman Filter Via a Simple and Intuitive Derivation. IEEE Signal Processing Magazine. 2012. ","date":"2021-08-19","objectID":"/kalmanfilter/:4:0","series":null,"tags":["卡尔曼滤波","滤波器"],"title":"卡尔曼滤波简介","uri":"/kalmanfilter/#参考文献"},{"categories":["生命在于折腾"],"content":"最近有兴趣折腾了一下 Vim，不免对这个上古神器的强大感到震撼。这篇文章简要记录下基本操作，只能说是冰山一角。 ","date":"2021-08-10","objectID":"/vim/:0:0","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#"},{"categories":["生命在于折腾"],"content":" 认识 Vim 基本模式Vim 有三种基本模式：普通模式、插入模式和命令行模式。普通模式是打开 Vim 之后的默认模式，也是进行模式转换的桥梁。在普通模式下，可以进行常规的浏览、替换、删除、粘贴等命令；在普通模式下按 i 即可切换到插入模式，这种模式与常规的文本编辑器相同，可以自由添加、修改、删除文本内容；按 Esc 可以从插入模式切换回普通模式，再次键入 : 会切换到命令行模式。这种模式支持各种命令的使用，在我看来也是 Vim 的强大之处所在。 注意 Vim 命令对大小写敏感，因此在使用 Vim 时务必确保大写锁定处于关闭状态。通常情况下，大家会建议将键盘的 Caps Lock 键重新映射为 Esc ，对于 Manjaro 系统，可以通过系统设置中的键盘的高级选项进行修改，非常方便。 当本文提及大写的命令如 A 时，实际上是指 Shift + a 的组合键。 ","date":"2021-08-10","objectID":"/vim/:1:0","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#认识-vim-基本模式"},{"categories":["生命在于折腾"],"content":" 退出 Vim网络上流传有这么一个段子：“问：如何产生随机字符串？答：让新手退出 Vim。” 退出 Vim 首先要确保处于普通模式，如果不是很确定，可以多按几次 Esc。然后输入 :quit 即可退出 Vim。这个命令可以这样来看，首先键入的 : 使 Vim 进入到命令行模式，而 quit 就是执行的命令。 可以猜想，如果只是写入文档而不退出（一般编辑器下的\"保存\"按钮），应当执行 :write ；如果想看某个命令的帮助文档，应该会涉及 :help 命令，实际上的确如此。在普通模式下输入 :help quit 就可以看到相应的帮助文档，其中 :q[uit] 的中括号部分表示可以省略。因此 :quit 可以简写为 :q 。 如果文档进行了改动，直接运行 :q 会抛出警告，这时需要写入后退出，或者不保存退出。汇总这些相关的命令，如下： :q — 退出 Vim （关闭文档）； :w — 写入（保存）文档但不退出； :wq — 保存并关闭当前文档； :q! — 忽略所有更改并关闭当前文档。 ","date":"2021-08-10","objectID":"/vim/:2:0","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#退出-vim"},{"categories":["生命在于折腾"],"content":" 移动光标移动光标需要在普通模式下进行，用于浏览文档或为编辑做准备。 ","date":"2021-08-10","objectID":"/vim/:3:0","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#移动光标"},{"categories":["生命在于折腾"],"content":" 基本移动普通模式下，光标移动可以通过以下按键实现： h — 左移一个字符； j — 下移一行； k — 上已一行； l — 右移一个字符； 0 — 移动到本行开头； $ — 移动到本行末尾； gg — 移动到文档首行开头； G — 移动到文档最后一行开头。 Vim 的命令在执行前可以指定重复次数，例如下移15行可以使用 15j 来完成。特别地，在 G 之前指定数字可以跳转到指定行。为了在 Vim 中显示行号，可以在普通模式下执行 :set number 。 技巧 当文档单行内容过长而 Vim 的 wrap 设置被启用（默认启用）时，过长的文字会在屏幕内自动换行，但这并不是真正的换行。Vim 默认的 j 命令是对实际行进行操作，遇到这种情况时难免会出乎我们的期望，因此可以使用 gj 和 gk 进行屏幕行的跳转。 为了默认使用屏幕行的跳转，我们会将 j 与 gj 的功能互换，可以在配置文件 .vimrc 中添加以下内容： text nnoremap k gk nnoremap gk k nnoremap j gj nnoremap gj j ","date":"2021-08-10","objectID":"/vim/:3:1","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#基本移动"},{"categories":["生命在于折腾"],"content":" 基于单词的移动比普通模式更快地，Vim 可以基于单词进行移动，主要命令如下： w — 移动到下一个单词开头（word）； e — 移动到当前单词结尾（end）； b — 向前移动到单词开头（backward）； ge — 向前移动到单词结尾； W — 移动到下一个字符串开头； E — 移动到下一个字符串结尾； B — 向前移动到字符串开头； gE — 向前移动到字符串结尾。 对比可以发现，小写命令针对单词，而大写命令针对的是字符串，两者的区别在于对特殊字符的处理方式：单词认为 ' 是单词之间的分割，而字符串则严格以空格作为分割。例如 let's go 这个短语会被 Vim 解读成 4 个单词或 2个字符串。 ","date":"2021-08-10","objectID":"/vim/:3:2","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#基于单词的移动"},{"categories":["生命在于折腾"],"content":" 基于查找的移动Vim 可以使用 f 对行内的单个字符进行查找，结合 ; 向后继续查找，当跳转过头时使用 , 向前查找。同样，也可以使用 / 对字符串进行查找，使用 n 或 N 分别向后、向前继续查找。 我们用下面的一个例子来对比各种移动光标的方法： text The quick brown fox jumps over the lazy dog. 假设现在光标处于这段话的开头，现在希望将光标跳转到 over 的开头，有这么几种做法： wwwww — 所见即所得，只要不觉得麻烦就可以达到效果； 5w — 与上一个命令等价，虽然按键少了，但需要一定的计算； fo;; — 首先 fo 指定了对字符 o 的查找，光标跳转到 brown 的中间，然后继续查找两次达成目标； fvh — 对 v 进行查找，然后向左移动一个字符； /over\u003cEnter\u003e — 对字符串 over 进行查找并跳转（其中 \u003cEnter\u003e 表示按回车键）。 对比这几种方法，第一种最直观，但是当句子特别长时跳转很慢；第二种虽然看起来简单，但数数的功夫容易得不偿失，也很少使用；第三种方法应该说是最常用也是最容易被人接受的，当句子较长时能够获得比较快的跳转速度；第四种是第三种的高阶用法，查找不常出现的字符以提高跳转速度；最后一种单次使用时输入较为复杂，通常结合替换使用。 ","date":"2021-08-10","objectID":"/vim/:3:3","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#基于查找的移动"},{"categories":["生命在于折腾"],"content":" 其他跳转方法% 可以用于配对符号之间的跳转，例如在 ( 处按 % 可以跳转到相应的 )，这个功能特别适合对代码进行检查。 m 和 ` 构成标记（mark）——跳转对。例如， ma 将当前位置标记为 a ，普通模式下使用 `a 就可以跳转到刚刚标记的位置。需要说明的是，标记只能是单个字符，并且区分大小写；单个文档可以存在多个标记。 ","date":"2021-08-10","objectID":"/vim/:3:4","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#其他跳转方法"},{"categories":["生命在于折腾"],"content":" 选定范围类比于英语中动词可以分为及物动词和不及物动词，Vim 中有些命令可以直接执行，例如 j 就是下移一行；也有些命令需要指定作用范围，这里我们以删除命令 d （delete）为例进行说明。 为了执行删除操作，按下 d 之后还应当给定删除范围。前面介绍跳转的时候说过 w 是从当前位置到下一个单词开头，确切地表明了范围。因此 dw 就是从当前位置删除到下一个单词的开头。类似地， d2w 就是从当前位置删除到后面第三个单词的开头（删除两个单词）、 d$ 从当前位置删除到本行结尾。 如果光标处于某个想删除的单词的中间，而使用 dw 删除时，光标之前部分不会被删除。为此，Vim 还提供了 a 和 i 这两个修饰词（可以理解为 around 和 inside）来进一步修饰范围， a 可以将选区扩展到光标两边，包括限定词； i 将选区扩展到两边，但是不包括限定词。例如， daw 将删除整个单词以及后面的一个空格，不管光标处于单词的哪个位置。使用 a 或 i 进行修饰时，除了使用 w 设定范围外，还可以使用配对符号进行扩展。例如，当光标处于某一对括号内部任意位置，使用 da) 可以删除整个括号内的内容，并连同括号一起删除。 特别地，Vim 的一些命令重复按两次表示对当前行进行操作，如 dd 为删除当前行。 除了使用命令划定范围外，与普通编辑器相同，可以先选定范围再执行操作。按 v 进入 Vim 的可视模式（visual mode），然后再利用前面介绍的各种跳转命令，可以发现光标遍历的位置高亮，这时候再执行 d 即可删除高亮选区。特别地， V 直接对整行进行选取。 组合键 Ctrl + v 在 Vim 中不再是粘贴，在普通模式下使用该组合键可以进入 Vim 的块选取模式，对应通常编辑器的列编辑功能，能够同时对多行进行相同的修改。 ","date":"2021-08-10","objectID":"/vim/:4:0","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#选定范围"},{"categories":["生命在于折腾"],"content":" 编辑文档","date":"2021-08-10","objectID":"/vim/:5:0","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#编辑文档"},{"categories":["生命在于折腾"],"content":" 在普通模式进行少量修改在普通模式下可以对文档进行部分删除和简单的替换工作，常用有： x — 删除当前字符； r — 使用另一个字符替换当前字符（replace），例如 re 是将光标下的字符替换为 e ； d — 删除操作，在上面已经讨论，不再赘述； . — 重复上一次操作。 ","date":"2021-08-10","objectID":"/vim/:5:1","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#在普通模式进行少量修改"},{"categories":["生命在于折腾"],"content":" 从插入模式编辑文档编辑文档最主要的方式是进入编辑模式，像普通编辑器一样编辑文档。Vim 提供以下基本的方式进入插入模式： i — 从当前光标之前进入插入模式（insert）； I — 从当前行（或可选模式下的选区）之前进入插入模式； a — 从当前光标之后进入插入模式（append）； A — 从当前行（或可选模式下的选区）之后进入插入模式； o — 向下插入新行并进入插入模式； O — 向上插入新行并进入插入模式； s — 删除当前字符并进入插入模式； S — 删除当前行并进入插入模式。 Vim 还可以使用 c 命令进行更改（change），例如 caw 表示删除当前的单词并进入插入模式。这种方法在修改程序时非常有效，例如修改字符串变量 sys_name = \"Windows 10\" 时，将光标移至双引号内部任意位置，使用 ci\" 即可删除字符串变量的值并进行修改。 ","date":"2021-08-10","objectID":"/vim/:5:2","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#从插入模式编辑文档"},{"categories":["生命在于折腾"],"content":" 搜索与替换前面介绍了 / 进行搜索，而替换则需要结合命令行 :s 实现（substitute）,例如将 old 替换为 new ，有以下几种不同的方式： :s/old/new — 从光标之后对当前行进行搜索，将第一个 old 替换为 new； :s/old/new/g — 从光标之后对当前行进行搜索，将所有 old 替换为 new； :%s/old/new/g — 对全文进行搜索，将所有 old 替换为 new； :%s/old/new/gc — 对全文进行搜索，将所有 old 替换为 new，并在执行前进行确认。 ","date":"2021-08-10","objectID":"/vim/:5:3","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#搜索与替换"},{"categories":["生命在于折腾"],"content":" 进行简单的计算在普通模式使用组合键 Ctrl + a 可以对光标下的数字加一，而使用 Ctrl + x 则进行减一操作。当光标不处于数字上，Vim 会自动从光标之后搜索当前行的第一个数字，执行相应操作。同样地，这种方式可以指定次数运行，例如 10\u003cCtrl\u003ea 是将当前数字加 10 。 注意 应当注意，Ctrl + a 和 Ctrl + x 都是针对单词的操作，因此小数将以小数点分界，作为两个整数来对待。 如果数字以 0 开头，Vim 默认将其解释为八进制，因此对 007 进行 \u003cCtrl\u003ea 命令后，得到的是 010 而不是 008。为了只使用十进制，可以在配置文件 .vimrc 中添加 set nrformats= 进行设置。 在插入模式中，可以使用 Ctrl + r + = 触发计算功能，输入计算表达式后，按 Enter 即可将计算结果输出到当前位置。例如 \u003cCtrl\u003er=1+1\u003cEnter\u003e 将会输入 2 。 ","date":"2021-08-10","objectID":"/vim/:5:4","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#进行简单的计算"},{"categories":["生命在于折腾"],"content":" 寄存器简介Vim 提供多种寄存器，用于储存复制或删除的内容。寄存器可以通过 \" 进行引用，有以下几种常见寄存器： [a-z] — 有名寄存器，用于各种自定义内容； \" — 无名寄存器，不指定寄存器时默认使用该寄存器； 0 — 复制专用寄存器（书里这么写的，我也不知道为啥要起这个名字，实际上复制不一定非要用这个）； + — 系统剪切板，用于系统级的复制粘贴； _ — 黑洞寄存器，所有在这里的东西都丢失，彻彻底底地删除； = — 表达式寄存器，可以用于计算； % — 当前文件名。 还有一些其他寄存器，这里不多赘述。 ","date":"2021-08-10","objectID":"/vim/:6:0","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#寄存器简介"},{"categories":["生命在于折腾"],"content":" 复制与粘贴以复制粘贴这个经典的例子来介绍寄存器的使用。 复制可以使用 y 来实现（yank），而粘贴使用 p 完成（paste）。复制时需要指定范围，可以用限定词来指定，如 yaw 为复制当前单词；也可以用可视模式进行选择。p 默认将内容粘贴在光标之后（Vim 会自动判断是否换行），也可用 P 粘贴在之前，或使用可视模式进行选择替换。特别地， yy 将对当前行进行复制。 上面这种直接复制的方法没有指定寄存器，默认使用无名寄存器 \",即 yy 命令等价于 \"\"yy （第一个 \" 表示使用寄存器，第二个 \" 表示使用无名寄存器）。使用无名寄存器容易导致复制的内容丢失，我们看下面一个例子： text 1) 使用 `yy` 命令复制本行； 2) 使用 `dd` 命令删除本行； 3）尝试在此使用 `p` 命令将第一行内容粘贴到本行之下。 如果按照上面的提示做，会发现最后粘贴的是第二行的内容。这是因为第二行使用 dd 删除的内容并没有真正的删除，而是以剪切的方式储存在寄存器内，而前面的 yy 和这里的 dd 均没有显式指定寄存器，所有都使用的是无名寄存器。无名寄存器第一次复制的内容被第二次删除的内容覆盖，因此粘贴时读取的无名寄存器是第二行内容。 为此，可以改变操作顺序，如先删除，后复制。也可以使用显式指定其他寄存器以避免内容覆盖，例如可以使用 \"0yy 和 \"0p 进行复制粘贴；或者可以将删除内容放置到其他寄存器如 \"_dd 。 可以同时使用多个寄存器，例如复制帐号和密码时，可以使用 \"ay 将帐号复制到寄存器 a ，而使用 “by 将密码复制到寄存器 b。粘贴分别使用 \"ap 和 \"bp 即可。 上述的粘贴是在普通模式进行，为了在插入模式直接读取寄存器内容，可以使用 Ctrl + r 组合键，指定寄存器后即可将内容粘贴到正文。 忘记寄存器内容时，可以使用 :reg 命令进行查看。 ","date":"2021-08-10","objectID":"/vim/:6:1","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#复制与粘贴"},{"categories":["生命在于折腾"],"content":" 宏的录制与回放寄存器中还可以保存命令（宏），并在特定的时候执行（回放）。普通模式下按 q 并指定寄存器即可开启宏的录制，再次按 q 即停止录制。在使用寄存器内保存的宏时，使用 @ 和寄存器名即可。 例如，如果要在 Markdown 中使用 Enter 这样的键盘样式，需要输入指令 \u003ckbd\u003eEnter\u003c/kbd\u003e，非常麻烦。因此可以录制一个宏，自动在单词两边分别添加 \u003ckbd\u003e 和\u003c/kbd\u003e 。假如我将这个宏录制到寄存器 k，具体步骤如下： 普通模式下将光标移动到需要添加键盘样式的单词处； 键入 qk 开始录制宏，并指定将宏录制到有名寄存器 k； 使用 ciw 删除当前单词并保留两边的空格，进入插入模式，输入前缀 \u003ckbd\u003e； 在插入模式中使用\u003cCtrl\u003er\" 读取无名寄存器的内容，即上一步删除的单词，然后输入后缀 \u003c/kbd\u003e； 按 Esc 返回普通模式，按 q 停止录制。 如此做，只需要在另一个需要添加键盘样式的单词处使用 @k 即可调用宏。使用 @ 回放宏的时候，也可以像普通命令一样指定次数。一个经典的例子就是在各行前面添加行号，需要结合一定的脚本，使用以下方式实现： 在命令行运行 :let i=1 设定行号初值，并将光标移动到需要编号的那一行； 使用 qq 开始录制宏，并将其录制到寄存器 q； 使用 I\\\u003cCtrl\u003er=i\\\u003cEnter\u003e) 将变量 i 的值插入到行的最前面，并添加 ) 进行修饰； 按 Esc 回到普通模式，运行 :let i+=1`` 进行递归，然后按 j` 换行； 按 q 停止宏录制，然后使用 22@q\u003e 将宏重复 22 次（2 与 @在同一个键位，用起来方便而已）。 当行数不足以满足指定的重复次数时，Vim 会自动停止回放宏，因此无需担心指定次数不准确的问题。 ","date":"2021-08-10","objectID":"/vim/:6:2","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#宏的录制与回放"},{"categories":["生命在于折腾"],"content":" 参考文献 Neil D. Vim实用技巧. 杨源, 车文隆, 译. 人民邮电出版社, 2014. ","date":"2021-08-10","objectID":"/vim/:7:0","series":null,"tags":["Vim","文本编辑器"],"title":"Vim 简介","uri":"/vim/#参考文献"},{"categories":["数字信号处理"],"content":"在系统仿真中通常使用噪声滤波器对白噪声进行塑形，从而验证色噪声对系统性能的影响。然而通常滤波器的阶次是整数，难以实现诸如 $1/f^\\alpha , (0\u003c \\alpha \u003c2)$ 分数阶次的粉红噪声。为此，我们可以在仿真之前利用傅立叶逆变换把噪声造出来，然后引入模型进行仿真。本文将介绍构造噪声的方法。 ","date":"2021-08-03","objectID":"/gennoise/:0:0","series":null,"tags":["噪声生成","功率谱"],"title":"产生任意谱密度的噪声","uri":"/gennoise/#"},{"categories":["数字信号处理"],"content":" 基本原理制造噪声的基本思路非常简单，分为以下三步： 根据给定的功率谱密度计算噪声在正频率部分的频谱； 产生随机相位，构造噪声完整频谱； 利用傅立叶逆变换计算噪声时域序列。 注意 功率谱密度（PSD, Power Spectrum Density）是信号自相关函数的傅立叶变换，其单位为 $\\mathrm{*^2/Hz}$ 。然而习惯上使用时通常对其进行开方运算，因而有了 $\\mathrm{*/\\sqrt{Hz}}$ 这种看起来很奇怪的单位。为了避免这种混淆，LTPDA 将开方后的功率谱称为 ASD（Amplitudy Spectrum Density）。本文借鉴这种表述，如无特别说明，功率谱均指 ASD 。 考虑单边 ASD 与傅立叶变换的频谱之间的关系为： $$\\mathrm{ASD}(k) = \\sqrt{\\frac{2}{N f_s}} \\left| X(k) \\right|$$ 为了计算 $\\left|X(k)\\right|$，需要各频点的谱密度。在傅立叶变换中，频率点的构造应当把握以下两个原则： 频率从 0 Hz 开始，最大不超过采样率 $f_s$ ； 频率分辨率为 $f_s/N$ ，其中 $N$ 为采样点数。 由于傅立叶变换具有周期性，因而 $(f_s/2,, f_s)$ 与 $(-f_s/2,,0)$ 的频谱相同，习惯上称其为负频率部分。由于具有共轭对称性，构造频率点时只需要构造正频率部分。在 MATLAB 中可以使用以下命令： matlab f = (0:floor(N/2))'*fs/N; 然后根据给定的 ASD 解析式即可计算正频率点频谱的模。 构造随机相位可以使用 randn 命令，然后利用复数的指数表达 $X(k) = \\left|X(k)\\right| \\mathrm{e}^{j\\phi(k)}$ 计算频谱的复数形式。为了构造完整的频谱，在利用共轭对称性时应当注意数据点的奇偶性： 当 $N$ 为奇数时：频率点不包含 $f_s/2$，直接将前面计算的正频率部分除了第一个 0 Hz 点之外的部分倒序共轭，并拼凑在原序列之后即可； 当 $N$ 为偶数时：频率点包含 $f_s/2$ ，共轭对称时要去除第一个 0 Hz 和最后一个 $f_s/2$ 的点，并拼凑在原序列之后。 构造完整频谱之后，使用 ifft 即可获得噪声的时域序列。应当注意的是，由于数值误差的存在，ifft 的输出存在很小的虚部，这是只需用 real 取其实部即可。 ","date":"2021-08-03","objectID":"/gennoise/:1:0","series":null,"tags":["噪声生成","功率谱"],"title":"产生任意谱密度的噪声","uri":"/gennoise/#基本原理"},{"categories":["数字信号处理"],"content":" 噪声测试首先根据以下形式的 ASD 生成 $1/f$ 噪声： $$\\mathrm{ASD}(f) = \\frac{0.05}{\\sqrt{f}} + 1$$ 产生的噪声如下图所示，可以看出时域基本具有随机信号的特性，且 ASD 与目标基本一致，初步判定噪声满足频域形状的需求。 生成噪声的谱密度测试 平稳随机噪声的特性应当不随时间改变，因此不同时间段的噪声应当具有相同的特性。为此，对生成的数据进行分段作谱（分段之间允许部分重叠），结果如下图所示，生成的噪声也能够满足平稳随机的要求。 生成噪声的平稳性测试 最后验证噪声的相关性：一方面自相关可以体现噪声各个时段内的相关性，理想情况下不同时段相关性为 0 ；另一方面使用相同设置生成另一组噪声，两组噪声之间应该相互独立，相关系数应当为 0 。测试结果如下图，可见满足需求。 生成噪声的相关性测试 针对生成的噪声还可以进行更加严格的相关性测试，但这超出了我自己的需求，就不再过多赘述。最后展示一个频域为正弦的噪声示例（给大家看看什么叫秀，狗头保命）。 花里胡哨噪声示例 matlab ASD = @(f) sin(pi*f) + 7; fs = 20; N = 1e3*fs; x = genNoise(ASD,fs,N); figure subplot(211) t = (0:N-1)'/fs; plot(t,x) grid on xlabel('Time (s)') ylabel('Noise (*)') subplot(212) [pxx,fx] = iLPSD(x,fs); plot(fx,sqrt(pxx)) hold on grid on plot(fx,ASD(fx)) xlabel('Frequency (Hz)') ylabel('Noise ASD (*/Hz^{1/2})') ","date":"2021-08-03","objectID":"/gennoise/:2:0","series":null,"tags":["噪声生成","功率谱"],"title":"产生任意谱密度的噪声","uri":"/gennoise/#噪声测试"},{"categories":["数字信号处理"],"content":" 参考文献 宋知用. MATLAB 数字信号处理 85 个实用案例精讲: 入门到进阶. 北京航空航天大学出版社, 2016. ","date":"2021-08-03","objectID":"/gennoise/:3:0","series":null,"tags":["噪声生成","功率谱"],"title":"产生任意谱密度的噪声","uri":"/gennoise/#参考文献"},{"categories":["生命在于折腾"],"content":"一些不常用但是可能有用的小技巧，或许会不定时更新吧。 ","date":"2021-07-10","objectID":"/tricks/:0:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#"},{"categories":["生命在于折腾"],"content":" Inkscape 批量导出图片之前用 Inkscape 画了很多矢量图，今天想把它们转成位图，一个一个打开再导出太麻烦了，于是想到 Inkscape 的命令行操作，果然有这个命令。结合 Python，可以轻松实现批量导出： Python import os files = os.listdir() for file in files: ## 图片之前另存了 PDF，以此为例 if os.path.splitext(file)[-1] == '.pdf': bash_command = 'inkscape ' + file.replace(' ',r'\\ ') + ' --export-type=png --export-dpi=600' os.system(bash_command) ","date":"2021-07-10","objectID":"/tricks/:1:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#inkscape-批量导出图片"},{"categories":["生命在于折腾"],"content":" Linux 测试 U 盘读写速度最简单的方法就是实测，使用 dd 命令随机写入数据并读取，测试速度。这里需要用到两个特殊的设备 /dev/zero ：文件\"白洞\"，产生任意大小的随机文件； /dev/null ：文件\"黑洞\"，所有写入的内容都被忽略。 使用 df -h 可以发现我的 U 盘挂载在 /run/media/xiaocy/misaka，于是可以用下面的命令进行测试： bash ## 测试写入 time dd if=/dev/zero of=/run/media/xiaocy/xiaocy/test.tmp bs=4k count=100000 ## 测试读取 time dd if=/run/media/xiaocy/xiaocy/test.tmp of=/dev/null bs=4k ","date":"2021-07-10","objectID":"/tricks/:2:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#linux-测试-u-盘读写速度"},{"categories":["生命在于折腾"],"content":" CSGO 绑定跳投在 CSGO 文件夹 \u003cCSGO-root-path\u003e/csgo/cfg/ 内新建 keybind.cfg 文件，并输入以下内容 text alias +jumpthrow\"+jump;-attack;-attack2\"; alias -jumpthrow -jump; bind t +jumpthrow; 每次运行 CSGO 时，按 ~ 键打开控制台，执行 exec keybind 即可。使用跳投时先点鼠标左键，然后按 t 即可。 控制台执行的命令 keybind 即为创建的 .cfg 文件名，可根据自己喜好修改；绑定的跳投键为上述代码第三行的第二个参数，也可以自行修改。 ","date":"2021-07-10","objectID":"/tricks/:3:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#csgo-绑定跳投"},{"categories":["生命在于折腾"],"content":" Vim 中文输入法问题当使用 Vim 编辑中文文本时，在切换插入模式和普通模式时需要频繁切换输入法，为此可以使用 fcitx.vim 插件自动化解决这个问题。 对于 Manjaro 系统，也可以从 AUR 中一键安装该插件： yay -S vim-fcitx 。在命令行使用时，切换模式会存在延时，进一步可以在 ~/.vimrc 配置文件中引入 set ttimeoutlen=100 而将其设置为较小值。 ","date":"2021-07-10","objectID":"/tricks/:4:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#vim-中文输入法问题"},{"categories":["生命在于折腾"],"content":" Linux 终端补全忽略大小写在家目录下创建 .inputrc 并写入： text set completion-ignore-case on 然后重启终端即可。 ","date":"2021-07-10","objectID":"/tricks/:5:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#linux-终端补全忽略大小写"},{"categories":["生命在于折腾"],"content":" VSCodeVim 配置为了自动切换中英文输入法，在配置文件中添加以下设置（适用于 fcitx5 框架）： text \"vim.autoSwitchInputMethod.enable\": true, \"vim.autoSwitchInputMethod.defaultIM\": \"1\", \"vim.autoSwitchInputMethod.obtainIMCmd\": \"/usr/bin/fcitx5-remote\", \"vim.autoSwitchInputMethod.switchIMCmd\": \"/usr/bin/fcitx5-remote -t {im}\", 添加以下配置可以重新将 j 和 k 映射为 gj 和 gk ： text \"vim.normalModeKeyBindingsNonRecursive\": [ { \"before\": [\"j\"], \"after\": [\"g\", \"j\"] }, { \"before\": [\"k\"], \"after\": [\"g\", \"k\"] } ] ","date":"2021-07-10","objectID":"/tricks/:6:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#vscodevim-配置"},{"categories":["生命在于折腾"],"content":" Linux 解压时中文乱码使用附带 -O cp936 选项的 unzip 命令即可。需要注意，某些发行版的 unzip 不提供 -O 选项，需要安装 unzip-iconv 。 解压示例： bash unzip -O cp936 中文解压包.zip ","date":"2021-07-10","objectID":"/tricks/:7:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#linux-解压时中文乱码"},{"categories":["生命在于折腾"],"content":" Linux 增加 Swap 分区大小使用 Linux 做计算时如果内存不够用，可以使用 Swap 空间将部分硬盘当作内存使用。如果 Swap 空间不够，可以使用以下方法进行扩容（需要管理员权限运行）： 查看当前 Swap 空间大小：free 创建空文件用做 Swap 空间：sudo dd if=/dev/zero of=/swapfile bs=1M count=4096 （创建了 4 GB 空间） 将上一部创建的文件指定为 Swap 空间： sudo mkswap /swapfile 启用交换空间： sudo swapon /swapfile 查看当前 Swap 空间大小： free 以上方法用于临时性地扩容，如果想要永久设置，设置 swapfile 开机时自动挂载即可：编辑 /etc/fstab ，在最后一行加入： text /swapfile swap swap 0 0 ","date":"2021-07-10","objectID":"/tricks/:8:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#linux-增加-swap-分区大小"},{"categories":["生命在于折腾"],"content":" Linux 定时任务定时任务可以使用 crontab 实现，常用的命令有： bash crontab -l ## 查看定时任务 crontab -e ## 编辑定时任务 crontab -r ## 删除所有任务 新建定时任务只需要按时间加命令的形式给出，由空格进行分割，其中时间由五个数字构成，分别是：分、时、日、月、周，并支持以下操作符 * — 所有可行取值 / — 指定重复周期 - — 指定时间范围 , — 离散时间序列 例如： text * * * * * myTask ## 每分钟运行一次 myTask 0 * * * * myTask ## 每小时整点运行一次 myTask 30 8 * * 1-5 myTask ## 每周一到周五的 8:30 运行 myTask 0 7-21/3 * * * myTask ## 7 点到 21 点每 3 小时运行一次 myTask 注意 为了确保定时任务生效，还需要启动相应的服务。在 manjaro 系统中，使用 sudo systemctl start cronie.service 可以开启服务，相应的将 start 选项改为 enable 可以设置自动启动； stop 可以关闭服务， status 查看当前服务状态。 ","date":"2021-07-10","objectID":"/tricks/:9:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#linux-定时任务"},{"categories":["生命在于折腾"],"content":" Linux WPS 高分辨率屏幕显示模糊编辑启动文件，在执行命令前增加 env QT_SCREEN_SCALE_FACTORS=1 即可。 ","date":"2021-07-10","objectID":"/tricks/:10:0","series":null,"tags":["小技巧"],"title":"日常小技巧","uri":"/tricks/#linux-wps-高分辨率屏幕显示模糊"},{"categories":["控制理论基础"],"content":"对于实际的系统，控制器的输出应当受到幅度限制，以避免超出执行机的量程。然而，在具有积分的控制器中如果仅对输出进行限幅，将会引起所谓的退饱和现象，使控制器的性能变差甚至导致系统不稳定。这回我们来谈谈抗饱和积分器。 ","date":"2021-06-19","objectID":"/integratorantiwindup/:0:0","series":null,"tags":["抗饱和","积分器"],"title":"抗饱和积分","uri":"/integratorantiwindup/#"},{"categories":["控制理论基础"],"content":" 退饱和现象考察这样一种情形：积分器首先得到正值信号的输入，当积分输出达到限幅后，再经过一段时间，输入变为负值。问：积分器的输出是否会在输入信号变号的那个时刻从限福开始下降？想象一下玩 CSGO 时一直往前走直到顶到墙上，这就对应着积分限幅，这时只要按下后退键，人物立马就会离开墙面。然而遗憾的是，如果像下面这样仅仅对输出进行限幅，实际的输出可能并不会如你所愿。 积分输出限幅示意图 不妨用仿真来看看到底是什么情况： 积分限幅的退饱和过程 上面的子图是积分器的输入，在前 2 s 内为正， 2 s 后变为负值。积分器和限幅后的输出分别如下图的蓝色和红色曲线所示。可以看到，这种限幅并没有使输出达到饱和后停止积分，所以内部的积分仍然在持续进行，当输入变号时，积分器的输出立刻开始减小，但是仍然在限幅器的阈值之外，因此输出仍然为饱和值，直到积分减小到限幅以内。红色曲线以上的蓝色曲线下降部分就是我们所说的退饱和现象。这种现象会引起控制器输出的\"延时\"，为了时积分的输出在输入变号时立刻开始反向积分，需要对积分进行限幅，达到图中黄色曲线的效果。 ","date":"2021-06-19","objectID":"/integratorantiwindup/:1:0","series":null,"tags":["抗饱和","积分器"],"title":"抗饱和积分","uri":"/integratorantiwindup/#退饱和现象"},{"categories":["控制理论基础"],"content":" 抗饱和积分器抗饱和积分器的基本思路就是在输出达到饱和时停止积分，实现这一目的最基本的方法就是采用逻辑回路控制积分器的输入，如下图所示： 基于逻辑回路的抗饱和积分器 以这种方式，当积分器的输出达到饱和，且输入与输出同号，则将积分器的输入置零，避免过度积分。除了使用逻辑电路从根本上解决问题外，下面的方式展示了如何利用反馈解决这个问题： 基于增益反馈的抗饱和积分器 以这种方式，当积分器没有达到饱和时，反馈为零，不影响积分器的正常功能；当积分器达到饱和时，通过一个大的抗饱和增益 $K_a$ 进行误差反馈，根据稳定环路下误差趋近于零的条件，可以知道此时积分器的输入几乎为零，积分器近似停止工作。 利用逻辑回路构造的抗饱和积分器是最理想的，但却难以整合在模拟电路中；利用抗饱和增益的反馈虽然具有一定的近似，但很容易在工程中实现。下图展示了这两种方式的对比，随着 $K_a$ 的增大，抗饱和反馈的方式会趋近于逻辑回路控制积分器的方式。 不同增益下的抗饱和积分器性能对比 ","date":"2021-06-19","objectID":"/integratorantiwindup/:2:0","series":null,"tags":["抗饱和","积分器"],"title":"抗饱和积分","uri":"/integratorantiwindup/#抗饱和积分器"},{"categories":["控制理论基础"],"content":" 积分饱和对控制的影响前面提到过，积分器的退饱和过程相当于对系统引入了不确定的延时，下面以一个例子来简单展示抗饱和积分对控制的影响。假设被控对象为一阶积分器，采用 PI 控制，如图所示： 闭环系统结构框图 利用增益的方式对积分器进行抗饱和前后，系统的响应如下： 抗饱和积分的反馈效果 可见，如果不采用抗饱和积分器，控制命令由于退饱和而存在一定延时，导致系统的输出具有较大的超调，并因此而具有较长的收敛时间。唔，实际使用时还是得用抗饱和积分器。 ","date":"2021-06-19","objectID":"/integratorantiwindup/:3:0","series":null,"tags":["抗饱和","积分器"],"title":"抗饱和积分","uri":"/integratorantiwindup/#积分饱和对控制的影响"},{"categories":["控制理论基础"],"content":" 参考文献 【中英双字】了解 PID 控制，第 2 部分：超越简单的积分 MATLAB\u0026Simulink. G.F. Franklin, J. D. Powell, and A. Emami-Naeini, Feedback Control of Dynamic Systems, 7th ed. 2014. ","date":"2021-06-19","objectID":"/integratorantiwindup/:4:0","series":null,"tags":["抗饱和","积分器"],"title":"抗饱和积分","uri":"/integratorantiwindup/#参考文献"},{"categories":["数字信号处理"],"content":"线性系统对不同频率信号的幅度和相位有不同的响应，据此可以实现信号在频域上的分离，这就是所谓的滤波，相应的系统称为滤波器。无论是 MATLAB 还是 Python 都具有完善的工具包对常用线性滤波器进行设计，本文简要介绍这些函数及其用法。 ","date":"2021-06-02","objectID":"/filterdesign/:0:0","series":null,"tags":["滤波器"],"title":"信号的滤波","uri":"/filterdesign/#"},{"categories":["数字信号处理"],"content":" 滤波器的参数及分类滤波器的性能通常以其幅频响应为评估依据，主要包括以下四个参数： 通带内的纹波 $R_{\\rm pass}$：滤波器在通带内的增益允许波动的范围，单位为 $\\rm dB$ ； 阻带内的衰减 $R_{\\rm stop}$：阻带内的信号相比于通带信号的衰减，以 $\\rm dB$ 表示； 通带频率 $f_{\\rm pass}$：在这个频率范围内，滤波器的增益变动不超过通带纹波的约束； 阻带频率 $f_{\\rm stop}$：在这个频率范围内，滤波器对信号的衰减达到阻带衰减倍数的需求。 以低通滤波器为例，上述四个参数可以用下图来表示 滤波器基本参数示意图 在对延时比较敏感的实时系统中，还需要讨论滤波器的群延时，其定义为相频响应的负导数，即 $$\\tau_g = -\\frac{\\mathrm{d}\\varphi(\\omega)}{\\omega}$$ 根据滤波器实现方法的不同，可以将其分为模拟滤波器和数字滤波器，前者用于处理连续信号，主要通过模拟电路实现，以拉普拉斯变换为主要的分析工具；后者则用于处理采样后的离散信号，可以部署在各种数字器件，以 $z$ 变换为主要分析工具。 依据冲击响应还可以将滤波器分为无限脉冲响应（IIR）和有限脉冲响应（FIR），从时域上看，两者的区别在于滤波器的冲击响应是否在有限时间内收敛到 $0$ ；从频域上看，IIR 滤波器的传递函数具有至少一个极点（传递函数的分母包含 $s$ 或 $z^{-1}$），而 FIR 滤波器不具有极点，因此也称其为纯零点滤波器。 ","date":"2021-06-02","objectID":"/filterdesign/:1:0","series":null,"tags":["滤波器"],"title":"信号的滤波","uri":"/filterdesign/#滤波器的参数及分类"},{"categories":["数字信号处理"],"content":" IIR 滤波器设计常用的 IIR 滤波器有巴特沃斯滤波器、切比雪夫 I 型滤波器、切比雪夫 II 型滤波器和椭圆滤波器。为了精确指定滤波器特性，先使用函数计算滤波器的阶数和带宽，然后再对滤波器系数进行设计。在 MATLAB 中，相应的设计函数如下表所示。 滤波器 求解阶数和带宽 滤波器设计 巴特沃斯滤波器 [n,Wn] = buttord(Wp,Ws,Rp,Rs,'s') [b,a] = butter(n,Wn,'s') 切比雪夫 I 型滤波器 [n,Wn] = cheb1ord(Wp,Ws,Rp,Rs,'s') [b,a] = cheby1(n,Rp,Wn,'s') 切比雪夫 II 型滤波器 [n,Wn] = cheb2ord(Wp,Ws,Rp,Rs,'s') [b,a] = cheby2(n,Rs,Wn,'s') 椭圆滤波器 [n,Wn] = ellipord(Wp,Ws,Rp,Rs,'s') [b,a] = ellip(n,Rp,Rs,Wn,'s') 上表中， 's' 选项对应的是模拟滤波器，这时 Wp 和 Ws 的单位都是 $\\rm rad/s$ ， Rp 和 Rs 的单位均为 $\\rm dB$。对于数字滤波器，调用函数时应当取消 's' 选项，并且频率采用归一化的数字频率。 对于 Python 用户， scipy.signal 提供了同名的函数，使用方法基本一致，但 's' 选项应更换为关键字参数 analog=True 。 以 Wp=1 ， Ws=3 ， Rp=1 和 Rs=40 为例设计模拟滤波器，幅频响应如下图所示 常用滤波器的幅频响应 可见，在相同参数设置下： 巴特沃斯滤波器通带平坦，阻带无纹波，但阶数最高； 切比雪夫 I 型滤波器通带有纹波，阻带无纹波，阶数适中； 切比雪夫 II 型滤波器通带无纹波，阻带有纹波，阶数适中； 椭圆滤波器通带和阻带均有纹波，但阶数最少。 ","date":"2021-06-02","objectID":"/filterdesign/:2:0","series":null,"tags":["滤波器"],"title":"信号的滤波","uri":"/filterdesign/#iir-滤波器设计"},{"categories":["数字信号处理"],"content":" FIR 滤波器设计FIR 滤波器是一种全零点数字滤波器，与 IIR 滤波器相比，不存在系统稳定性问题，且具有良好的线性相位，即滤波引入的延时是恒定的。但是为了达到相同的频率相应，FIR滤波器通常需要更高的阶数。 在 MATLAB 中，可以使用 fir1 或 fir2 进行FIR滤波器设计，前者基于窗函数设计法，设计时只需要给定滤波器阶数和带宽即可；后者基于频率采样设计法，设计时要给定阶数、频率和目标增益。 对于 Python 用户，相应的函数由 scipy.signal 包提供，分别为 firwin 和 firwin2 ，用法也是完全一致。 由于 FIR 滤波器的设计没有明确给定通带纹波、阻带衰减等特性，设计完成后通常需要验证其是否满足需求。 ","date":"2021-06-02","objectID":"/filterdesign/:3:0","series":null,"tags":["滤波器"],"title":"信号的滤波","uri":"/filterdesign/#fir-滤波器设计"},{"categories":["数字信号处理"],"content":" 零相位滤波数字滤波器的本质是差分方程，因此可以将滤波器系数转化为差分方程的系数，通过迭代实现滤波。这种动态相应通常以延时的形式表现在输出信号，如果滤波器的延时过大，可能对后续的过程产生影响。为了补偿滤波器引入的延时，有三种常用的方法： 互相关校准：将输出和输入的互相关来评估系统延时从而进一步补偿； 全通滤波器：这种滤波器在全频带内的增益都是恒定的，用于调整系统的相位以补偿前置滤波器引入的群延时； 零相位滤波：一种非因果的滤波技术，可以对延时进行补偿。 这里主要介绍零相位滤波，其实现方法主要有以下四步： 使用通常的滤波手段（差分方程）对数据进行滤波； 将滤波后的数据进行时域翻转； 将翻转后的数据再次滤波； 再次进行时域翻转。 从感性上看，第一次滤波是从前往后滤，因此向后引入了延时；第二次滤波是从后往前滤，向前引入的相同的\"延时\"。由于采用的是完全相同的滤波器，因而延时可以完全抵消。 为了使用滤波器，在 MATLAB 中可以使用 filter(b,a,x) 进行滤波，也可以使用 filtfilt(b,a,x) 进行零相位滤波。在Python中，这两个函数分别对应于 scipy.signal 中的 lfilter 和 filtfilt。下图给出同一个滤波器使用两种滤波方法对带噪声的正弦信号滤波后的结果。 零相位滤波示例 一般的滤波方法引入了可见的延时，而零相位滤波器没有引入明显延时。此外，相同滤波器下，零相位滤波器的输出结果更光滑，这是因为它对数据进行了两次滤波，其增益特性将是一次滤波的平方。需要注意的是，一般的滤波只在数据的开始阶段存在过渡过程，而零相位滤波在数据两端都有过渡过程。为了消除这些过渡过程，可以使用自适应技术提前对数据进行一定程度的预测。 零相位滤波是在数据采集完成之后才能进行的操作，不能实时处理，这也就是所谓\"非因果系统\"的实际含义。对于实时系统，只能通过其他的手段对延时进行补偿。 ","date":"2021-06-02","objectID":"/filterdesign/:4:0","series":null,"tags":["滤波器"],"title":"信号的滤波","uri":"/filterdesign/#零相位滤波"},{"categories":["数字信号处理"],"content":"数字信号处理中经常会用到微分，典型的例子就是数字 PID 控制器中的微分环节。然而理想的微分是不存在的，即使存在，其对高频噪声的放大也约束了它的实际应用。这篇文章我们将讨论并对比一些常见的微分算法。 ","date":"2021-05-25","objectID":"/diffsignal/:0:0","series":null,"tags":["数字微分","跟踪微分"],"title":"信号的微分","uri":"/diffsignal/#"},{"categories":["数字信号处理"],"content":" 从数值差分聊起对于数字信号，最简单的微分方式莫过于使用后向差分对微分近似，设采样时间间隔为 $T_s$（采样率为 $f_s = \\frac{1}{T_s}$），传递函数为： $$H(z) = \\frac{1}{T_s} \\left( 1 - z^{-1} \\right)$$ 其幅频响应为： $$ \\begin{aligned} \\left| H \\left(\\mathrm{e}^{\\mathrm{j}\\omega} \\right) \\right| \u0026= \\left| \\left. H\\left(z\\right) \\right|_{z=\\mathrm{e}^{\\mathrm{j}\\omega T_s}} \\right| \\\\ \u0026= \\frac{1}{T_s} \\left| 1 - \\mathrm{e}^{-\\mathrm{j}\\omega T_s} \\right| \\\\ \u0026= \\frac{1}{T_s}\\left| 1 - \\left( \\cos\\omega T_s - \\mathrm{j} \\sin \\omega T_s\\right) \\right| \\\\ \u0026= \\frac{1}{T_s} \\sqrt{ \\left( 1 - \\cos \\omega T_s \\right)^2 + \\sin^2 \\omega T_s } \\\\ \u0026= \\frac{1}{T_s} \\sqrt{ 2 - 2 \\cos \\omega T_s } \\\\ \u0026= \\frac{1}{T_s} \\sqrt{4 \\sin^2 \\frac{\\omega T_s}{2}} \\\\ \u0026= 2 f_s \\sin \\pi\\frac{f}{f_s} \\approx 2\\pi f = \\left| s \\right| \\quad (f \\ll f_s) \\end{aligned} $$ 可见数值差分与理想微分 $s$ 的传递函数存在差异，只有采样率远大于被微分信号的频率时才可以用差分代替微分。 除此之外，在 Nyquist 采样定理的约束，即 $f \u003c \\frac{1}{2} f_s$ 条件下，数值差分的幅频响应是单调递增的，这意味着信号中的高频噪声会被数值差分所放大，很容易导致时域的微分信号淹没在高频噪声之中。 为了说明数值差分对噪声的放大，考察下面的信号：左图橙色曲线为理想的单频信号，蓝色曲线引入了白噪声并将其假设为实际采集到的信号，采样率设置为 $f_s = 200 , \\mathrm{Hz}$ 。右图中蓝色曲线是数值差分的结果，可见微分信号完全淹没在高频噪声之中，单独的数值差分难以直接使用；配合低通滤波后的输出为橙色曲线所示，可以看到微分信号；理想的微分信号如绿色曲线所示。 带噪声的正弦信号及其数值差分 虽然可以使用滤波器将数值差分后放大的高频噪声衰减下去，但是在实际应用，尤其是设计定点化数据时应当注意增益增益分配，以免导致数据溢出。例如可以考虑差分后先进行滤波，再乘以 $\\frac{1}{Ts}$ 系数。当然，滤波器会引入延时，实际使用时应当考虑这一影响；如果只是对采集到的信号进行处理，可以使用非因果的零相位滤波，以避免滤波延时的影响。 ","date":"2021-05-25","objectID":"/diffsignal/:1:0","series":null,"tags":["数字微分","跟踪微分"],"title":"信号的微分","uri":"/diffsignal/#从数值差分聊起"},{"categories":["数字信号处理"],"content":" 从模拟微分中找找灵感既然数值差分存在高频噪声放大的问题，不妨看看模拟微分器是如何实现的，或许能够从中找的一些新的灵感。 模拟微分器从导数的定义出发（假设信号连续且光滑）： $$f'(x) = \\lim_{T \\to 0 } \\frac{f(x+T)-f(x)}{T} = \\lim_{T \\to 0 } \\frac{f(x)-f(x-T)}{T}$$ 可见，除了减法和除法，构造模拟微分器的关键就是产生足够小的延时。考虑延时的 Laplace 变换为 $\\mathrm{e}^{-s T}$ ，则上式对应的传递函数可以写为 $$H_1(s) = \\frac{1}{T} \\left( 1- \\mathrm{e}^{-s T}\\right) \\approx \\frac{1}{T} \\left( 1- \\frac{1}{1+sT}\\right) = \\frac{s}{Ts+1}$$ 上式的近似是取了延时的一阶 Pade 展开，最终的结果具有高通滤波器的形式。因此我们可以这么来看：分子的 $s$ 产生主要的微分效应，而分母的 $Ts+1$ 则用来约束高频增益，使高频噪声不被放大。显然，这种微分器是以牺牲工作带宽为代价的。 反正已经牺牲了工作带宽，有没有可能对高频噪声做进一步的抑制呢？当然是可以的，假设信号的导数也具有连续性，则： $$f'(x) = \\lim_{T_1 \\to 0 } f'(x-T_1) = \\lim_{T_1 \\to 0 } \\lim_{T_2 \\to 0} \\frac{f(x-T_1)-f(x-T_2)}{T_2 - T_1}$$ 同样在一阶 Pade 近似下，得传递函数： $$ \\begin{aligned} H_2(s) \u0026= \\frac{1}{T_2-T_1} \\left( \\mathrm{e}^{-s T_1} - \\mathrm{e}^{-s T_2} \\right) \\\\ \u0026\\approx \\frac{1}{T_2-T_1} \\left( \\frac{1}{T_1 s + 1} - \\frac{1}{T_2 s + 1}\\right) \\\\ \u0026= \\frac{s}{T_1T_2 s^2 + (T_1+T_2)s +1} \\end{aligned} $$ 这是一个带通滤波器！其幅频响应的\"左侧\"构成微分的功能，而\"右侧\"能够高频噪声进行抑制。下图展示了这两种微分器的效果。 两种模拟微分器的微分效果对比 注意 这里在讨论模拟微分器时仅讨论了传递函数的形式，由于具体实现的手段很多，故没有给出示例的电路图。此外，可能有同学会说书本上讲过使用运算放大器和电容构成微分器，它的传递函数是 $-sRC$，调整下增益不就是理想的微分器吗？这里稍作提示：运算放大器是具有增益带宽积的，频率很高时增益不够，不能达到\"虚短\"、“虚断\"的条件，传递函数自然不再是理想微分了。 进一步，考察带通滤波形式微分器如下所示的结构框图： 带通滤波器的基本结构框图 可以这么理解：构造串联积分作为\"被控对象\"，使其输出跟随系统的输入，即 $x_1 = u$；通过理想的状态反馈确保环路稳定，那么第二个状态量 $x_2 = \\dot{x}_1$ 就是输入信号的微分。这实际上就是控制理论中的状态观测器！ ","date":"2021-05-25","objectID":"/diffsignal/:2:0","series":null,"tags":["数字微分","跟踪微分"],"title":"信号的微分","uri":"/diffsignal/#从模拟微分中找找灵感"},{"categories":["数字信号处理"],"content":" 跟踪微分器从模拟微分器中已经学到：利用状态观测器跟踪输入信号，那么各状态量就分别对应输入信号的各阶导数（不再局限于一次微分），因此这种微分器称为跟踪微分器。跟踪微分器的环路稳定性可以通过反馈控制来保证，因此具有以下通用的形式： 跟踪微分器的一般形式 特别地，如果使用 相图与砰砰控制 所讨论的砰砰控制来稳定环路，就构成了韩京清老师所定义的跟踪微分器。下图展示了这种跟踪微分器的微分效果。 跟踪微分器的微分效果 从控制的角度来看，完全可以使用其他控制器以达到对高频噪声更高阶次的抑制，这里就不再过多讨论了。 ","date":"2021-05-25","objectID":"/diffsignal/:3:0","series":null,"tags":["数字微分","跟踪微分"],"title":"信号的微分","uri":"/diffsignal/#跟踪微分器"},{"categories":["数字信号处理"],"content":" 写在最后本文仅介绍了几种常用的微分器及其实现方法，由于各形式下微分器的参数不同，并可以自由设计，故没有将这几种微分器合在一起对比，而且示例的微分器参数也未必是最优的。相关的仿真文件我放在了 GitHub 仓库，有兴趣的小伙伴可以自行取阅。 ","date":"2021-05-25","objectID":"/diffsignal/:4:0","series":null,"tags":["数字微分","跟踪微分"],"title":"信号的微分","uri":"/diffsignal/#写在最后"},{"categories":["数字信号处理"],"content":" 参考文献 韩京清, 自抗扰控制技术: 估计补偿不确定因素的控制技术. 国防工业出版社. 2008. ","date":"2021-05-25","objectID":"/diffsignal/:5:0","series":null,"tags":["数字微分","跟踪微分"],"title":"信号的微分","uri":"/diffsignal/#参考文献"},{"categories":["生命在于折腾"],"content":"尝试过 Debian 系的 deepin、Ubuntu 和它的衍生版 Pop!_OS，都被各种各样的 Bug 劝退。后来尝试了 Arch 系的 Manjaro，唔，这真的是一款非常令人舒适的 Linux 发行版！来跟我一起折腾吧！ ","date":"2021-05-12","objectID":"/manjaro/:0:0","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#"},{"categories":["生命在于折腾"],"content":" 安装系统Manjaro 的系统镜像可以从官网下载，为了提高下载速度，可以从国内镜像站下载，例如我自己常用的 清华大学开源软件镜像站。Manjaro 有 XFCE、KDE、GNOME 三种官方桌面可供选择，而社区提供更多其他桌面环境。这里我个人非常推荐 KDE 版本。 准备一个空U盘制作系统启动盘，Windows 用户可以使用 Rufus 等工具通过用户界面对镜像文件进行烧写，对于 Linux 用户，可以按如下方式使用 dd 命令： bash sudo dd bs=4M if=[/path/to/manjaro.iso] of=/dev/sd[drive letter] status=progress oflag=sync 命令中的 if 和 of 分别代表输入文件（input file）和输出文件（output file），下载位置不同，注意连同中括号替换路径。 注意 [drive letter] 可以使用 sudo fdisk -l 进行查看，应当注意它是 U 盘驱动器的标识符（如 /dev/sdb ），不包括 分区号（如 /dev/sdb1）。 准备好启动盘后，重启电脑，从U盘进入系统，顺着安装引导进行安装即可。 Manjaro 安装界面 ","date":"2021-05-12","objectID":"/manjaro/:1:0","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#安装系统"},{"categories":["生命在于折腾"],"content":" 更换镜像源安装完 Linux 系统后的第一件事莫过于更换镜像源和更新系统，Manjaro 换源非常简单，打开终端运行以下命令： bash sudo pacman-mirrors -i -c China -m rank 在弹出的窗口进行选择即可完成换源。进一步可以使用 vi /etc/pacman.d/mirrorlist 进行确认。然后，运行以下命令更新系统： bash sudo pacman -Syu ","date":"2021-05-12","objectID":"/manjaro/:2:0","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#更换镜像源"},{"categories":["生命在于折腾"],"content":" 安装软件Manjaro 系统包管理的命令是 pacman ，为了使用强大的 AUR （Arch User Repository），可以安装并使用 yay 对软件进行管理： bash sudo pacman -S yay # 安装 yay 此后 sudo pacman 命令可以用 yay 代替了。绝大部分常用软件都可以不加额外配置地使用 yay -S 进行安装，是不是非常方便呢： bash yay -S base-devel # 基本打包工具，yay 安装软件可能用到 yay -S zotero # Zotero yay -S nutstore # 坚果云 yay -S visual-studio-code-bin # VS Code yay -S youdao-dict # 有道词典 yay -S qqmusic # QQ音乐 yay -S vmware-workstation # VM-Ware 虚拟机 yay -S thefuck # 命令输入错误后输入 `fuck` 进行纠错 yay -S mlocate # 文件查找 yay -S obs-studio # OBS Studio yay -S enca # 文件编码转换：enca -L chinese -x utf-8 * yay -S bash-completion # 终端自动补全功能 不确定软件名字的时候，可以使用命令 yay -Ss \u003cpkgname\u003e 进行搜索，或者在 AUR 仓库镜像站 搜索。 Manjaro 自带最新版本 Git ，真不错。下面记录一些需要少许配置的其他软件的安装。 ","date":"2021-05-12","objectID":"/manjaro/:3:0","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#安装软件"},{"categories":["生命在于折腾"],"content":" VimVim 是一个很强的编辑器，几乎所有 Linux 发行版都会内置，但自带的通常不能把文件内容复制到系统剪切板，为此可以安装 gVim： bash yay -S gvim 可以通过 vim ~/.vimrc 编辑文件对 Vim 进行配置，例如： text syntax on set number set autoindent set smartindent set tabstop=4 set expandtab set shiftwidth=4 set fileencodings=utf8 nnoremap j gj nnoremap k gk 最后两行是重新映射了 Vim 的换行功能，相关的使用说明可以参考 Vim 简介。 ","date":"2021-05-12","objectID":"/manjaro/:3:1","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#vim"},{"categories":["生命在于折腾"],"content":" 中文输入法首先安装 fcitx5 框架，唔……老命令换新名： bash yay -S fcitx5-im fcitx5-chinese-addons 使用 vim ~/.pam_environment 新建文件，添加以下内容以设置 fcitx5 的环境变量： text INPUT_METHOD DEFAULT=fcitx5 GTK_IM_MODULE DEFAULT=fcitx5 QT_IM_MODULE DEFAULT=fcitx5 XMODIFIERS DEFAULT=\\@im=fcitx5 然后就可以安装具体的输入法了，例如 Rime 可以使用如下命令进行安装： bash yay -S fcitx5-rime 安装完成之后需要注销用户重新登录系统，然后在开始菜单找到并打开 Fcitx5 Configuration ，点击 “添加输入法” 按钮，搜索并选择 Rime 即可。Rime 是一款可高度自定义的输入法，单是它的配置就可以写很多教程，这里我不想写的太多。不愿意折腾的朋友当然可以使用 fcitx5 自带的拼音输入法，还能安装 fcitx5-material-color 更换皮肤哟～ ","date":"2021-05-12","objectID":"/manjaro/:3:2","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#中文输入法"},{"categories":["生命在于折腾"],"content":" 微信 QQ微信和 QQ 无疑是基于 Wine 技术的，通常在 Ubuntu 等 Debian 系发行版下要经过繁琐的设置，但是在 Manjaro 下安装十分简单： bash yay -S deepin-wine-wechat # wine 微信 yay -S deepin-wine-qq # wine QQ 由于 Wine 本身的问题，使用时可能会出现一些问题，常见的问题和解决方案有： bash ## 微信中文乱码 yay -S wqy-zenhei wqy-microhei # 安装文泉译黑体 ## 高分辨率屏幕下，界面字体过小 /opt/apps/com.qq.weixin.deepin/files/run.sh winecfg 最后调整界面字体时， 路径 */com.qq.weixin.deepin/* 对应的是微信，QQ 应当做相应替换。运行后会弹出设置窗口，在 “显示” 选项卡中调整 “屏幕分辨率” 的 DPI 即可。将默认值 96 改为 144 即可实现 150% 的缩放效果。 详细的安装说明及问题可以参考 ArchLinux 微信 的说明文档。 ","date":"2021-05-12","objectID":"/manjaro/:3:3","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#微信-qq"},{"categories":["生命在于折腾"],"content":" MATLAB从官网下载的 .zip 压缩包如果直接解压可能导致无法打开安装文件，使用下面的命令进行解压： bash unzip -X -K matlab_R2021a_glnxa64.zip -d installMATLAB/ 从终端进入解压出来的 installMATLAB 文件夹，使用 ./install 调用安装程序即可根据用户界面按顺序进行安装。 为了将 MATLAB 添加到开始菜单，使用 sudo vim /usr/share/applications/MATLAB.desktop 创建文件，并写入以下内容（注意安装路径） text [Desktop Entry] Type=Application Name=MATLAB GenericName=MATLAB R2021a Comment=MATLAB: The Language of Technical Computing Exec=sh /home/xiaocy/MATLAB/R2021a/bin/matlab -desktop Icon=/home/xiaocy/MATLAB/R2021a/toolbox/nnet/nnresource/icons/matlab.png StartupNotify=true Terminal=false Categories=Development;MATLAB; KDE 桌面环境下，MATLAB 中右键 “Open Current Folder in File Manager” 可能不工作，可按 以下步骤 进行设置： 在终端使用 locate libQt5Core.so.5 确认库的位置； 在 MATLAB 中新建启动脚本： edit(fullfile(userpath,'startup.m')) ； 在启动脚本中添加以下内容，其中 /usr/lib/ 是第一步搜索到的路径： MATLAB setenv('LD_LIBRARY_PATH', ['/usr/lib/:',getenv('LD_LIBRARY_PATH')]); 对于高分辨率屏幕，MATLAB 界面的字体显得略小，可在 MATLAB 命令行中进行调整： MATLAB s = settings;s.matlab.desktop.DisplayScaleFactor s.matlab.desktop.DisplayScaleFactor.PersonalValue = 1.5 对于双显卡电脑（一般是笔记本电脑），绘图时可能出现无法使用独立显卡进行渲染的情况，通常给出 “MATLAB禁用了一些高级图形功能” 的警告或者直接抛出 OpenGL 相关的错误。为此，可在命令行使用 以下命令 启动 MATLAB： bash export MESA_LOADER_DRIVER_OVERRIDE=i965; matlab 进一步，若想保持这种设置，可将快捷方式的设置改为： text Exec=env MESA_LOADER_DRIVER_OVERRIDE=i965 /home/xiaocy/MATLAB/R2021a/bin/matlab -desktop ","date":"2021-05-12","objectID":"/manjaro/:3:4","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#matlab"},{"categories":["生命在于折腾"],"content":" TeX Live下载 TeX Live 的镜像文件，挂载后使用 sudo ./install-tl 即可安装。安装完成后需要在 ~/.bashrc 中设置路径： text export MANPATH=/usr/local/texlive/2021/texmf-dist/doc/man:${MANPATH} export INFOPATH=/usr/local/texlive/2021/texmf-dist/doc/info:${INFOPATH} export PATH=/usr/local/texlive/2021/bin/x86_64-linux:${PATH} 同样注意安装路径可能有所不同。最后运行 source .bashrc 刷新即可。 ","date":"2021-05-12","objectID":"/manjaro/:3:5","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#tex-live"},{"categories":["生命在于折腾"],"content":" InkscapeInkscape 是我最喜欢的绘图软件，它的安装非常简单： bash yay -S inkscape 除此，我还喜欢为其安装 TexText 扩展以在绘图时使用 LaTeX 。虽然该扩展可以简单地使用 yay -S textext 进行安装，但这种方法偶尔会找不到 LaTeX 路径，因此建议从 GitHub release page 下载，并在安装时手动指定路径： bash python setup.py --pdflatex-executable=$(which pdflatex) --xelatex-executable=$(which xelatex) --lualatex-executable=$(which lualatex) 可以编辑 ~/.config/inkscape/extensions/textext/default_packages.tex 对 TexText 宏包进行设置。一般我会使用以下宏包： LaTeX \\usepackage{metalogo} \\usepackage[table]{xcolor} \\usepackage{amsmath} \\usepackage{amssymb} \\usepackage{bm} \\usepackage{newtxmath} \\usepackage{siunitx} \\usepackage[UTF8]{ctex} ","date":"2021-05-12","objectID":"/manjaro/:3:6","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#inkscape"},{"categories":["生命在于折腾"],"content":" FlameshotLinux 下对标 Snipaste 的开源截图软件，安装很容易： text yay -S flameshot 我喜欢给这个截图工具设置全局快捷键，可以打开系统设置 → 快捷键 → 自定义快捷键 → 编辑 → 新建 → 全局快捷键 → 命令/URL。快捷键可以自己定义，绑定的命令应当设置为 flameshot gui 。 ","date":"2021-05-12","objectID":"/manjaro/:3:7","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#flameshot"},{"categories":["生命在于折腾"],"content":" 系统设置系统设置因个人喜好可以随便配置，这也得益于 KDE 的灵活性。这里简要记录一些常用的设置。 ","date":"2021-05-12","objectID":"/manjaro/:4:0","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#系统设置"},{"categories":["生命在于折腾"],"content":" 高分辨率屏幕缩放Manjaro 对高分辨率屏幕的支持很好，只需要打开系统设置 → （硬件）显示监视器 → 显示设置 → 全局缩放。将其设置为 150% 即可（取决于个人喜好，也可 125%）。 ","date":"2021-05-12","objectID":"/manjaro/:4:1","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#高分辨率屏幕缩放"},{"categories":["生命在于折腾"],"content":" Fn 键设置如果键盘的 Fn 键不可用，或者默认处于开启状态，希望默认关闭，可以在参考 Arch Wiki，在管理员身份下运行以下命令： bash echo 2 \u003e\u003e /sys/module/hid_apple/parameters/fnmode 如果想要这个设置永久生效，可以在 /etc/modprobe.d/hid_apple.conf 文件中添加以下内容： text options hid_apple fnmode=2 ","date":"2021-05-12","objectID":"/manjaro/:4:2","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#fn-键设置"},{"categories":["生命在于折腾"],"content":" GRUB 基本设置设置启动选项，只需要 sudo vim /etc/default/grub 编辑设置文件即可，我只动过以下两条： text GRUB_TIMEOUT=0 ## 启动等待时间 GRUB_TIMEOUT_STYLE=hidden ## 样式：hidden 或 menu 改动之后运行 sudo update-grub 刷新。 危险 GRUB 是很关键的系统文件，我曾经折腾 Ubuntu 时瞎改 GRUB 导致系统无法启动，新手改一下启动时间和样式就好，其他最好不乱动。 ","date":"2021-05-12","objectID":"/manjaro/:4:3","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#grub-基本设置"},{"categories":["生命在于折腾"],"content":" Zsh 忽略大小写在 .zshrc 中加入以下配置： bash # case insensitive path-completion zstyle ':completion:*' matcher-list 'm:{[:lower:][:upper:]}={[:upper:][:lower:]}' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' 'm:{[:lower:][:upper:]}={[:upper:][:lower:]} l:|=* r:|=*' ","date":"2021-05-12","objectID":"/manjaro/:4:4","series":null,"tags":["Manjaro","Linux","操作系统"],"title":"Manjaro 系统安装","uri":"/manjaro/#zsh-忽略大小写"},{"categories":["生命在于折腾"],"content":"reStructuredText 是一个不同于 Markdown 的文本标记语言，通常结合 Sphinx 构建静态网站，特别适合帮助类文档的编写。这篇文章简要介绍其基本用法。 ","date":"2021-04-13","objectID":"/restructuredtext/:0:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#"},{"categories":["生命在于折腾"],"content":" 章节标题在标题的下一行用某一符号填充，且长度不得小于标题文字长度。标题上一行可以填充相同的内容，但不是必须的，例如下面两种方式等价： reStructuredText ======================================== 甄士隐梦幻识通灵　贾雨村风尘怀闺秀 ======================================== 甄士隐梦幻识通灵　贾雨村风尘怀闺秀 ======================================== 应当注意，如果同时使用上面两种方式，即使使用的是同一种符号，也会被认为是不同级别的标题。标题的级别由符号使用的先后顺序决定。 标题装饰符相对比较随意，可以参考下面 Python 风格指南 的建议： ## 且在标题上下两行均填充，为部（Parts）标题； * 且在标题上下两行均填充，为章（Chapters）标题； = 且在标题下填充，为节（Sections）标题； - 且在标题下填充，为子节（Subsections）标题； ^ 且在标题下填充，为二级子节（Subsubections）标题； \" 且在标题下填充，为段落（Paragraphs）标题。 ","date":"2021-04-13","objectID":"/restructuredtext/:1:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#章节标题"},{"categories":["生命在于折腾"],"content":" 分割线使用与标题装饰符号相同的符号集，连续使用4个以上，且上下都是空行，来插入分隔符。应当注意一下事项： 分隔线与上下内容之间需要有空白行； 分隔线不能紧贴在大纲标题之前或之后，也不能放在文档最开头； 两个分隔线不能紧贴，必须有除了空白行之外的内容。 ","date":"2021-04-13","objectID":"/restructuredtext/:2:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#分割线"},{"categories":["生命在于折腾"],"content":" 列表列表第一项之前和最后一项之后都要有空行，编号列表和非编号列表分别用 #. 和 - 后接一个空格引出，代码示例如下： reStructuredText 这里是一点正文。 #. 有序列表的第一项要和正文之间由空行分割； #. 这是自动编号的有序列表的第二项。 - 这是一个无编号列表的例子； - 注意列表起始符与列表正文之间的空格； - 列表的嵌套只需要缩进即可。 ","date":"2021-04-13","objectID":"/restructuredtext/:3:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#列表"},{"categories":["生命在于折腾"],"content":" 表格表格分为简单表、网格表、CSV表，我直接复制了参考资料： ","date":"2021-04-13","objectID":"/restructuredtext/:4:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#表格"},{"categories":["生命在于折腾"],"content":" 简单表 行分隔：以等号 = 标记表格的顶线与底线。 每列中的行分隔符在竖直方向上必须对齐。 如果有表头，表头与表身也用 = 分隔。 在简单表中，不允许跨行。 列分隔：以空格来分隔列。 每列的文本左侧对齐到该列行分隔符的左侧。 如果需要，表中最右侧的列文本的右侧可以溢出该列的行分隔符右侧。 简单表允许跨列。用横线 - 来标记跨列的长度。跨列符必须与某一列的行分隔符对齐。 跨列时的列间空格用 - 替代。 空白行：表内任一行内部允许文本中存在的空白行。表行之间的空白行会被忽略。 空白表格：用反斜线 \\ 标记空白表格。 下面是一个简单表的例子: reStructuredText ======= ======= PID Controller ------------------ Items Value ======= ======= P 15 I 20 D 7 \\ Tested ======= ======= ","date":"2021-04-13","objectID":"/restructuredtext/:4:1","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#简单表"},{"categories":["生命在于折腾"],"content":" 网格表网格表的使用较为复杂但是更为灵活： 表线必须完整地围住表格文本。 行分隔线一律用横线 - 书写，除了表头分割线用等号 = 。 列分隔线一律用竖线 | 书写。 行、列分隔线的交叉点用加号 + 标记。 给出一个网格表的例子： reStructuredText .. table:: 网格表示例 :align: center :width: 40% +---------------------------+ | PID Paramters | +======+====================+ | Item | Degree of Freedoms | | +------+------+------+ | | X | Y | Z | +------+------+------+------+ | P | 1.0 | 2.0 | 3.0 | +------+------+------+------+ | I | 3.0 | 1.0 | 5.0 | +------+------+------+------+ | D | 2.0 | 5.0 | 7.0 | +------+------+------+------+ 从这个例子可以看出，网格表可以放在 table 指令（Directive: table）中，并可以提供对齐、宽度等约束。指令的一般用法为： reStructuredText .. directive:: :option1: option1 :option2: option2 content table 提供以下选项： align — 对齐方式： left ， center ， right ； widths — 各列的宽度： auto ， grid ，逗号或空格分割的整数序列； width — 整个列表的宽度，给定长度或页面宽度的百分比。 当中英文混合时，网格表容易出现文字对不齐的情况，可以使用中英文等宽字体避免这种显示问题，例如可以使用 Iosevka 字体。 ","date":"2021-04-13","objectID":"/restructuredtext/:4:2","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#网格表"},{"categories":["生命在于折腾"],"content":" CSV表 表宽 :width: LENGTH/PERCENT 表格的总宽度，以长度值或者百分数来指定 列宽 :widths: INT,INT,... 每列的相对宽度（相对于100）可以由整数 INT 指定。默认各列等宽。 表头：有两种表示方法。 表头行 :header-rows: INT 指定表格中的前 INT 行为表头。 表头文本 :header: TEXT,TEXT,... 直接输入每一列表头的文本。它也可以与 header-rows 选项同时使用，但必须放在 header-rows 之前。 列头： :stub-columns: INT 将前 INT 列作为列头。 对齐： :align: ALIGN 用 left, center 或者 right 来指定整个表如何向外部环境对齐。 外部CSV文件： 用 :file: FILEPATH 引用本地文件或者 :url: URL 引用网络文件。 reStructuredText .. csv-table:: CSV Table Caption :header: \"First Name\", \"Age\", \"Gender\" :widths: 30, 20, 20 :width: 60% :align: center \"Tom\", 3, Male \"Dick\", 5 \"Harry\",, Male ","date":"2021-04-13","objectID":"/restructuredtext/:4:3","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#csv表"},{"categories":["生命在于折腾"],"content":" 图片指令 image （Directive: image）和 figure （Directive: figure）都可以用来插图，但前者不能插入图名，因此这里用一个例子介绍后者的用法。 reStructuredText .. figure:: figures/kasugano.png :alt: 当图片无法显示时候用于代替的文本 :width: 80% :align: center :target: https://github.com/iChunyu 与 ``image`` 相比， ``figure`` 在这里可以插入标题甚至段落。 ","date":"2021-04-13","objectID":"/restructuredtext/:5:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#图片"},{"categories":["生命在于折腾"],"content":" 超链接两种超链接使用方法如下，一种是直接使用，一种是先定义别名，再给出链接。后者适合正文多次使用该超链接时使用。 reStructuredText `bilibili \u003chttps://www.bilibili.com/\u003e`_ 干杯！ `Git`_ 是一个版本管理软件， 它的官网为： `Git`_ 。 .. _Git: https://git-scm.com ","date":"2021-04-13","objectID":"/restructuredtext/:6:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#超链接"},{"categories":["生命在于折腾"],"content":" 交叉引用在需要引用的位置的空一行使用 .. _some-label: 打上标签，然后可以在文中任意位置使用 :ref:`some-label` 进行引用。 例如： reStructuredText .. _corss-ref: 交叉引用 ----------------------------------------------- （正文略） 交叉引用的使用方法可以查看： :ref:`corss-ref` 。 除正文交叉引用，还常用到项目内文件的交叉引用，例如 :doc:`learn_git` 可以应用项目内的其他文档 。 ","date":"2021-04-13","objectID":"/restructuredtext/:7:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#交叉引用"},{"categories":["生命在于折腾"],"content":" 脚注脚注的在正文中用 [##fn]_ 标记，一般在文末通过 .. [##fn] 文本 给出脚注内容。示例如下： reStructuredText 这是一个脚注 [##footnotemark]_ 。 .. [##footnotemark] 这是脚注的内容。 ","date":"2021-04-13","objectID":"/restructuredtext/:8:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#脚注"},{"categories":["生命在于折腾"],"content":" 代码正文内代码用一对反引号即可，例如 code ，对于代码块，可以使用 code-block 指令，例如： reStructuredText .. code-block:: python import numpy as np import matplot.pyplot as plt ","date":"2021-04-13","objectID":"/restructuredtext/:9:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#代码"},{"categories":["生命在于折腾"],"content":" 数学公式类似代码，行内公式可以使用 :math:`\\sin\\alpha` 这种形式，单行或多行公式可以在 :math: 指令中使用 $\\LaTeX$ 扩展。例如： text .. math:: \\left\\{ \\begin{aligned} \\sin\\left( \\alpha+\\beta \\right) \u0026= \\sin\\alpha \\cos\\beta + \\cos\\alpha \\sin\\beta \\\\ \\cos\\left( \\alpha+\\beta \\right) \u0026= \\cos\\alpha \\cos\\beta - \\sin\\alpha \\sin\\beta \\end{aligned} \\right. ","date":"2021-04-13","objectID":"/restructuredtext/:10:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#数学公式"},{"categories":["生命在于折腾"],"content":" 警示标记警示标记是一类指令，可以生成特别的消息框，使用方法如下： text .. warning:: 这是一个警告标记。 它将产生这种效果： 警告 这是一个警告标记。 可以使用的标记有以下 9 种： attention caution error hint important note tip warning ","date":"2021-04-13","objectID":"/restructuredtext/:11:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#警示标记"},{"categories":["生命在于折腾"],"content":" 参考文献 wklchris. reStructuredText 简介. ","date":"2021-04-13","objectID":"/restructuredtext/:12:0","series":null,"tags":["reStructuredText","文本标记语言"],"title":"reStructuredText 简介","uri":"/restructuredtext/#参考文献"},{"categories":["生命在于折腾"],"content":"Sphinx 是一个静态网页生成工具，可以将 reStructuredText 转化为静态网站，特别适合教程、说明等文档的编写。本文介绍如何基于此部署自己的博客。 ","date":"2021-04-09","objectID":"/sphinx/:0:0","series":null,"tags":["Sphinx","博客"],"title":"Sphinx 搭建博客","uri":"/sphinx/#"},{"categories":["生命在于折腾"],"content":" 概述静态网页可以由 Sphinx 编译而成，源代码托管于 GitHub 仓库，生成的静态网站部署在 Read the Docs。以这种方式建立网站的主要步骤为： 安装并初始化 Sphinx 项目； 在 GitHub 建立文档源码托管仓库； 从 Read the Docs 导入 Sphinx 项目。 ","date":"2021-04-09","objectID":"/sphinx/:1:0","series":null,"tags":["Sphinx","博客"],"title":"Sphinx 搭建博客","uri":"/sphinx/#概述"},{"categories":["生命在于折腾"],"content":" Sphinx 的安装与配置在 Linux 系统上，可以通过以下命令安装 Sphinx: bash pip install sphinx sphinx_rtd_theme 其中 sphinx 是主程序，sphinx_rtd_theme 是很常用的一个主题，更多主题可以在 Sphinx Themes Gallery 查看。 新建文件夹用于存放 Sphinx 文档的源码。在该文件夹打开终端后，运行 sphinx-quickstart 以快速创建 Sphinx 工程。依次会出现以下提示： \u003e Separate source and build directories (y/n) [n]: 是否将源码和编译后的文件分开？为了更好地管理文件，最好将它们分开，输入 y 以确认； \u003e Project name: 根据自己的爱好给项目起个名字吧，我的嘛，就叫\"某春雨的后花园\"； \u003e Author name(s): 作者的名字，喜欢用真名或者笔名都可以，我就叫大春雨吧； \u003e Project release []: 项目的发行版本？直接回车跳过吧！ \u003e Project language [en]: 项目的语言默认是英文，而我想使用简体中文，于是输入 zh_CN ，回车，搞定！ 项目初始化之后，文件夹将具有以下结构： text . ├── build/ ├── make.bat ├── Makefile └── source/ ├── conf.py ├── index.rst ├── _static/ └── _templates/ 初始话的文件夹为空，这时只需要在该项目的根目录下运行 make html 就可以生成最基本的静态页面样板，生成的结果可以在 build/html/index.html 中查看。 默认的主题似乎不是很好看的样子，那我们就在 source/conf.py 中进行修改吧，大概在第 54 行，改！ python html_theme = 'sphinx_rtd_theme' 至此，基本的设置就完成了。 ","date":"2021-04-09","objectID":"/sphinx/:2:0","series":null,"tags":["Sphinx","博客"],"title":"Sphinx 搭建博客","uri":"/sphinx/#sphinx-的安装与配置"},{"categories":["生命在于折腾"],"content":" GitHub 源码托管代码托管涉及到 Git 的使用，基本规则可以参考 Git 版本控制 。这里我们只需要在 GitHub 建立仓库，例如 helps 。然后在 Sphinx 项目目录下运行以下命令即可。 bash git init echo \"build/\" \u003e .gitignore git add . git commit -m 'Initial commit' git remote add origin git@github.com:iChunyu/helps.git git push -u origin main 上述各条命令的功能简述如下： 初始化 Git 仓库； 设置 Git 忽略 build/ 文件夹； 将所有文件保存到暂存区； 将暂存区文件提交到 Git 仓库； 添加远程分支，注意自己远程分支的地址； 将当前分支推送到远程分支。 ","date":"2021-04-09","objectID":"/sphinx/:3:0","series":null,"tags":["Sphinx","博客"],"title":"Sphinx 搭建博客","uri":"/sphinx/#github-源码托管"},{"categories":["生命在于折腾"],"content":" Read the Docs 网站部署注册并登录 Read the Docs ，与发现有个 Import a Project 按钮，点之。根据提示与 GitHub 绑定，然后会刷新出仓库列表，选择保存 Sphinx 项目的仓库，然后根据提示进行设置，完成导入即可。 在 Read the Docs 导入项目之后，会在相应的 GitHub 仓库部署一个钩子。这个钩子的功能就是检测该仓库的提交，每当有新的提交，Read the Docs 将会根据最新的仓库重新编译 Sphinx 项目，并部署在项目所设置的网站上。 这样以来就基本配置好了，剩下的只要依据 reStructuredText 的规则编写文档即可。当然，Sphinx 也可以通过插件提供 Markdown 支持。reStructuredText 具有很同意的风格和完善的扩展，但使用稍微复杂一点点；而 Markdown 虽然简单，却存在很多“方言”，不同的编辑器会有不同的特性。各位可以自行取舍。 ","date":"2021-04-09","objectID":"/sphinx/:4:0","series":null,"tags":["Sphinx","博客"],"title":"Sphinx 搭建博客","uri":"/sphinx/#read-the-docs-网站部署"},{"categories":["生命在于折腾"],"content":" GitHub Pages 网站部署生成的静态网站还可以直接由 GitHub Pages 进行托管，但需要遵循相关规则： 生成的静态网站所有内容都要放置在根目录 docs/ 文件夹下：cp -r build/html/* docs/； 在根目录和 docs/ 下添加 .nojekyll 文件以取消 Jekyll 支持： tuoch .nojekyll； 在 GitHub 仓库设置的 Pages 选项中修改文件夹为 docs/ 。 ","date":"2021-04-09","objectID":"/sphinx/:5:0","series":null,"tags":["Sphinx","博客"],"title":"Sphinx 搭建博客","uri":"/sphinx/#github-pages-网站部署"},{"categories":["LaTeX"],"content":"写文档的时候会在必要位置插入脚注进行补充说明，也会引用已经出现的图、表、章节等，即交叉引用。对于科技论文写作，会进一步涉及到参考文献引用；少数情况下，还会使用到外部超链接。被引对象的编号问题无疑是手动引用的繁琐之处，这篇文章向大家展示如何在 $\\LaTeX$ 中实现自动化引用。 ","date":"2020-12-24","objectID":"/latex05-cite/:0:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（5）：自动化引用","uri":"/latex05-cite/#"},{"categories":["LaTeX"],"content":" 脚注在 $\\LaTeX$ 中可以轻松使用 \\footnote{\u003ctext\u003e} 命令快速插入脚注，也可以用 \\footnotemark 打上标记，在其后相应的位置使用 \\footnotetext{\u003ctext\u003e} 给出具体脚注信息。这两种方法在正文中使用时并无二异，但是如果在表格等环境中使用脚注时，\\footnote{\u003ctext\u003e} 通常会失效，这时应当使用 \\footnotemark 打上标记，然后在环境外使用 \\footnotetext{\u003ctext\u003e} 给出具体脚注内容。 注意 为了详细展示命令的使用方法，这里用尖括号和被尖括号包围的文字表示示例，若无特殊说明，实际使用命令时不带尖括号。 \\footnotemark 和 \\footnotetext{\u003ctext\u003e} 成对出现，并且能够自定义编号，这通过使用中括号给出的可选参数进行设置，例如下面的例子： tex 这是第一个脚注 \\footnotemark[1]，这是第二个 \\footnotemark[2]。 \\footnotetext[1]{脚注1的内容} \\footnotetext[2]{脚注1的内容} 脚注默认的样式是阿拉伯数字角标，而对于中文文档的习惯，通常需要用带圆圈的数字且每页重新计数，这可以在导言区进行如下设置： tex % 优化脚注设置 \\usepackage[perpage]{footmisc} % 每页重新计数 \\usepackage{pifont} % 设置带圆圈的数字 \\renewcommand{\\thefootnote}{\\ding{\\numexpr171+\\value{footnote}}} ","date":"2020-12-24","objectID":"/latex05-cite/:1:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（5）：自动化引用","uri":"/latex05-cite/#脚注"},{"categories":["LaTeX"],"content":" 超链接超链接的使用相对容易，只需要导入 hyperref 宏包即可，配合 \\href{\u003clink\u003e}{\u003ctext\u003e} 命令使用即可。例如我想产生一个像这样指向 我的博客 的超链接，只需要像这样编写文档即可： tex 像这样就可以产生一个指向 \\href{https://ichunyu.github.io/}{我的博客} 的超链接。 导入 hyperref 宏包的另一个好处就是生成的文档会根据章节自动生成标签链接，方便 PDF 文档的导航。 默认情况下，不同类型的超链接将以不同颜色的方框将链接内容包围，即使这个方框在打印的时候不会出现，依然导致电子文档阅读时不够美观。所以我自己在使用的时候通常会在调用宏包后增加以下设置，将超链接的方框隐藏，使用带颜色的字来表示。 tex \\hypersetup{hidelinks} % 隐藏超链接的方框 \\hypersetup{colorlinks = true} % 使用颜色字体表示超链接 当然，如果不喜欢默认的颜色，也可以进行设置，这就不多说了。 ","date":"2020-12-24","objectID":"/latex05-cite/:2:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（5）：自动化引用","uri":"/latex05-cite/#超链接"},{"categories":["LaTeX"],"content":" 交叉引用交叉引用的一般思路是在适当的位置使用 \\label{\u003clabel\u003e} 插入标签，然后在需要引用的地方使用 \\ref{\u003clabel\u003e} 引用其编号，或者也可以使用 \\pageref{\u003clabel\u003e} 引用对象所在的页码。这就好比 LOL 里边先插眼后 TP 一样。下面给出一些可供参考的标签插入： tex \\section{自动化交叉引用} \\label{sec:autocite} % 章节标签 \\begin{figure}[!htb] \\centering \\includegraphics[width=0.8\\textwidth]{demo-figure.pdf} \\caption{figure name} \\label{fig:demo} \\end{figure} % 图片标签 \\begin{table}[!htb] \\centering \\caption{table name} \\label{tab:demo} % 表格标签 \\begin{tabular} \u003c...\u003e \\end{tabular} \\end{table} \\begin{equation} \\sin 2x = 2 \\sin x \\cos x \\label{tab:demo} % 公式标签 \\end{equation} 在引用编号的时候，对于图、表、章节通常可以直接引用，而公式编号通常用括号包围。为此，AMS 数学红包提供了 \\eqref{\u003clabel\u003e} 命令在引用公式是为编号加上括号。此外，以英文引用表格为例，“Tab” 和数字之间会有一个空格，且换行不能在 “Tab” 和数字之间打断，因此需要用 ~ 产生不可打断的空格，完整的引用示例应当像这样： Tab~\\ref{tab:demo}。 为了使引用更加简单，推荐使用 cleveref 宏包提供的 \\cref{\u003clabel\u003e}，它会根据计数器类型自动添加 “Tab”、“Fig” 等前缀，对于公式也能自动添加括号，使用非常地方便。由于该宏包依赖于 hyperref ，因此建议在导言区最后引入。同时该宏包提供以下选项： capitalise ：宏包默认前缀小写，导入该选项后前缀首字母大写； nameinlink ：一般交叉引用的超链接仅为编号，导入该选项后名字也在超链接范围内； noabbrev ：宏包默认采用缩写，导入该选项后将变为全称。 实际上 cleveref 还提供了 \\Cref{\u003clabel\u003e} 命令，当需要在句子的开头引用时应当使用该命令以确保首字母大写，其他功能与 \\cref{\u003clabel\u003e} 一致。 如果想自定义 \\cref{\u003clabel\u003e} 的前缀，可以使用 \\crefname{\u003ctype\u003e}{\u003csingular\u003e}{\u003cplural\u003e} 进行定义，三个参数分别是计数器类型、单数形式前缀、复数形式前缀。进一步，还可以使用 \\crefformat{\u003ctype\u003e}{\u003cformat\u003e} 对格式进行详细修改，其中 \u003cformat\u003e 应当包括 #1 、 #2 、 #3 三个输入参数，它们分别是计数器的计数和编号左右的符号（如数学编号的括号），通常可以不管。例如我自己用以下设置对 \\cref{\u003clabel\u003e} 进行汉化： tex \\crefname{equation}{式}{式} \\crefname{table}{表}{表} \\crefname{figure}{图}{图} \\crefformat{section}{\\!第~#2#1#3~节\\!} % 使用 \\! 取消命令前后的空格 \\crefformat{subsection}{\\!第~#2#1#3~小节\\!} ","date":"2020-12-24","objectID":"/latex05-cite/:3:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（5）：自动化引用","uri":"/latex05-cite/#交叉引用"},{"categories":["LaTeX"],"content":" 文献引用以前使用 Word 的时候最头疼的就是参考文献引用及其格式设置，而对于 $\\LaTeX$ 而言，这是十分简单的工作。对于投期刊文章的小伙伴，一般期刊会给 $\\LaTeX$ 模板并内置了参考文献样式；对于普通中文论文，一般需要满足 GB/T 7714—2015 《信息与文献 参考文献著录规则》，而 gbt7714 宏包为此提供了极大的便利。 参考文献的引用可以分为以下三步 导言区导入 gbt7714 宏包并使用 \\bibliographystyle{gbt7714-numerical} 设置为顺序编码制（也可以设置为 gbt7714-author-year ）； 将参考文献导出为 .bib 文件，并在正文中使用 \\cite{\u003ccitekey\u003e 的形式引用； 在需要插入参考文献列表的地方使用 \\bibliography{\u003cbibfilename\u003e} 即可。 这里再稍微啰嗦一下文献的 .bib 文件，这一般可以通过文献管理软件导出，也可以从图书馆等文献查阅的网站导出。单个文件可以包含多个题注，任意题注具有类似以下的信息： tex @book{canutoSpacecraftDynamicsControl2018, title = {Spacecraft Dynamics and Control: The Embedded Model Control Approach}, author = {Canuto, Enrico and Novara, Carlo and Carlucci, Donato and Montenegro, Carlos Perez and Massotti, Luca}, year = {2018}, month = mar, publisher = {Butterworth-Heinemann}, isbn = {978-0-08-100700-6}, language = {en} } 这个文件通常都是导出的，基本不需要自己手动编写，而内容基本也可以顾名思义。引用该文献需要用到的 citekey 就是第一行花括号右侧的字符串，本例就是canutoSpacecraftDynamicsControl2018 。 ","date":"2020-12-24","objectID":"/latex05-cite/:4:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（5）：自动化引用","uri":"/latex05-cite/#文献引用"},{"categories":["LaTeX"],"content":"对于理工科类的报告或论文，除了图表以外，还经常使用到各种公式。 $\\LaTeX$ 对数学公式提供了非常好的支持，本文重点对几种常用的数学环境进行介绍。 ","date":"2020-12-05","objectID":"/latex04-math/:0:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（4）：数学公式","uri":"/latex04-math/#"},{"categories":["LaTeX"],"content":" 数学模式简介与一般的正文不同，数学会涉及到大量的符号，且对字体、间距有明确的要求。因此需要使用数学模式。$\\TeX$ 有两种数学模式：行内（inline）模式和显示（display）模式。前者一般与正文交叉，出现在正文之中，例如这个公式 $\\sin 2x=2\\sin x \\cos x$；反之常用显示模式在单独一行中以合适的间距显示出来，如下式所示 $$ \\begin{aligned} \\cos 2x \u0026= \\cos^2x - \\sin^2 x \\\\ \u0026= 2\\cos^2x - 1 \\\\ \u0026= 1-2\\sin^2 x \\end{aligned} $$ 行内公式的使用相对简单，只需要用 $ 将公式括起来即可，例如上面示例中的代码为： tex `\\sin 2x = 2\\sin x \\cos x$` 看到这些 $\\LaTeX$ 的数学公式代码请不要慌张，因为这一般不是关注的重点，有很多软件可以辅助生成，例如 Mathtype、Mathpix Snip。不过，我自己偶尔会用一些在线的代码生成工具，友情推荐下 妈叔在线公式编辑器。 对于显示模式，常采用不同的数学环境，下面就常用的一些进行介绍。 注意 数学公式的排版通常离不开 AMS 宏包，本文已在导言区使用宏包：amsmath 和 amssymb。 ","date":"2020-12-05","objectID":"/latex04-math/:1:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（4）：数学公式","uri":"/latex04-math/#数学模式简介"},{"categories":["LaTeX"],"content":" 常用数学环境作为一个初步的教程，本文不打算对 $\\LaTeX$ 的博大精深展开太多介绍，仅对下面列举的常用环境进行介绍。 环境 简单说明 euqation 单行公式居中显示 gather, gathered 多行公式居中显示 align, aligned 多行公式整体居中，自定义对齐位置 equation 环境提供了单行公式的展示，更一般地常用 \\[ 和 \\] 对进行简化，例如 tex \\begin{equation} \\cos 2x \u0026= \\cos^2x - \\sin^2 x \\end{equation} 也等价于 tex \\[ \\cos 2x \u0026= \\cos^2x - \\sin^2 x \\] 该环境默认给公式进行编号，若要取消编号，可使用 equation* 环境，或者在不需要编号的公式后加上 \\notag 命令。此外，默认的编号都是从 $1$ 开始计数，如果需要带上章节号，可以在导言区进行如下设置： tex % 导言区，设置公式编号包含节编号 \\numberwithin{equation}{section} equation 环境只能展示单行公式，为了展示多行公式，可采用 gather 环境，并用 \\\\ 进行换行，例如 tex \\begin{gather} \\cos 2x = \\cos^2x - \\sin^2 x \\\\ = 2\\cos^2x - 1 \\\\ = 1-2\\sin^2 x \\end{gather} 这种排版存在的第一个问题是：整个公式希望它共用一个编号，但它每一行都有一个编号。为此，可以嵌套 gathered 环境，将整个公式组合成“块”，作为一个整体进行排版。如： tex \\begin{equation} \\begin{gathered} \\cos 2x = \\cos^2x - \\sin^2 x \\\\ = 2\\cos^2x - 1 \\\\ = 1-2\\sin^2 x \\end{gathered} \\end{equation} 注意到，gathered 环境仅用于将公式组合成块，它的外部通常还需要嵌套其他的环境。由于单个块可以看作单行公式，所以可以在最外层使用 equation 环境。 同样，如果不希望 gather 产生任何编号，只要加上星号改为 gather* 环境即可。 gather 的第二个问题是：多行公式的每行都是居中对齐的，而对于上面例子的推导而言，显然更好的方式是在等号处对齐，这就需要采用 align 环境。 align 在使用 \\\\ 换行的基础上，还需要使用 \u0026 指定对齐位置，并且整个公式块将在行内居中显示。例如 tex \\begin{align} \\cos 2x \u0026= \\cos^2x - \\sin^2 x \\\\ \u0026= 2\\cos^2x - 1 \\\\ \u0026= 1-2\\sin^2 x \\end{align} 这时，我们可以看到公式整体处于居中，而公式内部在等号位置对齐。同样，为了避免每行出现编号，使用 aligned 环境将公式转化为块即可，如 tex \\begin{align} \\begin{aligned} \\cos 2x \u0026= \\cos^2x - \\sin^2 x \\\\ \u0026= 2\\cos^2x - 1 \\\\ \u0026= 1-2\\sin^2 x \\end{aligned} \\end{align} 喏，相信看到这里，大家可能会想：既然单行公式是多行公式的特殊情况，那么只需要记住多行公式排版即可，而多行公式多数需要指定对齐位置，那索性只记下 align 环境就行了。幸运的是，就我个人的经验来看，事实确实如此。除非特别地要求多行公式分别居中，不得不用到 gather 环境，一般情况下 align 及其变种 aligned 足够应付绝大多数排版要求。 ","date":"2020-12-05","objectID":"/latex04-math/:2:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（4）：数学公式","uri":"/latex04-math/#常用数学环境"},{"categories":["LaTeX"],"content":" 矩阵排版基本的 $\\LaTeX$ 中，矩阵采用 \\matrix 等命令进行排版，由于其语法与 $\\LaTeX$ 基本语法不一致，常采用 AMS 提供的一系列矩阵环境来代替，这些环境的使用与表格的使用相同，区别仅仅在于外部的括号不同： 环境 简单说明 matrix 无括号 pmatrix 圆括号 bmatrix 方括号 Bmatrix 花括号 vmatrix 单竖线 Vmatrix 双竖线 矩阵排版更灵活的方法是采用 array 环境，有需求的小伙伴可以查看其宏包说明。 问题 数学排版从操作上并非难事，但有很多细节问题需要大家认真考虑。比如，标准的数学采用斜体作为标量的字体，加粗的字体表示矩阵或者向量，那么，自然对数的底 $\\mathrm{e}$ 应当是什么字体？以及，微分运算符 $\\mathrm{d}$ 呢？细心的朋友们会发现，常数和运算符都采用正体，并且运算符与变量之间的间距往往与变量之间的间距还略有不同。类似的细节还很多，算是行业标准，还望大家稍作重视。","date":"2020-12-05","objectID":"/latex04-math/:3:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（4）：数学公式","uri":"/latex04-math/#矩阵排版"},{"categories":["LaTeX"],"content":"很多朋友使用 $\\LaTeX$ 处理图表是都会感觉达不到期望的状态，这篇文章我们来看看如何正确使用图表。 ","date":"2020-11-14","objectID":"/latex03-tablefigure/:0:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（3）：使用图表","uri":"/latex03-tablefigure/#"},{"categories":["LaTeX"],"content":" 认识浮动体$\\LaTeX$ 有很多“环境”的概念，在代码里就体现为采用 \\begin{\u003cenv\u003e} 和 \\end{\u003cenv\u003e} 括起来的部分。环境一般用于局部的格式设置或者功能扩展，比如正常写作时采用的是两端对齐，如果想临时居中某内容时，可以使用 center 环境，如 tex 如果采用 $\\LaTeX$ 进行编译后，生成的文档中，这里是正常的两端对齐文字。 \\begin{center} 这里是居中的文字。 \\end{center} 环境是可以嵌套的，例如上面的内容在正文区，而正文区开始于 \\begin{document} ，说明正文是处于 document 环境下的。 可以想象，一般的图表都采用居中的格式，应当分别处于独立的环境中，$\\LaTeX$ 为此提供了 table 和 figure 环境。对于上例这样一般的环境，它仅提供局部的格式变动，不会影响上下文之间的位置关系。而 table 和 figure 却与之不同，它们被称作浮动体，意思是源码之间的相对位置与编译后生成文档中的相对位置可能是不同的。比如源码中的顺序是先写“如图 3 所示”，然后再插入图片，生成的文档可能会先插入图片，再出现“如图 3 所示”。 图表采用这种浮动体的原因有 一般文档会以交叉引用的方式指明图表（比如“如图 3 所示”，而不是“如下图所示”），因此图表与正文的相对位置没有过于严格的要求； 当前页面内的剩余版面可能无法完整插入图片或者表格，如果留空白会导致排版不好看，因此可以将图表移位，用后文填充页面； $\\LaTeX$ 默认的排版美学：同一页内连续使用图表或出现过多图表会使页面显得比较空洞而不好看。 使用浮动体（table 和 figure环境）时可以用中括号添加可选参数，表示可以浮动的位置，可选以下几个参数或其组合： h：允许在当前位置（here），即源码中插图与正文的相对位置保持一致； t：允许在当前页面的最顶端（top）； b：允许在当前页面的最低端（bottom）； p：允许将图片放在单独一页（page）。 有时候 $\\LaTeX$ 默认的排版美学会让人感到困惑，因此浮动体还支持采用 ! 选项突破默认的限制，例如我自己插图的时候经常会采用 \\begin{figure}[!htb] 的设置。 ","date":"2020-11-14","objectID":"/latex03-tablefigure/:1:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（3）：使用图表","uri":"/latex03-tablefigure/#认识浮动体"},{"categories":["LaTeX"],"content":" 使用插图为了在文档中插入图片，需要对 $\\LaTeX$ 的功能进行“扩展”，在导言区使用 \\usepackage{graphicx} 宏包即可。这个宏包提供的 \\includegraphics 命令可以方便地插入 pdf、eps、jpg、png 等常见格式的图片，使用方法和示例如下。 tex % 导言区添加 \\usepackage{graphicx} % \\includegraphics[\u003c选项\u003e]{\u003c图片文件名\u003e} \\begin{figure}[!htb] % 还记得刚说的图片放在浮动体内吗？ \\centering % 设置图片居中 % 插入图片，图片宽度为 0.7 倍正文宽度，图片文件为 misaka.png \\includegraphics[width=0.7\\textwidth]{misaka.png} \\caption{御坂美琴} % 正文中的图名 \\label{fig:misaka} % 交叉引用的标签，以后再说哈 \\end{figure} 以这种方法插图时，图片放置的位置必须在搜索路径中，或者使用绝对路径。一般情况下，我们会把正文图片收集在 figures 文件夹内，并在导入宏包后立即将该文件夹添加到图片的搜索路径，如下 tex \\usepackage{graphicx} % 添加搜索路径，多个路径时用花括号区分 \\graphicspath{ {./figure/} {./figures/} } 如此就可以实现正文的插图了。实际上，$\\LaTeX$ 是支持直接绘图的，有兴趣的小伙伴可以在命令行使用 texdoc pgfmanual 查看具体方法。 1300 多页的说明文档直接给我劝退了……有学会的小伙伴教教我哈。通常我还是使用其他软件绘图，导出 .pdf 后在 $\\LaTeX$ 中插图。说来，Inkscape 确实是一款很好用的矢量绘图开源软件。 ","date":"2020-11-14","objectID":"/latex03-tablefigure/:2:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（3）：使用图表","uri":"/latex03-tablefigure/#使用插图"},{"categories":["LaTeX"],"content":" 绘制表格绘制表格所需要的基本环境不需要额外的宏包进行扩展，但是依然推荐两个宏包：tabularx 和 booktabs，前者提供了定宽表格的格式，后者则提供了标准的三线表样式。下面我们先来看一个例子 tex \\begin{table}[hbp] \\centering \\caption{页码数字格式} \\label{tab:pagenum} \\begin{tabular}{ll} \\toprule 格式 \u0026 说明 \\\\ \\midrule arabic \u0026 阿拉伯数字 \\\\ roman \u0026 小写的罗马数字 \\\\ Roman \u0026 大写的罗马数字 \\\\ alph \u0026 小写的字符形式 \\\\ Alph \u0026 大写的字符形式 \\\\ \\bottomrule \\end{tabular} \\end{table} 分析表格的代码：我们在最外围申明了表格所处的 table 环境，这是将表格整体作为浮动体；然后设置该环境下内容居中显示；由于表格的标题一般在表格上方，所以先生成标题并打上标签；剩下的一大块便是由 tabular 环境构造的表格。 tabular 环境是用来构造表格本体的，该环境有一个参数用来指明列格式，常用的列格式包括： l：本列左对齐； c：本列居中； r：本列右对齐； p{\u003c列宽\u003e}：指定列宽并允许自动换行； |： 画一条竖线，不占据表项计数； @{\u003c内容\u003e}：任意添加内容，不占表项计数； *{\u003c计数\u003e}{\u003c列格式说明\u003e}：将给定列格式按计数重复多次。 诸位如果记不住这么多格式，只记住 l、c、r 就够基本使用了，有多少列就写多少个 l、c、r。 在表内，采用符号 \u0026 指明对齐位置， 并使用 \\\\ 进行换行。表格中可以使用 \\hline 绘制横线，或使用\\cline{\u003c开始\u003e-\u003c结束\u003e} 指定横线的范围。booktabs 宏包提供了标准三线表的横线，可使用命令 \\toprule 、 \\midrule、\\bottomrule分别绘制顶部横线、中间横线和底部横线。为了像 \\cline 那样绘制指定位置的横线，该宏包还提供了 \\cmidrule 命令。表格中绘制与单元格等高的竖线可用 \\vline 命令。 如上面的例子所示，在不单独指定列宽的情况下，tabular 环境可以根据内容自动改变表格宽度，这在绝大多数情况下是非常好用的。然而有时候我们希望指定表格的总宽度，这就需要tabularx宏包提供的tabularx 环境。该环境在指定列格式之前必须指定表格的总宽度。同时，该宏包提供了一个特殊的列格式 X，它能够根据总宽度和表的内容自动改变列宽，也可以和其他列格式一起使用。 写了不少了，更详细的使用帮助可使用 texdoc \u003c宏包名\u003e 查看。不过，现在有很多 在线制作 $\\LaTeX$ 表格 的工具，大家都可以尝试。 ","date":"2020-11-14","objectID":"/latex03-tablefigure/:3:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（3）：使用图表","uri":"/latex03-tablefigure/#绘制表格"},{"categories":["LaTeX"],"content":"这回我们来看看如何用 $\\LaTeX$ 编写文档。 ","date":"2020-10-27","objectID":"/latex02-document/:0:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（2）：编写文档","uri":"/latex02-document/#"},{"categories":["LaTeX"],"content":" 从示例开始上回在介绍 $\\LaTeX$ 的 安装与配置 后给出了一个最小的示例，给出了比较详细的注释，我们就从这个示例开始。 tex % HelloWorld.tex % Encoding： UTF-8 % ======================================================== % 🎆🎆🎆🎆🎆 导言区 🎆🎆🎆🎆🎆 % ======================================================== \\documentclass{article} % 业界习惯：百分号是注释开始的标志 \\title{Greetings} % 不服就试：注释是不会进入正文的哟 \\author{SpringMan} % 凑个对齐：在注释里可以任意地耍赖 \\date{\\today} % 如你所见：导言区就是进行“某些”设置的 % ======================================================== % 🎆🎆🎆🎆🎆 正文区 🎆🎆🎆🎆🎆 % ======================================================== \\begin{document} % 可想而知：正文从这里开始 \\maketitle % 显而易见：这个命令用来产生标题 Hello World ! % 打个招呼：你好世界 \\end{document} % 不难预料：正文在这里结束 首先注意到， % 后面的文字颜色与其他部分不一样，这是因为 % 是注释符号，像很多其他编程语言一样，注释的内容仅为了分割源码一起为源码的功能写备注所用，注释的内容并不会对主程序产生影响。 根据注释信息，文档分为导言区和正文区。两者实际上是以 \\begin{document} 为分割，在此之前的内容一般都是对文档的格式或属性进行声明，不会直接影响正文内容。正文区则以 \\begin{document} 和 \\end{document} 包围，是文档的主要内容。 在语法高亮功能的辅助下，诸位应当能够看到各种以反斜线 \\ 开头的词语呈现花花绿绿的颜色，这就是 $\\LaTeX$ 的命令（也叫做宏），类比为其他编程中的函数。这些命令可以完成丰富的功能，如设置文档信息的 \\title，在正文中生成标题的 \\maketitle 等。本例中的命令顾名思义即可，并不复杂，其他命令及其使用将在后面详细介绍。 ","date":"2020-10-27","objectID":"/latex02-document/:1:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（2）：编写文档","uri":"/latex02-document/#从示例开始"},{"categories":["LaTeX"],"content":" 导言区的设置在导言区内，首先需要使用 \\documentclass{} 声明文档类，这一步可以理解成为整个文档初始化，包括设置参数默认值（如行间距）、导入基本的命令。例如，在上面的例子中，article 是 $\\LaTeX$ 最基础的文档类，其诞生时并没有考虑到多语言支持，若使用该文档类，正文区使用中文将出现与预期不符的结果。 可见，仅调用文档类并采用其提供的默认设置并不能解决编写文档的需求，这时候我们需要“扩展” $\\LaTeX$ 的功能。只需要使用命令 \\usepackage{} 调用宏包即可。例如，为了在 article 文档类中使用中文，只需要在导言区补充 \\usepackage{ctex} 即可。 碎碎念1：实际上可以使用 CTeX 提供的 ctexart 文档类直接初始化中文支持，这也是最常用的方法。 碎碎念2：作为开源软件的优势，有很多优秀的宏包为 $\\LaTeX$ 提供了相当高级的功能，例如自动将段落组织成爱心状以方便书写情书；但由开源导致的宏包的多样性会使得寻找期望的宏包需要时间和耐心。好在，常用的宏包并不多，以后会慢慢介绍。 除了声明文档类和调用宏包，导言区还可以定义命令和环境，定义命令的基本方法如下，中括号为可选内容 tex \\newcommand{\u003c命令名\u003e}[\u003c参数个数\u003e][\u003c首参数默认值\u003e]{\u003c定义\u003e} \\renewcommand{\u003c命令名\u003e}[\u003c参数个数\u003e][\u003c首参数默认值\u003e]{\u003c定义\u003e} \\newcommand 用于定义新的命令，通常用于偷懒，例如我通常用哥特字体 $\\mathfrak{q}$ 来表示四元数，其命令 \\mathfrak{q} 太麻烦了，就可以在导言区定义 tex \\newcommand{\\q}{\\mathfrak{q}} 这样就可以直接使用 \\q 使用四元数了。 当使用 \\newcommand 定义已经存在的命令时，会产生错误。此时需要 \\renewcommand 重新定义命令，这往往用于格式的修改。 除了定义新的命令，导言区内还可以定义新的环境。作为快速入门的介绍，我不想展开太多，先不写了（偷懒）。 总而言之，导言区的作用就是对文档的格式进行设置：首先是声明文档类进行最基础的设置，然后调用宏包对设置进行更新或修改，必要时定义新的命令来辅助文档编写。 为了满足急不可耐的小伙伴好奇心，这里给出部分常用的宏包，有兴趣的可以在命令行采用 texdoc \u003c宏包名\u003e 查看帮助文档（没有什么比作者自己写的帮助文档更详细的了） tex % 某春雨在导言区常用的宏包 % 文档类使用 ctexart % 基本格式设置 \\usepackage{geometry} % 页边距设置 \\usepackage{fancyhdr} % 页眉页脚设置 \\usepackage{tocbibind} % 目录包含目录/参考文献/附录 \\usepackage{hyperref} % 超链接 % 数学相关宏包 \\usepackage{amsmath} % 数学环境 \\usepackage{amssymb} % 数学符号 \\usepackage{bm} % 特殊符号加粗 \\usepackage{newtxmath} % Times数学字体 % 图表相关宏包 \\usepackage{graphicx} % 插图控制 \\usepackage{tabularx} % 定宽表格 \\usepackage{booktabs} % 标准三线表 % 其他常用宏包 \\usepackage{siunitx} % 国际单位 \\usepackage{gbt7714} % 标准参考文献引用 ","date":"2020-10-27","objectID":"/latex02-document/:2:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（2）：编写文档","uri":"/latex02-document/#导言区的设置"},{"categories":["LaTeX"],"content":" 正文区的编写在正文区内，只需要按正常的思路编写文档即可。应当注意，$\\LaTeX$ 源码内的换行不会引起编译后的文档新起一个段落，这与 Word 有所区别。通过空行（一行或多行）可以实现正文另起段落。 利用源代码换行的特性，我们可以一句一行以便修改，这取决于个人的习惯。需要提醒的一个技巧是利用换行和注释对文档进行修改，从而保留修改历史以方便对比，如 tex % 正文区（原文） 为了说明源码换行不会引起正文换行，我决定先写一段没有什么实际意义的废话来凑一些字数，一方面要求字数充分多以突出行号，另一方面还是要求字数足够多以突出行号。大家可以看到，我的这一段文字前面只有一个行号，说明我在编写的时候并没有通过回车键进行换行，所看到的换行只是由于编辑器为了显示方便的自动换行，如果关闭自动换行的话就会看到超过屏幕的一长段话。这时候屏幕下面应该有个横向的滑块可以左右拖动。 % ======================================================== % 正文区（修改1：完全注释并重新编写） % 为了说明源码换行不会引起正文换行，我决定先写一段没有什么实际意义的废话来凑一些字数，一方面要求字数充分多以突出行号，另一方面还是要求字数足够多以突出行号。大家可以看到，我的这一段文字前面只有一个行号，说明我在编写的时候并没有通过回车键进行换行，所看到的换行只是由于编辑器为了显示方便的自动换行，如果关闭自动换行的话就会看到超过屏幕的一长段话。这时候屏幕下面应该有个横向的滑块可以左右拖动。 % 【修改说明】我可以只加一个百分号就在原文删除一段废话，并且还可以用额外的注释给出修改说明 % ======================================================== % 正文区（修改2：通过换行部分注释并进行部分修改） 为了说明源码换行不会引起正文换行，我决定先写一段没有什么实际意义的废话来凑一些字数 % ，一方面要求字数充分多以突出行号，另一方面还是要求字数足够多以突出行号 % 【修改说明】我也可以换行注释后进行修改，这适合小补丁的修正 。大家可以看到，我的这一段文字前面只有一个行号，说明我在编写的时候并没有通过回车键进行换行，所看到的换行只是由于编辑器为了显示方便的自动换行，如果关闭自动换行的话就会看到超过屏幕的一长段话。这时候屏幕下面应该有个横向的滑块可以左右拖动。 从一般文档的结构来说，通常由目录、正文（分为节、子节等）、参考文献、附录等部分组成，在 Word 中可能需要进行非常麻烦的样式设定，而 $\\LaTeX$ 通常只需要几条命令就可以实现（显然，这些命令都是在文档类或者宏包中由别人定义好了，必要时在导言区稍作修改即可），非常方便。 tex % 正文区 % 文档前几页的必要信息 \\pagenumbering{Roman} % 目录部分页码通常是罗马数字 \\tableofcontents % 插入目录 \\clearpage % 换页 \\listoffigures % 插入图片索引 \\clearpage % 换页 \\listoftables % 插入表格索引 \\clearpage % 换页 \\pagenumbering{arabic} % 正文页码通常是阿拉伯数字 \\setcounter{page}{1} % 正文页码重新开始于1 % 真正的正文开始于此 \\section{第一节} 此处省略若干字 \\subsection{第一节第一小节} 此处省略若干字 \\subsection{第一节第二小节} 此处省略若干字 \\section{第二节} 此处省略若干字 同样，正文区内包含其他丰富的技巧，一次性也不想写太多，给渴望学习的小伙伴透露一些常用命令。 功能 相关命令 插入脚注 \\footnote{} 或成对使用 \\footnotemark、\\footnotetext{} 行内数学 $ 括起 $\\LaTeX$ 表达式 交叉引用 使用\\label{}插入引用源，使用 \\ref{} 引用编号或 \\pageref{} 引用页码 插入图片 \\includegraphics 插入表格 tabular 环境 添加列表 enumerate 或 itemize 环境 ","date":"2020-10-27","objectID":"/latex02-document/:3:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（2）：编写文档","uri":"/latex02-document/#正文区的编写"},{"categories":["LaTeX"],"content":" 文档风格分享作为好习惯的开始，希望大家能够在使用 $\\LaTeX$ 的时候形成自己的文件管理风格，这可以利用 \\include{} 和 \\input{} 命令完成：\\include{} 命令将另一个 .tex 文档的内容复制到命令所在的位置，并利用 \\clearpage 进行分页；\\input{} 命令则相当于仅把目标文档复制到命令所在位置。 最后分享一下我目前的风格，文件结构如下 text document ├── sections/ ├── figures/ ├── reference/ ├── main.tex └── user_package.tex 为了写一个文档，首先我会新建一个文件夹以储存与该文档相关的所有素材，由于一般都会涉及很多图片，因此会新建 figures/ 文件夹；根据文档内容的多少以及涉及的参考文献数量，可分别建立 sections/、reference/ 文件夹存放文档的各节以及相关参考文献题录，这样有利于大型文档的编写。 建立 main.tex 文件作为核心，在该文件中对文档进行拼接：在导言区对文档样式进行设置（页边距等），在正文区用 \\tableofcontents 生成文档的相关信息，并利用 \\include{} 或 \\input{} 命令插入正文，这样有利于文档结构的布置。 考虑到部分宏包以及自定义的命令与正文息息相关，将这些宏包的调用以及命令定义汇总在 user_package.tex 中，在 main.tex 中采用 \\input{user_package.tex} 导入设置。这样做的原因是：正文的所有内容以及相关宏包都分离为单独文件，避免了更换模板时正文依赖宏包的缺失导致文档编译失败。 以此，main.tex 文档的主要内容大概如下 tex % main.tex % ======================================================== % 🎆🎆🎆🎆🎆 导言区 🎆🎆🎆🎆🎆 % ======================================================== \\documentclass{ctexart} % 正文样式设置 \\ctexset{ section/format = \\centering\\bfseries\\Large, subsection/format = \\raggedright\\bfseries\\large, subsubsection/format = \\raggedright\\bfseries\\large } % 正文依赖的宏包和用户自定义命令 \\input{user_package.tex} % ======================================================== % 🎆🎆🎆🎆🎆 正文区 🎆🎆🎆🎆🎆 % ======================================================== \\begin{document} \\makecover % 生成封面 \\pagenumbering{Roman} % 目录部分页码通常是罗马数字 \\tableofcontents % 插入目录 \\clearpage % 换页 \\listoffigures % 插入图片索引 \\clearpage % 换页 \\listoftables % 插入表格索引 \\clearpage % 换页 \\pagenumbering{arabic} % 正文页码通常是阿拉伯数字 \\setcounter{page}{1} % 正文页码重新开始于1 % 真正的正文开始于此 \\include{sections/background.tex} \\include{sections/calculation.tex} \\include{sections/simulation.tex} \\include{sections/conclusion.tex} \\bibliography{ref} \\include{sections/appendix.tex} \\end{document} 上述风格仅供参考，欢迎讨论。 ","date":"2020-10-27","objectID":"/latex02-document/:4:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（2）：编写文档","uri":"/latex02-document/#文档风格分享"},{"categories":["LaTeX"],"content":"$\\LaTeX$ 是一个非常优秀的开源排版软件，特别适合于大量公式、代码的理工类文档的排版。本文介绍其安装方法并给出最小示例。 ","date":"2020-10-13","objectID":"/latex01-install/:0:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（1）：安装与配置","uri":"/latex01-install/#"},{"categories":["LaTeX"],"content":" $\\LaTeX$ 简介$\\LaTeX$ 是一款开源排版软件，区别于 Word 的所见即所得，使用 $\\LaTeX$ 编写文档更像是编写代码，需要经过编译才能生成pdf格式的文档。初学者可能会止步于这种代码式的文档编写方法，但随着使用的熟练，在科技报告、论文方面，其至少在下面几个方面碾压 Word ： 数学公式支持：$\\LaTeX$ 天然支持数学公式，而 Word 内置的公式编辑器一般不好用，需借助 Mathtype、AxMath 等公式编辑软件； 文献应用支持：$\\LaTeX$ 天然支持文献引用，并提供了常见各种期刊标准样式，而 Word 内置的参考文献录入麻烦，常需借助文献管理软件如 Zotero、Endnote 等； 快速模板切换：$\\LaTeX$ 仅需要对导言区的样式进行更改即可实现全文格式的变更，而 Word 一般需要重新定义样式。 那，话不多说，开整。 ","date":"2020-10-13","objectID":"/latex01-install/:1:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（1）：安装与配置","uri":"/latex01-install/#latex-简介"},{"categories":["LaTeX"],"content":" 安装$\\LaTeX$ 有很多发行版，TeX Live 是最为推荐的一款。下载只需要打开 清华大学开源镜像站，在目录中查找 CTAN → TeX Live → Images，选择任意 texlive*.iso 下载即可。 无论是 Linux 用户还是 Windows 用户，TeX Live 的安装绝对不是一件难事，借用官方的安装说明如下： 安装脚本叫 install-tl，它在目录树的顶层。你可以通过 perl install-tl 来调用它。在 Windows 下，你可以运行在它旁边的批处理文件：install-tl-windows.bat。在 Mac 上，你可能会希望从 MacTeX 安装，它有自己的安装程序 (也在 DVD 里包括，就在你现在浏览的 texlive/ 目录旁边)。 对于Linux用户，安装完成后还需要对路径进行设置，需要在 ~/.bashrc 文件中添加以下内容（注意TeX Live版本号可能存在差异） bash export MANPATH=${MANPATH}:/usr/local/texlive/2020/texmf-dist/doc/man export INFOPATH=${INFOPATH}:/usr/local/texlive/2020/texmf-dist/doc/info export PATH=${PATH}:/usr/local/texlive/2020/bin/x86_64-linux 至此安装完成，为了验证安装的正确性，Linux 用户可以打开终端，Windows 用户可以打开 CMD，运行 bash latex --version 正常输出版本号即代表 $\\LaTeX$ 安装正确。 ","date":"2020-10-13","objectID":"/latex01-install/:2:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（1）：安装与配置","uri":"/latex01-install/#安装"},{"categories":["LaTeX"],"content":" 配置如本文开头所示，使用 $\\LaTeX$ 编写文档更像是编写程序，而 $\\LaTeX$ 只是编译器。为此，我们还需要一个友好的编写代码环境（当然，你完全可以用记事本之类的软件，取决于个人爱好）。TeXstudio 是一个值得推荐编辑器，这对新手非常友好，基本上不需要进行特别的配置。对于我们需要编写中文文档的，只需要将编译器改为 xelatex 即可。 另一个好看的编辑器莫过于 VS Code 了，我们仅需要安装插件 LaTeX Workshop，并在设置中引入如下配置即可： json \"latex-workshop.view.pdf.viewer\": \"tab\", \"latex-workshop.latex.tools\": [ { \"name\": \"xelatex\", \"command\": \"xelatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOCFILE%\" ] }, { \"name\": \"pdflatex\", \"command\": \"pdflatex\", \"args\": [ \"-synctex=1\", \"-interaction=nonstopmode\", \"-file-line-error\", \"%DOCFILE%\" ] }, { \"name\": \"bibtex\", \"command\": \"bibtex\", \"args\": [ \"%DOCFILE%\" ] } ], \"latex-workshop.latex.recipes\": [ { \"name\": \"xelatex\", \"tools\": [ \"xelatex\" ], }, { \"name\": \"pdflatex\", \"tools\": [ \"pdflatex\" ] }, { \"name\": \"xe-\u003ebib-\u003exe-\u003exe\", \"tools\": [ \"xelatex\", \"bibtex\", \"xelatex\", \"xelatex\" ] }, { \"name\": \"pdf-\u003ebib-\u003epdf-\u003epdf\", \"tools\": [ \"pdflatex\", \"bibtex\", \"pdflatex\", \"pdflatex\" ] } ], \"latex-workshop.bibtex-format.tab\": \"4 spaces\", \"latex-workshop.latex.autoBuild.run\" : \"never\", ","date":"2020-10-13","objectID":"/latex01-install/:3:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（1）：安装与配置","uri":"/latex01-install/#配置"},{"categories":["LaTeX"],"content":" Hello World$\\LaTeX$ 的文档以 .tex 为后缀，因此我们可以创建一个名为 HelloWorld.tex 文件，填入以下内容： tex % ======================================================== % 🎆🎆🎆🎆🎆 导言区 🎆🎆🎆🎆🎆 % ======================================================== \\documentclass{article} % 业界习惯：百分号是注释开始的标志 \\title{Greetings} % 不服就试：注释是不会进入正文的哟 \\author{SpringMan} % 凑个对齐：在注释里可以任意地耍赖 \\date{\\today} % 如你所见：导言区就是进行“某些”设置的 % ======================================================== % 🎆🎆🎆🎆🎆 正文区 🎆🎆🎆🎆🎆 % ======================================================== \\begin{document} % 可想而知：正文从这里开始 \\maketitle % 显而易见：这个命令用来产生标题 Hello World ! % 打个招呼：你好世界 \\end{document} % 不难预料：正文在这里结束 使用 TeXstudio 的小伙伴可以点击运行并查看，使用 VS Code 的小伙伴可以仅使用 xelatex 编译，喜欢命令行的猛士也可以在当前目录下运行命令 xelatex HelloWorld.tex ，最后，我们打开编译生成的同名 pdf 文件，就可以看到以下效果，是不是非常神奇呢？ $\\LaTeX$ 排版结果 ","date":"2020-10-13","objectID":"/latex01-install/:4:0","series":null,"tags":["LaTeX"],"title":"LaTeX 学习记录（1）：安装与配置","uri":"/latex01-install/#hello-world"},{"categories":["控制理论基础"],"content":"比例积分微分（PID）控制器是一种经典的控制器，以其简单的结构和较强的鲁棒性广泛适用于各种控制系统。对 PID 的原理有多种解释，今天跟大家分享一些自己的看法。 ","date":"2020-09-08","objectID":"/intropid/:0:0","series":null,"tags":["PID","控制器"],"title":"感性认识 PID","uri":"/intropid/#"},{"categories":["控制理论基础"],"content":" 弹簧-质量-阻尼系统弹簧-质量-阻尼系统可以说是最经典也是最容易让大家产生感性认识的物理系统，如下图所示，假设一质量块的质量为 $m$ 无摩擦地放置于地面，通过刚度系数为 $k$ 的弹簧和阻尼系数为 $c$ 的阻尼器与墙壁连接。 弹簧-质量-阻尼系统示意图 将坐标系原点建立在弹簧的自由长度处，在图示正方向下，质量块受到的力有：外部作用产生的合力 $F$、弹簧的回复力 $-kx$、阻尼器产生的阻尼 $-c\\dot{x}$。根据牛顿第二定律可以得到质量块的运动方程为 $$ m \\ddot{x} = F - kx - c \\dot{x} $$ 可见，质量块的运动由系统特性（刚度和阻尼）及作用力决定。为了改变系统的动态，我们可以换一个弹簧或者阻尼器来改变系统自身的特性，或者施加一定的力$F$引导质量块的运动。 二阶系统的结构框图 ","date":"2020-09-08","objectID":"/intropid/:1:0","series":null,"tags":["PID","控制器"],"title":"感性认识 PID","uri":"/intropid/#弹簧-质量-阻尼系统"},{"categories":["控制理论基础"],"content":" 增益与微分为了改变质量块的运动特性，首先将增益和微分环节引入反馈。也就是令上面的外力依据质量块的位置和速度施加 $F = -(P x + D \\dot{x })$，这时系统的动态方程将变为 $$ m \\ddot{x} = - kx - c \\dot{x} - (P x + D \\dot{x }) = -(k+P)x- (c+D) \\dot{x} $$ 方程中，控制器参数的比例增益 $P$ 与刚度 $k$ 处于等价的位置，而微分增益 $D$ 与阻尼系数 $c$ 等价。这就说明，虽然我们不能从物理层面改变弹簧的刚度和系统的阻尼，但是可以通过分别调整 $P$ 和 $D$ 来等效地改变系统的“闭环刚度”和“闭环阻尼”，从而改变系统的动态响应。 PD控制器的理论实现如下图所示，需要说明的是，这里的微分器仅作示意，实际上理想的微分器是不存在的，可以参考 信号的微分。 二阶系统的 PD 反馈 我们说经典控制是基于误差来消除误差，而误差的定义是什么呢？实际上，控制的目的是使系统的输出跟随一个参考信号 $r$，这里就对应质量块按照需求发生位移。需求值与实际值不同，就是反馈所用的误差，在本例中为 $$ e = r-x $$ 使用了误差反馈时，反馈力为 $$ F = Pe + D\\dot{e} = - (P x + D \\dot{x }) + (Pr + D\\dot{r}) $$ 该式的前一个括号对应地改变了系统的刚度和阻尼，而后一个括号是对参考信号的考究：增益考虑了参考信号以多大的强度输入到控制系统，而微分则是对参考信号进一步预测，使系统能够提前做出响应。 ","date":"2020-09-08","objectID":"/intropid/:2:0","series":null,"tags":["PID","控制器"],"title":"感性认识 PID","uri":"/intropid/#增益与微分"},{"categories":["控制理论基础"],"content":" 积分的作用从上面的讨论可知，PD控制器似乎已经能够满足需求，为什么还需要用到积分呢？一般的讨论中，我们会计算PD控制下的稳态误差：令动态方程中位置的各阶导数为零，对应着没有速度、加速度，因而处于稳态。得到（下标 $\\rm ss$ 表示 steady-state） $$ m \\ddot{x} = - kx - c \\dot{x} - (P x + D \\dot{x }) + (Pr + D\\dot{r}) \\quad \\Rightarrow \\quad x_{\\rm ss} = \\frac{P}{k+P}r $$ 可以看到，当刚度不为$0$或者参考信号不恒为$0$时，仅采用PD控制存在稳态误差，增大$P$可以减小稳态误差，这时反馈力中$Pr$项增大，因此前面说$P$也对应于参考信号输入到控制系统的强度。 为了使稳态误差为零，这可以通两种方式补偿： 当系统的刚度准确可知时，令参考信号的输入强度（比例增益）为$k+P$，即反馈力的计算修改为 $F = - (P x + D \\dot{x }) + \\left[(P+k)r + D\\dot{r} \\right]$； 当系统的刚度不可知时，引入积分环节，反馈力变为 $F = Pe + D\\dot{e} + I \\int e\\mathrm{d}t$，此时，系统稳定时所有的动态停止，意味着积分停止，即误差收敛到 $0$。利用积分器的这个特性，我们可以说积分环节补偿了系统参数（刚度）的不确定性。 除了系统参数不确定性外，更重要是外部扰动的不确定性。为了说明这一点，设参考信号恒为 $0$，从上面的计算可知 PD 控制不会引入稳态误差。然而当存在外部扰动力 $F_n$ 时（为方便讨论，假定为恒力），质量块最终会稳定在 $$ x_{\\rm ss} = \\frac{F_n}{k+P} $$ 即外部扰动力也会使质量块出现稳态误差，同样，我们引入积分环节，达到稳态时，各动态停止，积分的停止意味着 $e=0$，则有 $$ m \\ddot{x} = F_n - kx - c \\dot{x} + Pe + D\\dot{e} + I \\int e\\mathrm{d}t \\quad \\Rightarrow \\quad F_n + I \\int e\\mathrm{d}t = 0 $$ 可见积分补偿了外部扰动。 由上述讨论可知，积分环节能够补偿系统参数不确定性引入的误差和外部扰动引入的误差，从而使稳态误差收敛到 $0$。总的来说：积分能够补偿系统的不确定性。 ","date":"2020-09-08","objectID":"/intropid/:3:0","series":null,"tags":["PID","控制器"],"title":"感性认识 PID","uri":"/intropid/#积分的作用"},{"categories":["控制理论基础"],"content":" 总结采用 PID 进行反馈控制时： P 能够改变系统的刚度，调整系统的自振频率，改变动态过程，在引入参考信号时能够调整参考信号的输入强度； D 能够改变系统的阻尼，使系统的自振能够快速收敛，同时能够对参考信号做出预测，使系统提前响应； I 则用于补偿系统由于参数不确定性、扰动不确定性引入的误差，提高系统鲁棒性。 ","date":"2020-09-08","objectID":"/intropid/:4:0","series":null,"tags":["PID","控制器"],"title":"感性认识 PID","uri":"/intropid/#总结"},{"categories":["控制理论基础"],"content":"砰砰控制（Bang Bang Control）是一种使误差收敛速度最快的最优控制，对于二阶系统，可以借助相图来完成。本文介绍相图并据此实现砰砰控制。 ","date":"2020-08-21","objectID":"/bangbang/:0:0","series":null,"tags":["相图","砰砰控制","Bang Bang Control"],"title":"相图与砰砰控制","uri":"/bangbang/#"},{"categories":["控制理论基础"],"content":" 相图相图（Phase Portrait）也称相轨迹，是以各状态为坐标，由状态轨迹绘制而成的图。例如，质量为 $m$，刚度为 $K$ 弹簧的状态空间方程为 $$ \\left\\{ \\begin{aligned} \\dot{x}_1 \u0026= x_2 \\\\ \\dot{x}_2 \u0026= -\\frac{K}{m} x_1 + \\frac{1}{m} F \\end{aligned} \\right. $$ 当外力 $F=0$，弹簧从某一初始位置自由释放时，质量块会在平衡位置来回震荡，其相图如下图所示 震荡过程的相图 相图表示了系统状态随时间的发展趋势，在分析系统动态时非常有用。此外，bilibili 的 up 主 DR_CAN 在他的一期视频里 利用相图分析了爱情，很有意思，有兴趣的朋友可以看一下。 ","date":"2020-08-21","objectID":"/bangbang/:1:0","series":null,"tags":["相图","砰砰控制","Bang Bang Control"],"title":"相图与砰砰控制","uri":"/bangbang/#相图"},{"categories":["控制理论基础"],"content":" 砰砰控制砰砰控制（Bang Bang Control）又称开关控制，它的控制信号非正即负，系统响应要么全力加速要么全力减速，因而是一种最速控制。以二阶系统为例，为了确定控制信号（加速度）变号的时刻，考察系统在 $u=u_{\\rm max}$ 和 $u=-u_{\\rm max}$ 时的相图，如下图所示（设 $u_{\\rm max}=1$ ） 匀加速运动的相图 图中，蓝色曲线代表在某状态处施加正向最大控制量时系统状态的轨迹，其由第四象限拐向第一象限；红色曲线为施加负向最大控制量时状态的轨迹，由第二象限拐向第三象限。可见，存在一个临界的曲线，如图中绿色曲线所示，当初始状态在该曲线上方时，只要施加负向控制量可使状态回到绿色曲线，反之只要施加正向控制量即可回到绿色曲线。因此这个绿色的曲线就是控制信号的切换曲线。 临界曲线的解析式分别对应从原点处分别按 $u = \\pm u_{\\rm max} = \\pm 1$ 施加控制所形成的状态轨迹，其表达式为 $$x_1 + \\frac{x_2 |x_2|}{2u_{\\rm max}} = 0$$ 因而控制信号可根据当前状态来确定 $$u = -u_{\\rm max} \\operatorname{sign}\\left( x_1 + \\frac{x_2 |x_2|}{2u_{\\rm max}} \\right)$$ 设系统初始状态 $x_1=-2,, x_2=3$ ，控制过程的状态轨迹如下图紫色曲线所示 砰砰控制收敛过程的相轨迹 理想情况下，控制信号 $u$ 最多只需要一次切换就能达到控制效果，而实际的数字控制器中，离散状态的时间间隔限制了状态不可能正好达到相图的原点，状态轨迹会在原点附近出现高频\"颤振\"，如下图所示。相应地，控制信号不断进行正负切换，就像乒乓球来回碰撞，砰砰控制也因此得名。 砰砰控制的位移收敛与指令颤振 砰砰控制的高频颤振使其在实际应用中受到限制，为了解决这个问题，韩京清老师基于离散时间模型对控制信号进行了改进，提出了如下算法： $$ \\mathrm{fhan} = \\left\\{ \\begin{aligned} \u0026 a_0 = h x_2 \\\\ \u0026 d = r h^2 \\\\ \u0026 y = x_1 + a_0 \\\\ \u0026 a_1 = \\sqrt{d \\left( d+ 8\\left| y \\right| \\right)} \\\\ \u0026 a_2 = a_0 + \\operatorname{sign}\\left( y \\right) \\frac{a_1-d}{2} \\\\ \u0026 s_y = \\frac{1}{2} \\left[ \\operatorname{sign}\\left( y+d \\right) - \\operatorname{sign}\\left( y-d\\right)\\right] \\\\ \u0026 a = \\left( a_0 + y - a_2 \\right) s_y + a_2 \\\\ \u0026 s_a = \\frac{1}{2} \\left[ \\operatorname{sign}\\left( a+d \\right) - \\operatorname{sign}\\left( a-d\\right)\\right] \\\\ \u0026 \\mathrm{fhan} = -r \\left[ \\frac{a}{d} - \\operatorname{sign}\\left( a \\right)\\right] s_a - r \\operatorname{sign}\\left( a \\right) \\end{aligned}\\right. $$ 式中， $r=u_{\\rm max}$ 为控制器输出的最大控制信号，值越大响应越快，闭环的带宽也越大。 $h$ 为采样时间，实际使用时可取独立于 $h$ 的变量 $h_0 =n h$ 以抑制高频噪声，即 $u = \\operatorname{fhan}\\left( x_1, , x_2, , r, , h_0 \\right)$。采用这种算法，砰砰控制不再出现高频颤振，如下图所示。 fhan 最优综合下的砰砰控制 ","date":"2020-08-21","objectID":"/bangbang/:2:0","series":null,"tags":["相图","砰砰控制","Bang Bang Control"],"title":"相图与砰砰控制","uri":"/bangbang/#砰砰控制"},{"categories":["控制理论基础"],"content":" 参考文献 G.F. Franklin, J. D. Powell, A. Emami-Naeini. Feedback Control of Dynamic Systems. 7th ed. 2014. p673-676. 韩京清, 自抗扰控制技术: 估计补偿不确定因素的控制技术. 国防工业出版社. 2008. p107. ","date":"2020-08-21","objectID":"/bangbang/:3:0","series":null,"tags":["相图","砰砰控制","Bang Bang Control"],"title":"相图与砰砰控制","uri":"/bangbang/#参考文献"},{"categories":["奇妙的数学"],"content":"“近似”是非常常用的数学手段，其中包括利用多项式来作为其他函数的近似，并使得两个函数之间的某个误差最小，这类极小化问题应当如何求解？本文从一个几何例子开始，以数形结合的思想初步给出极小化问题与正交投影之间的关系；然后介绍多项式的内积定义，给出函数在多项式线性空间的正交投影计算方法；最后以正弦函数的多项式近似给出一个极小化问题的实例。 ","date":"2020-08-16","objectID":"/orthogonalprojection/:0:0","series":null,"tags":["正交投影","曲线拟合"],"title":"正交投影——极小化问题的解决方案","uri":"/orthogonalprojection/#"},{"categories":["奇妙的数学"],"content":" 极小化问题的直观认识如下图所示，三维空间中存在某一向量 $\\vec{v}$，现需要在给定平面内找到一个向量 $\\vec{u}$ 来尽可能逼近 $\\vec{v}$，这就要求两者的误差最小。向量的误差可以用模长（欧几里得范数）来定量表述，其定义为 $$\\left\\| \\vec{u} - \\vec{v} \\right\\| = \\sqrt{(\\vec{u} - \\vec{v}) \\cdot (\\vec{u} - \\vec{v})}$$ 由于点到平面内的距离最短，那么这个极小化问题的解就是向量 $\\vec{v}$ 在给定平面内的正交投影，即 $\\vec{u}=\\vec{v}_p$ 。 空间向量的正交投影示意图 为了定量表述向量 $\\vec{v}$ 的正交投影，需要选取基向量，如图中的 $\\vec{e}_1$ 和 $\\vec{e}_2$。特别地，所选取的基向量为标准正交基，即满足： $$ \\vec{e}_i \\cdot \\vec{e}_j = \\left\\{ \\begin{matrix} 1 \u0026 (i = j) \\\\ 0 \u0026 (i \\ne j) \\end{matrix} \\right. $$ 在标准正交基下，正交投影可分解为 $$\\vec{v}_p = \\left( \\vec{v}_p \\cdot \\vec{e}_1 \\right) \\vec{e}_1 + \\left( \\vec{v}_p \\cdot \\vec{e}_2 \\right) \\vec{e}_2$$ 由此可见，极小化问题可化为正交投影的求解问题，这涉及两点核心内容：1）构造合适的标准正交基；2）求原向量（也可能是函数）与各基的内积（对应向量的点乘）。 ","date":"2020-08-16","objectID":"/orthogonalprojection/:1:0","series":null,"tags":["正交投影","曲线拟合"],"title":"正交投影——极小化问题的解决方案","uri":"/orthogonalprojection/#极小化问题的直观认识"},{"categories":["奇妙的数学"],"content":" 多项式的基与内积多项式的一般形式为 $$p = a_0 + a_1x + a_2x^2 + ... + a_nx^n$$ 向量可用坐标 $x_i$ 与基向量 $\\vec{e}_i$ 的线性组合 $$\\vec{v} = x_1 \\vec{e}_1 + x_2 \\vec{e}_2 + ... + x_n \\vec{e}_n$$ 对比上面两种表述，若将 $a_i , (i=0,1,2…n)$ 看作多项式的\"坐标\"，那么 $x^i , (i=0,1,2…n)$ 就是多项式的基。容易看出这种表述确实满足线性可加原理，因而将 $x^i$ 作为多项式的基是合理的。 进一步，为了定义多项式的内积（用尖括号表示），同样由向量的内积类推可得 $$ \\left\\langle \\vec{u},\\,\\vec{v} \\right\\rangle = \\sum\\limits_{i = 1}^n u_i v_i \\to \\left\\langle p_1(x),\\,p_2(x) \\right\\rangle = \\int p_1(x)p_2(x)\\,\\mathrm{d}x $$ 应当注意这里并没有给出多项式的内积定义的积分限，这通常由所关注的问题给出。 ","date":"2020-08-16","objectID":"/orthogonalprojection/:2:0","series":null,"tags":["正交投影","曲线拟合"],"title":"正交投影——极小化问题的解决方案","uri":"/orthogonalprojection/#多项式的基与内积"},{"categories":["奇妙的数学"],"content":" 正弦函数的多项式近似作为一个例子：求一个不超过5次的多项式 $p_5(x)$ ，使其在区间 $\\left[-\\pi,,\\pi\\right]$ 内逼近 $\\sin(x)$ ，要求 $\\int_{-\\pi}^{\\pi} \\left(\\sin(x)-p_5(x) \\right)^2,\\mathrm{d}x$ 最小。 观察到所需的最小值正是 $\\sin(x)$ 与 $p_5(x)$ 误差的内积，为了使其最小，$p_5(x)$ 就是 $\\sin(x)$ 在多项式线性空间的正交投影。 首先构造标准正交基。由上面讨论可知 $x^i (i=0,1,2…n)$ 是多项式的基，但可以验证其不是正交的，因为 $$ \\int_{ - \\pi }^\\pi x^i x^j\\,\\mathrm{d} x \\ne \\left\\{ \\begin{matrix} 1 \u0026 (i = j) \\\\ 0 \u0026 (i \\ne j) \\end{matrix} \\right. $$ 为此，可采用格拉姆-施密特正交化方法，基 $v_i$ 经过正交化后的标准正交基 $e_i$ 为 $$ \\left\\{ \\begin{aligned} e_1 \u0026= \\frac{v_1}{\\left\\| v_1 \\right\\|} \\\\ e_i \u0026= \\frac{ v_i - \\left\\langle v_i,\\, e_1 \\right\\rangle e_1 - \\left\\langle v_i,\\, e_2 \\right\\rangle e_2 - ... - \\left\\langle v_i,\\, e_{i-1} \\right\\rangle e_{i-1} }{\\left\\| v_i - \\left\\langle v_i,\\, e_1 \\right\\rangle e_1 - \\left\\langle v_i,\\, e_2 \\right\\rangle e_2 - ... - \\left\\langle v_i,\\, e_{i-1} \\right\\rangle e_{i-1} \\right\\| } \\quad (i\u003e1) \\end{aligned} \\right. $$ 利用MATLAB符号计算可得本题的标准正交基可选为 $$ \\left\\{\\begin{aligned} e_0 \u0026= \\frac{\\sqrt{2}}{2\\,\\sqrt{\\pi }} \\\\ e_1 \u0026= \\frac{\\sqrt{6}}{2\\,\\pi^{3/2} } x \\\\ e_2 \u0026= -\\frac{3\\,\\sqrt{10}}{4\\,\\pi^{5/2} } \\left(\\frac{\\pi^2 }{3}-x^2 \\right) \\\\ e_3 \u0026= -\\frac{5\\,\\sqrt{14}}{4\\,\\pi^{7/2} } \\left(\\frac{3\\,x\\,\\pi^2 }{5}-x^3 \\right) \\\\ e_4 \u0026= \\frac{105\\,\\sqrt{2}}{16\\,\\pi^{9/2} } \\left(x^4 -\\frac{6\\,\\pi^2 \\,x^2 }{7}+\\frac{3\\,\\pi^4 }{35}\\right) \\\\ e_5 \u0026= \\frac{63\\,\\sqrt{22}}{16\\,\\pi^{11/2} } \\left(x^5 -\\frac{10\\,\\pi^2 \\,x^3 }{9}+\\frac{5\\,\\pi^4 \\,x}{21}\\right) \\end{aligned}\\right. $$ 计算 $\\sin(x)$ 与各基的内积后，得所求的5次多项式为 $$ \\begin{aligned} {p_5}(x) \u0026= \\left( {\\frac{{105}}{{8{\\pi ^2}}} - \\frac{{16065}}{{8{\\pi ^4}}} + \\frac{{155925}}{{8{\\pi ^6}}}} \\right)x + \\left( { - \\frac{{315}}{{4{\\pi ^4}}} + \\frac{{39375}}{{4{\\pi ^6}}} - \\frac{{363825}}{{4{\\pi ^8}}}} \\right){x^3} + \\left( {\\frac{{693}}{{8{\\pi ^6}}} - \\frac{{72765}}{{8{\\pi ^8}}} + \\frac{{654885}}{{8{\\pi ^{10}}}}} \\right){x^5} \\\\ \u0026\\approx {\\text{0}}{\\text{.9878621356}}x - {\\text{0}}{\\text{.1552714106}}{x^3} + {\\text{0}}{\\text{.005643117976}}{x^5} \\ \\end{aligned} $$ 上式可以与 $\\sin(x)$ 的泰勒展开对比 $$p_{t}(x) = x-\\frac{x^3 }{6}+\\frac{x^5 }{120}$$ 将三者绘制在同一张图上，如下图所示，可见正交投影的方式获取的多项式更加逼近原始正弦函数，在 $\\pm\\pi$ 处的误差远小于泰勒展开导致的误差。 正弦函数的多项式近似 本文所涉及的相关符号计算源码如下 matlab % Symbolic calculation for projection of sin(x) % Ref: (ISBN) 978-7-115-43178-3, 149-150 % XiaoCY 2020-08-02 (MATLAB R2020a) clear;clc close all %% Symbolic Calculation syms x f(x) = sin(x); degp = 5; % degree of polynomial B = x.^(0:degp); % Gram－Schmidt Orthogonalization B(1) = B(1)/sqrt(int(B(1)^2,-pi,pi)); for k = 2:degp+1 V = B(k); for m = 1:k-1 V = V-int(B(k)*B(m),-pi,pi)*B(m); end B(k) = V/sqrt(int(V^2,-pi,pi)); end Y = int(f.*B,-pi,pi).*B; y(x) = sum(Y); p = sym2poly(y); ft = taylor(f,x,0,'order',6); %% Plot Results x = linspace(-pi,pi,1e3); figure subplot(2,1,1) plot(x,f(x),'DisplayName','Sine') hold on plot(x,ft(x),'DisplayName','Taylor') plot(x,polyval(p,x),'DisplayName','Projection') grid on legend('Location','southeast') ylabel('Value') axis([-pi pi -1.2 1.2]) subplot(2,1,2) plot(x,ft(x)-f(x),'DisplayName','Taylor') hold on plot(x,polyval(p,x)-f(x),'DisplayName','Projection') grid on legend('Location','southeast') ylabel('Error') xlim([-pi pi]) ","date":"2020-08-16","objectID":"/orthogonalprojection/:3:0","series":null,"tags":["正交投影","曲线拟合"],"title":"正交投影——极小化问题的解决方案","uri":"/orthogonalprojection/#正弦函数的多项式近似"},{"categories":["奇妙的数学"],"content":" 参考文献 Sheldon Axler. Linear Algebra Done Right (线性代数应该这样学). 2016. ","date":"2020-08-16","objectID":"/orthogonalprojection/:4:0","series":null,"tags":["正交投影","曲线拟合"],"title":"正交投影——极小化问题的解决方案","uri":"/orthogonalprojection/#参考文献"},{"categories":["控制理论基础"],"content":"对于被引入到系统的参考信号，如果其特征是已知的，还可以采用所谓的鲁棒跟踪控制进一步提高系统对该类信号的跟踪能力。本文将介绍这种方法的设计。 ","date":"2020-08-15","objectID":"/robusttracking/:0:0","series":null,"tags":["鲁棒跟踪","现代控制"],"title":"鲁棒跟踪控制","uri":"/robusttracking/#"},{"categories":["控制理论基础"],"content":" 参考信号特征参考信号的特征可以用一定的微分方程进行描述。例如直流信号可以不失一般性地描述为 $\\dot{r}=0$；而正弦信号可以参考弹簧-刚度系统的描述；如果参考信号为 $\\omega_1$ 和 $\\omega_2$ 两个正弦信号的叠加，它的微分方程可选为 $$r^{(4)}+(\\omega_1^2+\\omega_2^2)r^{(2)} + \\omega_1^2\\omega_2^2 =0$$ 用于描述信号特征的微分方程有很多，依信号类型而不同。本文以一个二阶信号为例，假设输入的参考信号满足微分方程 $$\\ddot{r} + \\alpha_1 \\dot{r} +\\alpha_0 r = 0$$ 根据该微分方程，可以对控制律或这状态估计器进行扩展，从而实现鲁棒跟踪控制（Robust Tracking Control）。 ","date":"2020-08-15","objectID":"/robusttracking/:1:0","series":null,"tags":["鲁棒跟踪","现代控制"],"title":"鲁棒跟踪控制","uri":"/robusttracking/#参考信号特征"},{"categories":["控制理论基础"],"content":" 扩展控制律设被控对象的状态空间表述为 $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= A \\bm{x} + Bu \\\\ y \u0026= C \\bm{x} \\end{aligned} \\right. $$ 定义跟踪误差 $e=y-r$ 。将其代入参考信号的微分方程，有 $$ \\begin{aligned} \\ddot e + {\\alpha _1}\\dot e + {\\alpha _0}e \u0026= \\ddot y + {\\alpha _1}\\dot y + {\\alpha _0}y \\\\ \u0026= {C}\\left( {\\ddot{\\bm{x}} + {\\alpha_1}\\dot{\\bm{x}} + {\\alpha _0}{\\bm{x}}} \\right) \\\\ \u0026= {C\\bm{\\xi }} \\\\ \\end{aligned} $$ 这里定义了 $\\xi={\\ddot{\\bm{x}} + {\\alpha_1}\\dot{\\bm{x}} + {\\alpha _0}{\\bm{x}}}$，考察它的动态，有 $$ \\begin{aligned} \\dot{\\xi} \u0026= \\frac{\\mathrm{d}}{\\mathrm{d}t} \\left( \\ddot{\\bm{x}} + \\alpha_1 \\dot{\\bm{x}} +\\alpha_0 \\bm{x}\\right) \\\\ \u0026= \\frac{\\mathrm{d}^2}{\\mathrm{d}t^2} \\dot{\\bm{x}} + \\alpha_1 \\frac{\\mathrm{d}}{\\mathrm{d}t} \\dot{\\bm{x}} + \\dot{\\bm{x}} \\\\ \u0026=A\\left( \\ddot{\\bm{x}} + \\alpha_1 \\dot{\\bm{x}} +\\alpha_0 \\bm{x}\\right) + B \\left( \\ddot{u} + \\alpha_1 \\dot{u} +\\alpha_0 u\\right) \\\\ \u0026= A \\xi + B \\mu \\end{aligned} $$ 同样补充定义了 $\\mu = \\ddot u + \\alpha \\dot u + \\alpha_0 u$ 。 综上，利用误差和扩展的状态量构造误差空间（Error Space） $$ {\\bm{\\dot z}} = {{ A}_z}{\\bm{z}} + {{B}_z}\\mu = \\begin{bmatrix} 0\u00261\u0026{0}\\\\\\ { - {\\alpha _0}}\u0026{ - {\\alpha _1}}\u0026{C}\\\\\\ {0}\u0026{0}\u0026{ A} \\end{bmatrix} \\left[ \\begin{array}{c} e \\\\ \\dot{e} \\\\ \\xi \\end{array} \\right] + \\begin{bmatrix} 0\\\\\\ 0\\\\\\ {B} \\end{bmatrix} \\mu $$ 取状态反馈为 $\\mu = - {{K}_z}{\\bm{z}} = - \\begin{bmatrix} {{K_{e0}}}\u0026{{K_{e1}}}\u0026{{{K}_x}} \\end{bmatrix}\\bm{z}$，当上述误差收敛时，由于跟踪误差为零，系统的输出将跟随输入。 为了实现上述控制器，需要从 $\\mu$ 中求解系统输入 $u$ ，这可以从 $\\mu$ 的定义中获得 $$ \\begin{gathered} \\ddot u + {\\alpha _1}\\dot u + {\\alpha _0}u = - {{K}_z}{\\bm{z}} = - {K_{e0}}e - {K_{e1}}\\dot e - {K}_x\\left( \\ddot{\\bm{x}} + {\\alpha _1}\\dot{\\bm{x}} + {\\alpha _0}{\\bm{x}} \\right) \\\\ \\Updownarrow \\\\ \\frac{{{{\\text{d}}^2}}}{{{\\text{d}}{t^2}}}\\left( {u + {{K}_x}{\\bm{x}}} \\right) + {\\alpha _1}\\frac{{\\text{d}}}{{{\\text{d}}t}}\\left( {u + {{K}_x}{\\bm{x}}} \\right) + {\\alpha _0}\\left( {u + {{K}_x}{\\bm{x}}} \\right) = - {K_{e0}}e - {K_{e1}}\\dot e \\\\ \\Downarrow \\\\ e \\to u + {{K}_x}{\\bm{x}}:\\quad H(s) = - \\frac{{{K_{e1}}s + {K_{e0}}}}{{{s^2} + {\\alpha _1}s + {\\alpha _0}}} \\\\ \\end{gathered} $$ 利用微分方程的实现手段（传递函数或状态空间的标准实现），根据 $e$ 求解 $u + {{K}_x}{\\bm{x}}$ ，然后与 ${{K}_x}{\\bm{x}}$ 相减即可得到系统的输入信号 $u$ 。这种方法可以看作是对控制律的扩展，而状态估计器与一般的估计器并无大异，可以将这种方法命名为扩展控制律，其结构如下图所示。 扩展控制律后的系统示意图 ","date":"2020-08-15","objectID":"/robusttracking/:2:0","series":null,"tags":["鲁棒跟踪","现代控制"],"title":"鲁棒跟踪控制","uri":"/robusttracking/#扩展控制律"},{"categories":["控制理论基础"],"content":" 扩展状态估计器既然控制律可以利用已知的参考信号动态进行扩展，那么状态估计器也应当能够扩展。我们可以这样想：如果系统的输出与参考之间存在误差，说明系统的输入端存在没有被完全抵消的扰动 $\\rho$ ，如果能够对这个扰动进行估计，令 $u=-K\\bm{x}-\\rho$ 就可以在控制器的输出端抵消这个扰动，从而减小跟踪误差。 从系统的输出向输入看，表现为各微分的组合，当参考信号 $r$ 满足某个微分方程时， $\\rho$ 也一定会满足该微分方程，在本例中 $$\\ddot{\\rho} + \\alpha_1 \\dot{\\rho} +\\alpha_0 \\rho = 0$$ 类似扩展控制律，将扰动和系统状态合一起作为扩展状态，状态空间可表述为 $$ \\left\\{ \\begin{aligned} \\bm{\\dot{z}} \u0026= {{A}_z}{\\bm{z} + {{B}_z}u = \\begin{bmatrix} 0\u00261\u0026{\\bm{0}} \\\\ { - {\\alpha _0}}\u0026{ - {\\alpha _1}}\u0026{\\bm{0}} \\\\ {B}\u0026{\\bm{0}}\u0026{A} \\end{bmatrix}\\begin{bmatrix} \\rho \\\\ {\\dot{\\rho} } \\\\ {\\bm{x}} \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ 0 \\\\ {B} \\end{bmatrix}u{\\quad}} \\\\ y \u0026= {{C}_z}{\\bm{z} = \\begin{bmatrix} 0\u00260\u0026{C} \\end{bmatrix}{\\bm{z}}} \\end{aligned}\\right. $$ 其对应的扩展状态估计器为 $$\\dot{\\bm{\\hat{z}}} = {{A}_z}{\\bm{z}} + {{B}_z}u + {L}_z\\left( {y - {{C}_z}{\\bm{z}}} \\right)$$ 利用 ${{A}_z} - {{L}_z}{{C}_z}$ 的特征值设计使扩展状态估计器稳定，最后用 $u=-K\\hat{\\bm{x}} - \\hat{\\rho}$ 即可完成整个控制器设计。本例中的闭环框图如下，状态估计器相对于普通的状态估计器增加了对扰动的建模，因此称为扩展状态估计器。 扩展状态估计器后的系统示意图 ","date":"2020-08-15","objectID":"/robusttracking/:3:0","series":null,"tags":["鲁棒跟踪","现代控制"],"title":"鲁棒跟踪控制","uri":"/robusttracking/#扩展状态估计器"},{"categories":["控制理论基础"],"content":" 参考文献 G.F. Franklin, J. D. Powell, and A. Emami-Naeini, Feedback Control of Dynamic Systems, 7th ed. 2014. ","date":"2020-08-15","objectID":"/robusttracking/:4:0","series":null,"tags":["鲁棒跟踪","现代控制"],"title":"鲁棒跟踪控制","uri":"/robusttracking/#参考文献"},{"categories":["控制理论基础"],"content":"调节器只能将系统的各状态拉回到零位，而控制系统的根本目的是使被控对象的输出跟随参考信号，因此在调节器设计完成的基础上，还需要正确地引入参考信号。本文介绍三种常用的方式将参考信号引入到控制系统。 ","date":"2020-08-08","objectID":"/mc05-reference/:0:0","series":null,"tags":["参考信号","现代控制"],"title":"现代控制理论（5）：参考信号的引入","uri":"/mc05-reference/#"},{"categories":["控制理论基础"],"content":" 输入的一般形式设被控对象的状态空间方程为 $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= A \\bm{x} + Bu \\\\ y \u0026= C \\bm{x} \\end{aligned} \\right. $$ 在实际的数字控制系统中，能够人为干涉的是状态的估计和控制律，因此，不失一般性地可以设参考信号 $r$ 的引入方式为 $$ \\left\\{ \\begin{aligned} \\dot{\\hat{\\bm{x}}} \u0026= \\left( {{A} - {LC} - {BK}} \\right) \\hat{\\bm x} + {L}y + {M}r \\\\ u \u0026= - K {\\hat{\\bm x}} + Nr \\end{aligned} \\right. $$ 参数 $M$ 和 $N$ 的设计方法可分为如下三种情况。 ","date":"2020-08-08","objectID":"/mc05-reference/:1:0","series":null,"tags":["参考信号","现代控制"],"title":"现代控制理论（5）：参考信号的引入","uri":"/mc05-reference/#输入的一般形式"},{"categories":["控制理论基础"],"content":" 标准形式 (Standard Case)从状态观测器的角度来考察，不希望参考信号的引入对状态估计产生影响，考察状态估计的误差为 $$ \\begin{aligned}\\dot{\\tilde{\\bm{x}}} \u0026= {A\\bm{x}} + {B}\\left( { - K{\\hat{\\bm x}} + Nr} \\right) - \\left[ {\\left( {{A} - {LC} - {BK}} \\right){\\bm{\\hat x}} + {L}y + {M}r} \\right] \\\\ \u0026= \\left( {{A} - {LC}} \\right){\\bm{\\tilde x}} + \\left( {{B}N - {M}} \\right)r\\end{aligned} $$ 因此，通过补充约束条件： $M = BN$，即可避免参考信号对状态估计引入任何扰动。此时控制器的状态空间可以进一步改写为 $$ \\left\\{ \\begin{aligned} \\bm{\\dot{\\hat x}} \u0026= \\left( {{A} - {LC}} \\right){\\bm{\\hat x}} + {B}u + {L}y \\\\ u \u0026= - K{\\hat{\\bm x}} + Nr \\end{aligned} \\right. $$ 这就意味着状态观测器的输入与被控对象完全一致。这时，只需要对参考信号的增益 $N$ 进行设计，设计的原则是令 $r\\rightarrow y$ 的增益为 $1$ 即可。考察闭环系统的状态空间 $$ \\left\\{ \\begin{aligned} \\begin{bmatrix} {{\\bm{\\dot{x}}}}\\\\ {{\\bm{\\dot{\\tilde x}}}} \\end{bmatrix} \u0026= \\begin{bmatrix} {{A} - {BK}}\u0026{{BK}}\\\\ {0}\u0026{{A} - {LC}} \\end{bmatrix}\\begin{bmatrix} {\\bm{x}}\\\\ {{\\bm{\\tilde x}}} \\end{bmatrix}+ \\begin{bmatrix} {B}\\\\ {0} \\end{bmatrix}Nr \\\\ y \u0026= \\begin{bmatrix} {C}\u00260 \\end{bmatrix} \\begin{bmatrix} {\\bm{x}}\\\\ {{\\bm{\\tilde x}}} \\end{bmatrix} \\end{aligned} \\right. $$ 根据 $r\\rightarrow y$ 的增益为 $1$ 解得 $$ N = - \\left\\{ \\begin{bmatrix} {C}\u00260 \\end{bmatrix} \\begin{bmatrix} A - BK \u0026BK\\\\ {0}\u0026A - LC \\end{bmatrix}^{-1} \\begin{bmatrix} {B}\\\\ {0} \\end{bmatrix} \\right\\}^{ - 1} $$ 这时整个系统的框图如下图所示。 标准形式的参考输入 ","date":"2020-08-08","objectID":"/mc05-reference/:2:0","series":null,"tags":["参考信号","现代控制"],"title":"现代控制理论（5）：参考信号的引入","uri":"/mc05-reference/#标准形式-standard-case"},{"categories":["控制理论基础"],"content":" 误差控制 (Error Control Case)如果令 $N=0$ ， $M = -L$，即可得到基于误差控制的参考信号引入方式，这是经典控制中的常用方式，如下图所示。 误差形式的参考输入 这种简单的方式可以用传递函数来证明其可靠性，设开环传递函数为 $H_{\\rm open}$，则 $r\\rightarrow y$ 的传递函数即为闭环传递函数 $$H_{close}=\\frac{H_{\\rm open}}{1+H_{\\rm open}} \\rightarrow 1$$ 应当注意，上式成立的条件是 $H_{\\rm open}$ 在带宽内具有足够的增益，这通常要求开环传递函数中存在一个或多个 $\\frac{1}{s}$ 项，若被控对象本身无法满足这一条件，可考虑在控制器中增加积分环节。 ","date":"2020-08-08","objectID":"/mc05-reference/:3:0","series":null,"tags":["参考信号","现代控制"],"title":"现代控制理论（5）：参考信号的引入","uri":"/mc05-reference/#误差控制-error-control-case"},{"categories":["控制理论基础"],"content":" 一般形式 (General Case)更一般地，可以通过人为设计参数 $M$ 和 $N$ 来设计 $r\\rightarrow u$ 的零点从而改变 $r\\rightarrow y$ 的零点以改善系统的动态特性。$r\\rightarrow u$ 的零点满足（这里关注 $r$ ，可以暂时令 $y=0$ ） $$ \\begin{gathered} \\begin{vmatrix} {{I}s - \\left( {{A} - {BK} - {LC}} \\right)}\u0026{ - {M}} \\\\ { - {K}}\u0026N \\end{vmatrix} = 0 \\\\ \\Downarrow \\\\ \\left| {{I}s - {A} + {BK} + {LC} - \\frac{{M}}{N}{K}} \\right| = \\left| {{I}s - {A} + {BK} + {LC} - {{\\bar MK}}} \\right| = 0 \\end{gathered} $$ 因此，我们可以首先根据零点对进行 ${\\bar{M}}=\\frac{M}{N}$ 设计，再根据 $r\\rightarrow y$ 的增益为 $1$ 计算得 $N$ 。这种方式的系统框图如下图所示。 一般形式的参考输入 ","date":"2020-08-08","objectID":"/mc05-reference/:4:0","series":null,"tags":["参考信号","现代控制"],"title":"现代控制理论（5）：参考信号的引入","uri":"/mc05-reference/#一般形式-general-case"},{"categories":["控制理论基础"],"content":" 参考文献 G.F. Franklin, J. D. Powell, and A. Emami-Naeini, Feedback Control of Dynamic Systems, 7th ed. 2014. ","date":"2020-08-08","objectID":"/mc05-reference/:5:0","series":null,"tags":["参考信号","现代控制"],"title":"现代控制理论（5）：参考信号的引入","uri":"/mc05-reference/#参考文献"},{"categories":["控制理论基础"],"content":"状态估计器提供了状态的估计值，在分离原理的指导下，利用估计的状态进行状态反馈能够使系统稳定。本文讨论最基本的闭环设计，即调节器设计。 ","date":"2020-08-02","objectID":"/mc04-regulator/:0:0","series":null,"tags":["调节器","分离原理"],"title":"现代控制理论（4）：调节器设计","uri":"/mc04-regulator/#"},{"categories":["控制理论基础"],"content":" 分离原理状态反馈指出可以利用系统的状态变量的线性组合 $u=-K\\bm{x}$ 作为被控对象的输入以稳定系统。由于系统的状态通常不易直接测得，需要通过状态估计器进行状态估计。容易想到实际的控制信号是由状态估计值提供，即 $u=-K\\hat{\\bm{x}}$ 。分离原理为这样做的可行性提供了理论依据。 设被控对象的状态空间表述为 $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= A \\bm{x} + Bu \\\\ y \u0026= C \\bm{x} \\end{aligned} \\right. $$ 相应构建状态估计器为 $$\\dot{\\hat{\\bm{x}}} = A\\hat{\\bm{x}}+Bu+L\\left(y-C\\hat{\\bm{x}}\\right)$$ 则状态误差 $\\tilde{\\bm{x}}=\\hat{\\bm{x}}-\\bm{x}$ 满足 $$\\dot{\\tilde{\\bm{x}}}=\\left(A-LC\\right)\\tilde{\\bm{x}}$$ 控制律为 $$u=-K\\hat{\\bm{x}}=-K\\left( \\tilde{\\bm{x}} + \\bm{x} \\right)$$ 综上，整个闭环系统的状态空间可表述为： $$ \\begin{bmatrix} \\dot{\\bm{x}} \\\\ \\dot{\\tilde{\\bm{x}}} \\end{bmatrix} = \\begin{bmatrix} {A} - {BK} \u0026 - {BK} \\\\ 0 \u0026 {A} - {LC} \\end{bmatrix} \\begin{bmatrix} {\\bm{x}} \\\\ \\bm{\\tilde x} \\end{bmatrix} $$ 闭环的系统矩阵为上三角矩阵，其特征值为 $A-BK$ 和 $A-LC$ 的特征值。因此得到分离原理：当理想控制器和状态估计器分别稳定时，构成的系统也一定是稳定的。 根据分离原理，进行闭环设计时可以分别对控制器和状态观测器进行设计，然后将控制器所用的状态量替换为状态估计器输出的状态估计值即可。 ","date":"2020-08-02","objectID":"/mc04-regulator/:1:0","series":null,"tags":["调节器","分离原理"],"title":"现代控制理论（4）：调节器设计","uri":"/mc04-regulator/#分离原理"},{"categories":["控制理论基础"],"content":" 调节器设计示例设一负弹簧系统的特征角频率为 $\\omega_n = 2 \\,\\rm{rad/s}$ ，系统输入为加速度，输出为位移。则该系统的状态空间表述为 $$ \\left\\{ \\begin{aligned} \\bm{\\dot x} = \\begin{bmatrix} 0\u00261\\\\ {\\omega _n^2}\u00260 \\end{bmatrix}{\\bm{x}} + \\begin{bmatrix} 0\\\\ 1 \\end{bmatrix} u \\\\ y = \\begin{bmatrix} 1\u00260 \\end{bmatrix}{\\bm{x}} \\end{aligned} \\right. $$ 仿真模型如下图所示，紫色区域为被控对象(Plant)，其输入为控制器的输出信号 $u$；黄色区域内为状态估计器，其内嵌一个与被控对象相同的模型，分别接收控制器输出信号 $u$ 和被控对象输出 $y=x_1$ ，通过参数 $L$ 将误差反馈到状态进行状态修正，输出状态的估计值；粉色控制律则基于理想状态反馈设计，由状态估计值和反馈增益 $K$ 计算反馈控制信号 $u$ 。 被控对象与控制器仿真模型 为了稳定系统，可将控制器的极点布置在 $-0.5\\pm0.866j$，将状态估计器的极点布置在 $-3.5\\pm3.571j$ ，可以利用 MATLAB 的 place 函数实现，如 matlab % Plant omgn = 2; A = [0 1; omgn^2 0]; B = [0 1]'; C = [1 0]; % Control Law K = place(A,B,[-0.5+0.866j -0.5-0.866j]); % State Estimator L = place(A',C',[-3.5+3.571j -3.5-3.571j]); L = L'; 参数设计完成后带入仿真，运行后结果如下图所示。由于设计了被控对象初始状态非零，因而初期存在状态误差，该误差收状态估计器调节而收敛。系统的状态和估计受到控制律约束，克服负刚度造成的不稳定影响，最终各状态稳定到零位。对比两图可见，状态估计器的带宽大于控制器的带宽，因而状态误差的收敛比状态的收敛更快。 调节器仿真结果 ","date":"2020-08-02","objectID":"/mc04-regulator/:0:0","series":null,"tags":["调节器","分离原理"],"title":"现代控制理论（4）：调节器设计","uri":"/mc04-regulator/#调节器设计示例"},{"categories":["控制理论基础"],"content":" 参考文献 G.F. Franklin, J. D. Powell, and A. Emami-Naeini, Feedback Control of Dynamic Systems, 7th ed. 2014. ","date":"2020-08-02","objectID":"/mc04-regulator/:1:0","series":null,"tags":["调节器","分离原理"],"title":"现代控制理论（4）：调节器设计","uri":"/mc04-regulator/#参考文献"},{"categories":["控制理论基础"],"content":"现代控制讲究状态反馈，然而系统的状态不一定是直接测得的，这就需要用到本文介绍的状态估计器进行状态估计。 ","date":"2020-07-11","objectID":"/mc03-stateestimator/:0:0","series":null,"tags":["状态估计","现代控制"],"title":"现代控制理论（3）：状态估计","uri":"/mc03-stateestimator/#"},{"categories":["控制理论基础"],"content":" 全维状态估计器设线性时不变被控对象的状态空间表述为： $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= A \\bm{x} + Bu \\\\ y \u0026= C \\bm{x} \\end{aligned} \\right. $$ 据此，构建相同的理论模型： $$ \\left\\{ \\begin{aligned} \\dot{\\hat{\\bm{x}}} \u0026= A \\hat{\\bm{x}} + Bu \\\\ \\hat{y} \u0026= C \\hat{\\bm{x}} \\end{aligned} \\right. $$ 在该理论模型中，带帽子的变量（如 $\\hat{x}$）表示估计值。由于是理论模型，其所有信息都可以通过计算机获得。理论模型和被控对象输入相同的 $u$ 时，原则上两者的响应相同，因而状态和输出都应当相同。然而实际上，由于被控对象和理论模型初始状态的偏差、理论模型的建模误差、被控对象的额外扰动、传感器的测量噪声等因素的影响，实际输出和理论输出并不相同，因而状态也不相同。 When in trouble, use feedback。为了解决模型之间的差异，遵循这个控制的金科玉律，对理论模型引入反馈进行矫正，令： $$\\bm{\\dot{\\hat{x}}} = A\\hat{\\bm{x}} + { B}u + {L}\\left( {y - \\hat y} \\right)$$ 此时状态的估计误差 ${\\bm{\\tilde x}} = {\\bm{x}} - {\\bm{\\hat{x}}}$ 满足： $$\\bm{\\dot{\\tilde{x}}} = \\left( A - LC \\right) \\bm{\\tilde{x}}$$ 于是，只要合理设计 $L$ 令 $\\left( A - LC \\right)$ 所有特征值的实部均小于零即可使状态估计误差收敛到零，即状态估计值趋近于真是状态。 状态估计器 $L$ 的设计与状态反馈 $K$ 的设计完全相同，考察数学关系： $$ \\left| {{A} - {LC}} \\right| = \\left| {{{\\left( {{A} - {LC}} \\right)}^T}} \\right| = \\left| {{{A}^T} - {{C}^T}{{L}^T}} \\right| \\leftarrow \\left| A - BK \\right| $$ 即：状态观测器与控制律之间存在对偶关系，设计时只需分别将 $A$ 、 $C$ 、$L$ 转置后采用与状态反馈相同的方法进行极点配置即可。 下面给出一个全维状态估计器的例子。 设弹簧-质量-阻尼系统的状态空间为： $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= \\begin{bmatrix} 0 \u0026 1 \\\\ -\\omega_n^2 \u0026 -2\\zeta \\omega \\end{bmatrix} \\bm{x} + \\begin{bmatrix} 0 \\\\ \\omega_n^2 \\end{bmatrix}u \\\\ y \u0026= \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix}\\bm{x}\\ \\end{aligned} \\right. $$ 其中，$\\omega_n=1 {\\rm rad/s,}\\, \\zeta=0.3$，基于Simulink搭建被控对象如图所示 全维状态估计器框图 为了状态估计能够快速收敛，设的阻尼系数 $\\zeta=0.7$ ，对应极点为 $-0.70\\pm0.71j$ ，进而 $L=\\left[0.80,, -0.48\\right]$。带入仿真，观察状态的实际值和估计值如下图所示： 全维状态估计器仿真结果 第一个子图实线为真实状态，虚线为状态估计值，可见两者在大约5s后趋于一致。第二个子图则表示两个状态的估计误差，同样可以反应状态估计值的误差随时间收敛到零，状态估计值趋于真实值。 ","date":"2020-07-11","objectID":"/mc03-stateestimator/:1:0","series":null,"tags":["状态估计","现代控制"],"title":"现代控制理论（3）：状态估计","uri":"/mc03-stateestimator/#全维状态估计器"},{"categories":["控制理论基础"],"content":" 降维状态估计器上面介绍的状态估计器称之为全维状态估计器，因为它对系统的所有状态都进行了估计。然而，在一些情况下，系统的输出就是系统的某一个状态，能否直接利用这个状态，仅对其他状态进行估计呢？这时就需要用降维状态估计器。 以单输入单输出系统（SISO，Single Input Sigle Output）为例，将其状态空间方程拆解为： $$ \\left\\{ \\begin{array}{l} \\begin{bmatrix} \\dot{x}_a \\\\ \\dot{\\bm{x}}_b \\end{bmatrix} = \\begin{bmatrix} A_{aa} \u0026 A_{ab} \\\\ A_{ba} \u0026 A_{bb} \\end{bmatrix}\\begin{bmatrix} x_a \\\\ \\bm{x}_b \\end{bmatrix} +\\begin{bmatrix} B_a \\\\B_b \\end{bmatrix} u \\\\ y = \\begin{bmatrix} 1\u00260 \\end{bmatrix}\\begin{bmatrix} x_a \\\\ \\bm{x}_b \\end{bmatrix} \\end{array} \\right. $$ 系统的输出就是状态量 $x_a$ ，需要进行估计的状态为 $\\bm{x}_b$ 。 为了实现降维，需要对原始的状态空间方程进行改造，构造新的系统，使其状态变量有且仅有 $\\bm{x}_b$ 。 首先从 $\\dot{\\bm{x}}_b$ 的方程中寻找新的系统输入方程： $$\\dot{\\bm{x}}_b = {{A}_{bb}}{{\\bm{x}}_b} + \\left( {{A_{ba}}{x_a} + {{ B}_b}u} \\right)$$ 将 $\\dot{x}_a$ 换为输出的导数 $\\dot{y}$ ，改写系统的输出方程： $$\\left( {\\dot{y} - {A_{aa}}{x_a} - {B_a}u} \\right) = {{A}_{ab}}{{\\bm{x}}_b}$$ 由上面两个式子，对比标准的状态空间方程，显然有以下转换关系： $$ \\left\\{ \\begin{array}{l} {\\bf{x}} \\to {{\\bf{x}}_b}\\\\ {A} \\to {{A}_{bb}}\\\\ {B}u \\to \\left( {{A_{ba}}{x_a} + {{B}_b}u} \\right)\\\\ C \\to {{A}_{ab}}\\\\ y \\to \\left( {\\dot y - {A_{aa}}{x_a} - {B_a}u} \\right) \\end{array} \\right. $$ 根据全维状态估计器的设计方法，对这个转换后的\"新系统\"进行状态估计器设计，有 $$ \\begin{aligned} \\dot{\\hat{\\bm{x}}}_b \u0026= {{A}_{bb}}{{{\\bf{\\hat x}}}_b} + \\left( {{A_{ba}}{x_a} + {{B}_b}u} \\right) + {{L}_b}\\left[ {\\left( {\\dot y - {A_{aa}}{x_a} - {B_a}u} \\right) - {{A}_{ab}}{{{\\bf{\\hat x}}}_b}} \\right] \\\\ \u0026= \\left( {{{A}_{bb}} - {{L}_b}{{A}_{ab}}} \\right){{{\\bf{\\hat x}}}_b} + \\left( {{A_{ba}} - {{L}_b}{A_{aa}}} \\right)y + \\left( {{{B}_b} - {{L}_b}{B_a}} \\right)u + {{L}_b}\\dot y \\end{aligned} $$ 由此初步完成了降维估计器的构造，设计的目标只需令 $A_{bb} - L_bA_{ab}$ 的所有特征值实部为负。需要注意的是，上式中包含输出的导数 $\\dot{y}$，实际中微分是不容易实现的，且容易放大高频噪声，应当避免这一项的存在。于是需要进一步构造辅助变量 $\\bm{x}_c = \\bm{\\hat x}_b - L_by$ ，则上式改为： $$ \\dot{\\hat{\\bm{x}}}_c = \\left( {{{A}_{bb}} - {{L}_b}{{A}_{ab}}} \\right)\\left( {{{\\bf{x}}_c} + {{L}_b}y} \\right) + \\left( {{A_{ba}} - {{L}_b}{A_{aa}}} \\right)y + \\left( {{{B}_b} - {{L}_b}{B_a}} \\right)u $$ 至此，推导出降维状态估计器的可实现的形式。对于本文所提及的弹簧-质量-阻尼系统，其降维状态估计器结构如下图所示： 降维状态估计器框图 对降维状态估计器进行参数设计，之后得到该估计器的响应如图： 降维状态估计器仿真结果 该降维状态估计器仅对状态量 $x_2$ 进行估计，可见在 8s 左右估计的误差已收敛到合适的范围，随着时间的增长，状态估计误差收敛于零，状态估计值收敛于真实值。 全维状态估计器还是降维状态估计器？这是一个开放性的问题，全维状态估计器的所有状态响应都有一定的收敛过程，而降维状态估计器利用系统输出作为已知状态，仅被估计的状态存在收敛过程，从这一方面看，降维状态估计器具有\"更快\"的效果；然而，降维估计器中对应于系统输出的状态容易受到传感器噪声的影响，而全维状态估计可以对噪声进行滤波，因而全维状态估计器具有\"更低噪声\"的效果。 ","date":"2020-07-11","objectID":"/mc03-stateestimator/:2:0","series":null,"tags":["状态估计","现代控制"],"title":"现代控制理论（3）：状态估计","uri":"/mc03-stateestimator/#降维状态估计器"},{"categories":["控制理论基础"],"content":" 参考文献 G.F. Franklin, J. D. Powell, and A. Emami-Naeini, Feedback Control of Dynamic Systems, 7th ed. 2014. ","date":"2020-07-11","objectID":"/mc03-stateestimator/:3:0","series":null,"tags":["状态估计","现代控制"],"title":"现代控制理论（3）：状态估计","uri":"/mc03-stateestimator/#参考文献"},{"categories":["控制理论基础"],"content":"状态反馈是现代控制理论的基础，本文分析其基本原理，并介绍主导极点法和 LQR 设计法两种参数设计方法。 ","date":"2020-07-08","objectID":"/mc02-statefeedback/:0:0","series":null,"tags":["状态反馈","现代控制"],"title":"现代控制理论（2）：状态反馈","uri":"/mc02-statefeedback/#"},{"categories":["控制理论基础"],"content":" 状态反馈的原理现代控制理论基于状态空间建模，对于连续的线性时不变系统，其状态空间可表述为： $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= A \\bm{x} + Bu \\\\ y \u0026= C \\bm{x} + Du \\end{aligned} \\right. $$ 通常情况下 $D=0$ 。 如果系统矩阵 $A$ 存在正实部的特征值而导致系统不稳定，或是系统虽然稳定但性能不满足需求，可以通过反馈控制来改变系统特性。现代控制理论采用的状态反馈区别于经典控制中利用输出和参考信号的误差进行反馈，其根据系统的状态来计算控制信号，对于线性系统，反馈信号可表述为 $u = -K{\\bm{x}}$ ，此时系统的动态响应变为 $$\\dot{\\bm{x}} = \\left( A-BK \\right) \\bm{x}$$ 因此，只要我们合理设计反馈增益 $K$ ，使得 $A-BK$ 的特征值（对应传递函数的极点）均分布在复平面的左半平面，即可实现系统的稳定。 常用的系统极点的配置方法有主导极点法和 LQR 设计法，下面用一些例子来介绍反馈增益的设计方法。 ","date":"2020-07-08","objectID":"/mc02-statefeedback/:1:0","series":null,"tags":["状态反馈","现代控制"],"title":"现代控制理论（2）：状态反馈","uri":"/mc02-statefeedback/#状态反馈的原理"},{"categories":["控制理论基础"],"content":" 主导极点法稳定系统的收敛速度取决于离虚轴最近的极点，称为主导极点。主导极点法是将主导极点按照适当的二阶系统进行配置，引入相应的阻尼和刚度使其满足要求；对于其他的非主导极点，将其布置在实轴上，并尽可能远离主导极点，使这些极点领导的响应能够快速收敛。 设某系统状态空间矩阵为： $$ \\begin{aligned} {A} \u0026= \\begin{bmatrix} 0\u00262\u00260\u00260\u00260 \\\\ { - 0.1}\u0026{ - 0.35}\u0026{0.1}\u0026{0.1}\u0026{0.75} \\\\ 0\u00260\u00260\u00262\u00260 \\\\ {0.4}\u0026{0.4}\u0026{ - 0.4}\u0026{ - 1.4}\u00260 \\\\ 0\u0026{ - 0.03}\u00260\u00260\u0026{ - 1} \\end{bmatrix} \\\\ {B} \u0026= \\begin{bmatrix} 1\u00260\u00260\u00260\u00260 \\end{bmatrix} \\\\ {C} \u0026= \\begin{bmatrix} 1\u00260\u00260\u00260\u00260 \\end{bmatrix} \\end{aligned} $$ 容易计算系统矩阵的特征值有： $[0,-0.5075,-0.9683,-0.6371\\pm0.6669j]$ ，可见改系统具有四个稳定的极点和一个位于原点的极点，可以判定该系统为Ⅰ型系统：系统的阶跃响应收敛于斜直线，如下图所示： I 型系统的阶跃响应 通过计算二阶系统的响应，我们发现在 $\\omega_n = 1 \\rm{ rad/s} , \\zeta = 0.5$ 时二阶系统 $H(s)=\\frac{\\omega_n^2}{s^2+2\\zeta\\omega_ns+\\omega_n^2}$ 的响应接近需求，其极点为 $-0.5\\pm0.866j$ 。 因此，我们可以将该系统的主导极点设置为二阶系统的极点，其他极点的距离4倍于主导极点，设置为 $-4$ 。 在 MATLAB 中使用函数 acker 或 place 均可以实现极点配置，前者由于容易引入数值误差，一般用于阶数较低（$\\le10$）的系统；后者的算法是基于特征向量来的，应当避免使用重复极点，必要时可以使重复极点具有微妙的差别。设计时应当注意极点移动的距离越大，意味着反馈增益越大，即需要的能量越大，应当充分考虑执行机的能力。 通过极点配置，反馈后系统矩阵 $A-BK$ 的特征值为：$[-0.5 \\pm 0.866j,\\,-3.99,\\,-4,\\,-4.01]$。进而可以得到系统响应为（输出按20s处的值进行了归一化以便于对比）： 主导极点法设计后系统的阶跃响应 ","date":"2020-07-08","objectID":"/mc02-statefeedback/:2:0","series":null,"tags":["状态反馈","现代控制"],"title":"现代控制理论（2）：状态反馈","uri":"/mc02-statefeedback/#主导极点法"},{"categories":["控制理论基础"],"content":" LQR设计法LQR设计旨在寻找合适 $K$ 的使得下面的积分取得最小值 $${\\mathcal{J} } = \\int_0^\\infty { { {\\bm{x} }^T}Q{\\bm{x } }+{ {\\bm{u} }^T}R{\\bm{u} } } \\,\\mathrm{d} t$$ 其中， $Q$ 和 $R$ 的选取是相对\"任意\"的，初次设计时，可以将其选择为对角矩阵，并令各对角元素为允许误差平方的导数，即： $${Q_{ii} } = \\frac{1}{ {\\max (x_i^2)} },\\quad {\\text{ } }{R_{ii} } = \\frac{1}{ {\\max (u_i^2)} }$$ 选定 $Q$ 和 $R$ 后，利用MATLAB函数 lqr 即可完成设计。 这里，我们令 $R=1$ ，采用两种 $Q$ 进行设计对比，结果如下图所示 $$ \\begin{aligned} {{Q}_1} \u0026= \\begin{bmatrix} {25}\u00260\u00260\u00260\u00260 \\\\ 0\u0026{25}\u00260\u00260\u00260 \\\\ 0\u00260\u0026{25}\u00260\u00260 \\\\ 0\u00260\u00260\u0026{25}\u00260 \\\\ 0\u00260\u00260\u00260\u0026{25} \\end{bmatrix} \\\\ {{Q}_2} \u0026= \\begin{bmatrix} 4\u00260\u00260\u00260\u00260 \\\\ 0\u0026{100}\u00260\u00260\u00260 \\\\ 0\u00260\u00264\u00260\u00260 \\\\ 0\u00260\u00260\u0026{100}\u00260 \\\\ 0\u00260\u00260\u00260\u00264 \\end{bmatrix} \\end{aligned} $$ LQR 设计后系统的阶跃响应 下面给出参数设计的部分源码以供参考，本文所述工作已整理在 控制理论学习仓库 ，欢迎讨论！ matlab % Plant A = [0 2 0 0 0; -0.1 -0.35 0.1 0.1 0.75; 0 0 0 2 0; 0.4 0.4 -0.4 -1.4 0; 0 -0.03 0 0 -1]; B = [0 0 0 0 1]'; C = [1 0 0 0 0]; % Dominant Second-Order Poles p = [-0.5+0.866i -0.5-0.866i -3.99 -4.00 -4.01]'; K = place(A,B,p); % Linear Quadratic Regulator xm = [0.2 0.2 0.2 0.2 0.2]; Q = diag(1./xm.^2) R = 1; K = lqr(A,B,Q,R); ","date":"2020-07-08","objectID":"/mc02-statefeedback/:3:0","series":null,"tags":["状态反馈","现代控制"],"title":"现代控制理论（2）：状态反馈","uri":"/mc02-statefeedback/#lqr设计法"},{"categories":["控制理论基础"],"content":" 参考文献 G.F. Franklin, J. D. Powell, and A. Emami-Naeini, Feedback Control of Dynamic Systems, 7th ed. 2014. ","date":"2020-07-08","objectID":"/mc02-statefeedback/:4:0","series":null,"tags":["状态反馈","现代控制"],"title":"现代控制理论（2）：状态反馈","uri":"/mc02-statefeedback/#参考文献"},{"categories":["控制理论基础"],"content":"系统本质上由微分方程描述，对于线性系统，可采用拉普拉斯变换获取其传递函数，从而在频域上表达系统的特性。对于高阶的微分方程，还可以将其转化为由一系列一阶微分方程组构成的状态空间描述。本文介绍这三种描述系统的方法。 ","date":"2020-07-06","objectID":"/mc01-sysdiscription/:0:0","series":null,"tags":["传递函数","状态空间","现代控制"],"title":"现代控制理论（1）：系统的描述","uri":"/mc01-sysdiscription/#"},{"categories":["控制理论基础"],"content":" 系统的微分方程由于系统是由元件构成的，而元件的特性通常满足一定的（微分）方程，考虑元件之间的约束后，系统的本质就可以看作是微分方程。以经典的弹簧-质量-阻尼系统为例，如下图所示。 弹簧-质量-阻尼系统示意图 该系统由弹簧、阻尼器、质量三个元件构成，三个元件的特性分别由以下方程进行描述： 弹簧满足胡克定律： $F_k = -kx$ 阻尼与速度成正比： $F_c = -cv = -c \\dot{x}$ 质量满足牛顿定律： $F_m = ma = m \\ddot{x}$ 元件与输入之间的联系可以考虑为质量块力的合成： $F_m = F+F_k+F_c$ 综合元件特性与相互联系后，该系统的微分方程为： $$m \\ddot{x} + c \\dot{x} + k x = F$$ 更一般地，设系统的输入为 $u$ ，输出为 $y$，线性系统的微分方程通常可表示为： $$y^{(n)} + a_{n-1} y^{(n-1)} + ...+a_1 y' + a_0 = b_m u^{(m)} + b_{m-1} u^{(m-1)} + ...+b_1 u' + b_0$$ 对于实际的系统，上式通常有 $m \\le n$ 。 ","date":"2020-07-06","objectID":"/mc01-sysdiscription/:1:0","series":null,"tags":["传递函数","状态空间","现代控制"],"title":"现代控制理论（1）：系统的描述","uri":"/mc01-sysdiscription/#系统的微分方程"},{"categories":["控制理论基础"],"content":" 系统的传递函数对于线性微分方程，可以通过所谓的拉普拉斯变换将其转化为频域表达式，拉普拉斯变换的定义为： $$X(s) = \\int_{-\\infty}^{\\infty} x(t) \\mathrm{e}^{st}\\, \\mathrm{d}t$$ 根据定义，对系统的微分方程两边同时进行拉普拉斯变换，有： $$ \\left( s^{n} + a_{n-1} s^{n-1} + ...+a_1 s + a_0 \\right) Y(s) = \\left( b_m s^{m} + b_{m-1} s^{m-1} + ...+b_1 s + b_0 \\right) U(s) $$ 如此做，系统的微分方程在形式上变成了关于复变量 $s$ 的代数方程，称系统输出的拉普拉斯变换与输入的拉普拉斯变换之比为传递函数，记为 $H(s)$ ，由上式可得： $$H(s) = \\frac{b_m s^{m} + b_{m-1} s^{m-1} + ...+b_1 s + b_0}{s^{n} + a_{n-1} s^{n-1} + ...+a_1 s + a_0}$$ ","date":"2020-07-06","objectID":"/mc01-sysdiscription/:2:0","series":null,"tags":["传递函数","状态空间","现代控制"],"title":"现代控制理论（1）：系统的描述","uri":"/mc01-sysdiscription/#系统的传递函数"},{"categories":["控制理论基础"],"content":" 系统的状态空间系统的微分方程阶数通常较高而不便于分析，状态空间的思想在于引入状态变量，将一个高阶微分方程转化为多个一阶微分方程。对于线性微分方程，状态变量的数量等于输出变量的最高微分阶数 $n$ ，从技巧上通常可以取输出及其 $n-1$ 次导数作为状态变量。以上述弹簧-质量-阻尼系统为例，输出最高阶数为2，因此需要选择两个状态变量。选取第一个状态变量为输出，即 $x_1 = x$ ，第二个状态变量为输出的一阶导数，即 $x_2=\\dot{x}$ ，于是有： $$ \\left\\{ \\begin{aligned} \\dot{x}_1 \u0026= x_2 \\\\ \\dot{x}_2 \u0026= -\\frac{k}{m} x_1 -\\frac{c}{m}x_2 + \\frac{F}{m} \\end{aligned} \\right. $$ 不失一般性地，将上述表达写成矩阵的形式为： $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= A \\bm{x} + Bu \\\\ y \u0026= C \\bm{x} + Du \\end{aligned} \\right. $$ 其中， $\\bm{x}$ 为系统的状态变量， $A$ 称为系统矩阵， $B$ 为输入矩阵， $C$ 为输出矩阵， $D$ 为直接传输矩阵且通常 $D=0$。就本例而言： $$ A = \\begin{bmatrix} 0 \u0026 1\\\\ - \\frac{k}{m} \u0026 - \\frac{c}{m} \\end{bmatrix}, \\quad B = \\begin{bmatrix} 0 \\\\ \\frac{1}{m} \\end{bmatrix}, \\quad C = \\begin{bmatrix} 1 \u0026 0 \\end{bmatrix} $$ 需要说明的是，系统的微分方程和传递函数表达式都是唯一的，而状态空间却不是唯一的，这是由于状态变量的选择不唯一。状态空间有几种标准的形式，将在以后进行讨论。除此之外，状态空间表达并不局限于线性时不变系统，它跟微分方程一样广泛适用于各种系统的描述，状态空间更一般的形式如下，暂不做过多讨论。 $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= f(\\bm{x},\\bm{u},t) \\\\ y \u0026= h(\\bm{x},\\bm{u},t) \\\\ \\end{aligned} \\right. $$ 为了说明状态空间方程的求解思路，设系统的状态空间方程为： $$ \\left\\{ \\begin{aligned} \\dot{\\bm{x}} \u0026= A \\bm{x} + Bu \\\\ y \u0026= C \\bm{x} \\end{aligned} \\right. $$ 设辅助状态变量 $\\bm{z}$ 满足线性变换 $\\bm{x}=P\\bm{z}$（ $P$ 为常矩阵），带入第一个方程，有： $$ P\\dot{\\bm{z}}=AP\\bm{z}+B\\bm{u} \\quad \\Rightarrow \\quad \\dot{\\bm{z}}=P^{-1}AP\\bm{z}+P^{-1}B\\bm{u} $$ 选取合适的变换矩阵 $P$ 使得 $P^{-1}AP$ 为矩阵 $A$ 的相似变换，即 $P^{-1}AP$ 为特征值对角矩阵： $$ P^{-1}AP = \\begin{bmatrix} {{\\lambda_1}}\u0026{}\u0026{}\u0026{}\\\\ {}\u0026{{\\lambda_2}}\u0026{}\u0026{}\\\\ {}\u0026{}\u0026 \\ddots \u0026{}\\\\ {}\u0026{}\u0026{}\u0026{{\\lambda_n}} \\end{bmatrix} $$ 如此做，关于辅助状态变量 $\\bm{z}$ 的微分方程组解耦为独立的一阶微分方程： $$ \\dot{z}_i = \\lambda_i z_i + \\tilde{u}_i \\quad \\Rightarrow \\quad z_i(t) = C_i \\mathrm(e)^{\\lambda_i t} + \\tilde{z}_i(t) $$ 其中， $\\tilde{u}_i$ 表示 $P^{-1}B\\bm{u}$ 的第 $i$ 的分量，其对应的特解为 $\\tilde{z}_i(t)$ 。最后代回 $\\bm{x}=P\\bm{z}$ 即可得到原状态变量，进而带入输出矩阵解得输出。 由微分方程的解可以看出，若系统矩阵 $A$ 存在某特征值 $\\lambda_i$ 大于零，根据微分方程的通解，系统将存在某一状态量随时间趋于无穷，在实际系统中将是输出饱和，于是说该系统是不稳定的。若系统矩阵的特征值的实部均小于零，通解将收敛到零（若存在虚部，则是震荡收敛），意味着状态变量的初值将收敛，系统的输出由输入控制，称系统是（渐进）稳定的。特别地，若系统的特征值小于等于零，等于零的特征值将对应于某状态的等幅震荡，由于不会导致系统输出发散，因而也可以说系统是（临界）稳定的。对于实际工作的系统，都应当满足渐进稳定。 信息 最近 3b1b 在 bilibili 上传的 e 的矩阵指数 视频对应着状态空间的求解，有兴趣的同学可以作为扩展学习。 ","date":"2020-07-06","objectID":"/mc01-sysdiscription/:3:0","series":null,"tags":["传递函数","状态空间","现代控制"],"title":"现代控制理论（1）：系统的描述","uri":"/mc01-sysdiscription/#系统的状态空间"},{"categories":["控制理论基础"],"content":" 三种描述的对比微分方程作为系统的本质，适用于各种系统，且对系统的描述是最为详尽的，但其表达不够直观，通常不利于分析问题；传递函数仅适用于线性时不变系统，但其计算简单，直接在频域建模，能够直观表达系统的频率特性（主要指幅频响应和相频响应），但传递函数没有指明系统的状态变量，在基于传递函数建模的仿真系统中通常不能对初始状态的影响进行分析；状态空间是微分方程的等价表述，因而也可以广泛用于各种系统，由于其引入了状态变量的概念，能够方便地分析系统初始状态带来的影响，线性系统的状态空间由矩阵描述，还能使用线性代数中的各种技巧，便于计算。但状态空间基于时域建模，分析系统频率特性时还需要进行拉普拉斯变换。 ","date":"2020-07-06","objectID":"/mc01-sysdiscription/:4:0","series":null,"tags":["传递函数","状态空间","现代控制"],"title":"现代控制理论（1）：系统的描述","uri":"/mc01-sysdiscription/#三种描述的对比"},{"categories":["好用的软件"],"content":"说到文献管理软件，大家可能或多或少听说过 EndNote 或 NoteExpress ，这里再跟大家分享 Zotero，旨在提供一个新的选择，分享开源的强大。这篇文章主要介绍文献管理软件 Zotero 的基本用法，包括：添加题录、获取原文、添加笔记、文献引用、文档整理和数据同步。为了增强数据同步功能，本文还将对坚果云进行补充介绍。 ","date":"2020-06-20","objectID":"/zotero/:0:0","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#"},{"categories":["好用的软件"],"content":" Zotero 基本用法","date":"2020-06-20","objectID":"/zotero/:1:0","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#zotero-基本用法"},{"categories":["好用的软件"],"content":" 安装从 Zotero官网 下载安装包可轻松完成安装，下载界面会识别当前浏览器并推荐相应的插件，同样，点击并安装该插件。 Zotero 下载页面 安装完成后打开 Zotero，其界面大概可以分为三部分：左侧是用户自定义的文件夹，中部是当前文件夹下收录的题录，右侧则是选中的题录的详细信息。 Zotero 主界面 对于 Windows 用户，Zotero 安装时会自动添加 Microsoft Word 插件，在 Word 界面的顶部应当能够看到多出的 Zotero 菜单栏。如果没有，可在 Zotero 的设置中依次找到 Edit → Preferences → Cite → Word Processors 并重新安装插件即可。 Word 的 Zotero 插件 ","date":"2020-06-20","objectID":"/zotero/:1:1","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#安装"},{"categories":["好用的软件"],"content":" 添加题录为了管理文献，首先需要将文献的题录添加到 Zotero 数据库中，我们可以采用三种方法。首先自然是手动输入，在 Zotero 主界面上部点击绿色圆圈的加号，选择题录的类型（书籍、学位论文、期刊文献等等）即可创建空题录，并在右侧手动输入相关信息即可完成录入，这种无疑是比较麻烦的方法，写在前面自然也是当作炮灰，抛砖引玉。 添加题录的第二种方法就是从文件或剪切板板导入。几乎所有的文献检索网站都支持将文献题录导出，以学校图书馆搜索结果为例，搜索文献并点击引用时，可以将文献题录导出到不同格式（令人惊讶的是居然有标准 Zotero 格式），实际上任意下载一种格式都可以从 Zotero 中正确导入。例如下载 BibTex 格式，将会得到一个 .bib 文件。 从网站导出题录 在 Zotero 主界面找到 File → Import... ，然后选择刚才下载的 .bib 文件即可完成导入。可能会有小伙伴觉得使用这种方法一个一个地下载题录再导入很不方便，实际上很多文献检索网站都有批量导出的功能：只要将看中的文献进行标记（不同的网站提示可能不一样，例如有的可以在前面打勾，有的提供\"Save Item\"选项），然后批量导出，进而可以批量导入到 Zotero 。 如果觉得这样依然比较麻烦，那么第三种方法就是使用之前安装的浏览器插件进行全自动收录。打开文献的网站后，Zotero 的浏览器插件会自动进行识别，识别成功后图标会发生相应改变，例如期刊文献的图标如下图所示。点击插件，选择题录保存的文件夹，点击Done 即可。 使用 Zotero 插件导入题录 注意 该功能在本地使用时需要提前打开 Zotero 软件，或者从插件登陆在线帐号，否则无法顺利导入题录。 ","date":"2020-06-20","objectID":"/zotero/:1:2","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#添加题录"},{"categories":["好用的软件"],"content":" 获取原文如果在导入题录的时候使用的是浏览器插件，且相应的文献通过正常渠道可以免费下载，那么稍等一会儿，你会看到 Zotero 能够自动下载文献并与题录关联，是不是非常棒呢！ 如果相关的文献在正常渠道不可以免费下载，那么很遗憾 Zotero 将不会自动下载。假如学校购买了相应数据库，可以手动下载后右键点击题录添加附件将文献原文与题录进行关联。 如果文献在正常渠道不免费，学校又没有买，那只得采用一点非正常渠道咯：SciHub。为了使用SciHub，你需要知道文献的身份证，即所谓的 DOI，其通常是以 10. 开头的字符串，如 10.1088/0264-9381/33/3/035010 ，一般在文献检索网站都有该信息。得到 DOI 后，我们就可以在 SciHub 进行下载。 信息 作为文献收录最全的非正常渠道，SciHub 为科研人员提供了免费的文献，因此也受到官方的封杀。但更多的人认为知识不应当受到限制，因而 SciHub 通过不断更换域名得以维持。例如本文写成时可用的域名为 https://sci-hub.se/ 。 Zotero 作为开源软件，获取 DOI 这种事情麻烦但又常见的事情，当然可以有插件来解决：使用 Zotero-ShortDOI 获取文献 DOI，然后利用 Zotero-SciHub 即可获得原文，而这只需要两次鼠标的右键即可完成。 在 Zotero 中安装插件也非常简单：下载相关 .xpi 文件，在主界面的 Tools → Add-ons 点击齿轮选择从文件安装插件，然后重启软件即可。 安装 Zotero 插件 技巧 有些浏览器在点击 .xpi 文件的链接后不会自动下载，右键该链接并选择\"链接保存为…“即可。 ","date":"2020-06-20","objectID":"/zotero/:1:3","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#获取原文"},{"categories":["好用的软件"],"content":" 添加笔记右键题录可以为题录添加笔记，也可以从上部添加笔记的按钮中添加独立笔记。然而 Zotero 自带的笔记功能不支持 Markdown 语法，为了对此功能进行扩充，可以使用 MarkdownHere 插件。我不打算展开介绍 Markdown 教程，附以超链接供大家参考。 使用 Markdown 语法编写好笔记后，点击 File → Markdown Toggle 即可进行渲染。需要说明的是，如果重新编辑笔记，需要再次点击 Markdown Toggle 回到文本模式，编辑完成后重新渲染，否则该功能不会正常工作。 ","date":"2020-06-20","objectID":"/zotero/:1:4","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#添加笔记"},{"categories":["好用的软件"],"content":" 文献引用Zotero 对 Word 的支持使得文献引用非常简单，只需要在 Word 中点击 Zotero → Add/Edit Citation ，第一次使用时会提示选择样式，这里不得不再夸一下 Zotero 极为丰富的样式库。例如我们标准格式是由 GB/T7714 规定的，点击添加，并在新弹出的对话框稍作搜索即可下载标准的引用样式，选择即可。以后需要修改样式时可以从 Edit → Preferences → Cite → Styles 重新设置。 文献引用样式设置 选择好样式之后，软件会自动调出题录数据库，选择题录并回车即可。默认视图下仅有一个搜索框可以根据文献的名字进行搜索，但也可选择经典视图打开题录数据库进行手动选择。 插入文献引用 使用 Zotero 插件进行文献引用时，不需要在意操作的先后顺序，Zotero 能够根据引文在文中出现的先后顺序自动对编号进行修改。当文章写完后，在 Word 点击 Zotero → Add/Edit Bibliography 即可自动生成参考文献列表，如下图所示。 生成参考文献列表 可以看出，文献引用的格式大体上是正确的，但是对多语言支持并不是很好，表现在英文文献作者较多时应当用\"et al\"，而不能用\"等\"。进一步，参考文献列表的字体与 Word 的使用有关，可能出现字体大小不对的情况，这都要求我们对参考文献进行手动修改。 手动修改文献列表前建议先对文档进行备份。从 Word 点击 Zotero → Unlink Citations ，断开参考文献列表与文献编号的关联（在 EndNote 中称之为格式化，这将使得新插入的参考文献重新从 1 开始编号，因此务必确认参考文献已经全部引用），这样就可以将参考文献列表变成文本，进行修改。 关于参考文献引用，$\\LaTeX$ 的 gbt7714 宏包 提供了非常好的多语言支持，这里稍微秀一下，相关用法可以参考 $\\LaTeX$ 的学习记录：自动化引用 。 LaTeX 的文献管理示意 ","date":"2020-06-20","objectID":"/zotero/:1:5","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#文献引用"},{"categories":["好用的软件"],"content":" 文档整理Zotero 自动下载的文献原文默认储存在其数据路径下，并以一些奇怪的文件夹名称进行归类，不利于文献的集中管理。为了将文献原文汇总到一个文件夹，可以使用 ZotFile 插件：它能够跟踪某个文件夹下新增的文件，并将该文件剪切到另一个文件夹，同时进行自定义格式的重命名。因此，我们需要告诉它 Zotero 的默认储存目录，然后让它将该文件夹下新增的文件（自动下载的文献原文）剪切到自定义的文件夹中。应当注意的是，这样做虽然能够完成文件的转移，但是会导致 Zotero 中打开题录附件时出现\"附件不存在\"的错误，因此还需要进一步将 Zotero 附件的默认位置改为 ZotFile 的目标文件夹。 ZotFile 插件配置 ","date":"2020-06-20","objectID":"/zotero/:1:6","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#文档整理"},{"categories":["好用的软件"],"content":" 数据同步注册并登录 Zotero 即可自动同步自身数据文件夹下的数据。根据 Zotero 同步规则 ，题录和笔记（Zotero 内置的笔记功能）内容不限空间，附件（主要是文献原文）仅提供 300M 免费空间。为了突破附件空间的限制，我们可以选择付费，也可以通过 WebDAV 来进行容量扩展。截止到这个文章最后修改，国内支持 WebDAV 功能的网盘只有坚果云。大家无须叹气，我保证坚果云和 Zotero 一样好用！ ","date":"2020-06-20","objectID":"/zotero/:1:7","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#数据同步"},{"categories":["好用的软件"],"content":" 其他小技巧 复制题录：直接鼠标拖拽即可 移动题录：按住 Shift 后用鼠标进行拖拽 查看题录所在收集箱：选中题录后长按 Alt (Linux) 或 Ctrl (Windows) ","date":"2020-06-20","objectID":"/zotero/:1:8","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#其他小技巧"},{"categories":["好用的软件"],"content":" 坚果云扩展同步功能坚果云 是一个面向协同合作的云盘，它支持自动同步和版本控制等功能。但是我决定不花精力写太多关于坚果云其他功能的介绍，除非坚果云能够把这一波广告费发给我，哼！ ","date":"2020-06-20","objectID":"/zotero/:2:0","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#坚果云扩展同步功能"},{"categories":["好用的软件"],"content":" 安装与使用从 坚果云官网 下载安装包后双击安装即可，注册账号之类的东西我想应该不必多少。对于个人用户，免费账户完全够用，并且值得称赞的是，坚果云没有广告！ 安装好坚果云之后，我们只需要右键某个文件夹选择坚果云同步即可，如此做，该文件下的文件都能自动同步到坚果云服务器，因此将这个文件夹成为同步文件夹。 与其他网盘不同的是，在联网状态下，坚果云同步文件夹的内容会实时更新以保持与服务器一致。可以将该文件夹共享给团队进行协同工作。协同工作时，为避免冲突，当一个人在修改某一文件时，该文件将会被锁定，其他人不可编辑。当由于网络延迟或断网使得多人编辑的同一文档出现冲突时，坚果云会有冲突提醒，并能够调用差异对比工具辅助进行冲突解决。 同步文件夹下的文件修改后会形成多个版本，用户可以随时提取之前的版本。因此，勒索病毒什么的完全就不用担心，因为同步到了云端，即使当前版本被加密，从云端重新下载最近的版本即可。也就是说，版本控制确保了损失的最小化。 坚果云文件历史 下面我们将重点回到使用坚果云扩展 Zotero 的同步功能，可以采用两种方法： WebDAV 同步和直接同步。 ","date":"2020-06-20","objectID":"/zotero/:2:1","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#安装与使用"},{"categories":["好用的软件"],"content":" 使用 WebDAV 同步 Zotero 附件坚果云提供了提供了 WebDAV 接口，那么我们就可以利用坚果云对数据进行同步。从网页进入坚果云的个人账户设置，在安全选项中的第三方软件管理可以看到坚果云服务器地址。点击添加应用，写好备注即可生成第三方接口的密码（有时候叫做授权码）。 坚果云 WebDAV 设置 然后打开 Zotero，点击 Edit → Preferences → Sync ，将文件同步选项改为 WebDAV，输入坚果云提供的服务器地址，用户账号和刚才生成的第三方接口密码即可。 Zotero 同步设置 我在 Zotero 配置坚果云服务器时添加了 /WebDAV ，这就创建了单独的文件夹以管理坚果云的 WebDAV 服务，以免与自己的其他文件混淆。在这种方案下，如果使用 ZotFile 将附件剪切到了其他文件夹，则无法同步附件。也就是说，这种方案配置简单，但是与 ZotFile 对文件集中管理的思路不太一致。 ","date":"2020-06-20","objectID":"/zotero/:2:2","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#使用-webdav-同步-zotero-附件"},{"categories":["好用的软件"],"content":" 结合 ZotFile 同步 Zotero 附件上面提到了 ZotFile 管理文献原文时将文献移动到了指定的文件夹，直接用坚果云同步这个文件夹不就可以了嘛：右键收录文献的文件夹，点击\"使用坚果云同步\"即可。 综上所述，如果你想图简单而不在意文献原文的汇总整理，那么就不需要使用 ZotFile 插件，直接采用坚果云 WebDAV 接口进行同步；如果你有一定的强迫症并愿意折腾，那么就可以使用 ZotFile 转移文献原文后用坚果云的同步文件夹进行同步。 ","date":"2020-06-20","objectID":"/zotero/:2:3","series":null,"tags":["Zotero","文献管理"],"title":"Zotero 文献管理","uri":"/zotero/#结合-zotfile-同步-zotero-附件"},{"categories":["好用的软件"],"content":"Git 是一个专业的版本控制软件，既可以管理个人文档，也可以进行团队协作。本文尽可能介绍概念性的原理以便理解，以供有需要的同学们快速查阅。 ","date":"2020-05-30","objectID":"/learngit/:0:0","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#"},{"categories":["好用的软件"],"content":" Git 基本概念所谓版本控制，实际上就是阶段性备份。习惯比较好的同学，在进行文档修改时会创建副本，这样，当修改后的版本不好，或者出错、误删，都可以用备份好的副本来继续工作，这就是最简单的版本控制。这种\"人肉\"版本控制的优点显然是简单，只要有好习惯就可以，不需要使用额外的工具。但是缺点也是显而易见的，一方面是随着修改次数的增加，副本会越来越多使得文件夹显得非常凌乱；另一方面，当需要以前的版本时，仅从副本的文件名很难获得足够的信息来精确定位所需的版本。为了更好地进行版本控制，Git 是一个非常不错的选择。 在使用 Git 之前首先介绍一些基本概念，或许会对理解 Git 的工作流程有所帮助。 ","date":"2020-05-30","objectID":"/learngit/:1:0","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#git-基本概念"},{"categories":["好用的软件"],"content":" 工作区、暂存区和版本库在正式介绍 Git 之前，首先简要说明三个相关的概念： 工作区：是能够看到的目录，例如 ~/LearnGit/ ； 暂存区：用于临时保存工作区的修改，一般不可见； 版本库：有时候也叫仓库，是工作目录下的 .git/ 隐藏文件夹，一般不可见。 工作区的文件被改动后，需要先提交到暂存区，暂存区所记录的修改通常需要提供一定的注释或说明才能提交到版本库。一旦文件提交到了版本库，Git 就会生成一个哈希值来标识当前版本。这种哈希值由40位16进制的字符组成，形如 78b6157cdbc031530c24b003fd72d283fab30d44 。通常情况下哈希值差异很大，在不引起矛盾的情况下，我们可以只使用哈希值的前几位来表示相应的版本。 文件提交到版本库后就可以为所欲为了，下面的一系列图片将会帮助理解 Git 的开发流程。 ","date":"2020-05-30","objectID":"/learngit/:1:1","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#工作区暂存区和版本库"},{"categories":["好用的软件"],"content":" 分支与开发流程假设工作过程中对文件进行了各种修改，并提交到仓库，提交历史将如下图所示： Git 提交历史示意图 其中，蓝色的方块代表一次提交，其值就是该提交的哈希值前几位。由于 Git 储存数据的方式，新的提交会指向旧的提交，因而也将较新的提交称为\"上游\"，对应将之前的提交称为\"下游\"，蓝色方块串起来的提交历史就是一个分支。图中标有 master 字样的黄色方块就是分支默认的名字，其实际上是一个指针，指向分支的最新提交。在 Git 中，一个分支就是一个指针，反过来，一个普通的指针就对应一个分支。标有 HEAD 字样的红色方块是一个特殊的指针，它只能指向分支，也就是说，它是指针的指针。HEAD 的位置决定了当前工作目录显示的是哪个提交，也决定了新的提交会在哪个分支。 注意 本文初稿形成时 Git 的默认分支名为 master ，这有一定的历史原因。新版本 Git 提倡使用 main 作为默认分支名，一方面其具有跟明确的含义，另一方面也避免 master/slave 这种略有侮辱性的词语。建议大家遵循新的约定。 为了进一步说明 HEAD 的影响，假设在 97bbf1b 位置出新建了一个名叫 dev 的指针，并让 HEAD 移动到 dev 的位置，如下图所示。 Git 分支切换 此时如果你观察工作目录，你会惊奇地发现\"穿越\"到了过去：工作目录的样子跟当时 97bbf1b 提交时候的样子一模一样，后面新的修改不见了、添加的文件不见了、删除的文件复活了。但是如果把 HEAD 分支重新移动到 master 的位置，工作空间又会变成 1e08a24 的样子，各种修改又回来了。可见，文件提交到版本库后不会丢失，而工作空间显示的文件结构由 HEAD 所指向的分支决定。 HEAD 还决定新的提交的位置。为了理解这个，可以打一个非常有意思的比方：把文件的提交，或者说仓库的向上游的扩展看作是修路，那么 master 就代表一个没有包工头的施工队，而 HEAD 就是包工头。包工头带领哪个施工队，工程就会在那个施工队的后面延续。而当有多个施工队时，其他的施工队就处于窝工状态。考察下面这种情况，当 HEAD 指向 dev 分支时，当修改的文件提交后，仓库是在 A 处延续还是在 B 处呢？ Git 提交的延拓 答案是在 B 处延续。进一步，由于产生了新的提交，而前面提到代表分支的指针指向最新的提交，又有 HEAD 指向分支的指针，我们就可以得到这样的结论：新的提交产生后，分支指针和 HEAD 指针将同时移动，指向最新的提交。例如在 dev 分支上又做了两次修改，整个历史将如下图所示： 不同分支上的提交 可以看到开发进程在 97bbf1b 处分叉，这也印证了\"分支\"名字的由来。 在不同分支上进行不同的修改，而后将修改以某种方式整合到主分支上，称之为分支的合并。例如，将上述 dev 分支的提交合并到 master 分支后，整个提交历史如下图所示： Git 分支合并 刚刚提到\"主分支\"，实际上 Git 中的分支都是平权的，不存在所谓的主分支，只是习惯上会将默认的 master 分支看作主分支。Git 的分支非常适合团队协作，例如，在 97bbf1b 处新建多个分支分配给团队的各个小组：dev 分支进行进一步开发、doc 分支进行帮助和说明文档的编写、debug 分支进行详细的调试等，一轮进行完成后合并到 master 分支，并由此重新生成各个分支进行下一轮开发。 下面简要介绍部分常用命令的使用，当然 Git 的使用不局限于命令行，已有很多的图形界面程序可以使 Git 操作通过点击鼠标完成，这里就不作推荐了。 ","date":"2020-05-30","objectID":"/learngit/:1:2","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#分支与开发流程"},{"categories":["好用的软件"],"content":" 使用示例对于 Windows 系统，从 Git 官方网站下载安装包之后，直接双击即可实现 Git 的安装，一路基本都采用默认设置即可。在安装过程中会出现下面这样选择默认编辑器的页面，由于默认的 vim 编辑器对新手不友好，可以根据习惯另外选择（可能需要另外安装）。 Windows 下 Git 的安装设置 安装完成后，在桌面或者资源浏览器内右键会有 Git Bash Here 的选项，我们打开它进行初始化设置。 初始化设置主要是设置用户名和邮箱，分别运行以下两个命令： bash git config --global user.name \u003cusername\u003e git config --global user.email \u003cemailaddress\u003e 其中 \u003c\u003e 内部的命令由用户自己指定，输入时不需要输入尖括号。后面再介绍命令使用时也将采用这种表述。 这两条命令运行后不会出现任何可见的效果，因为 Git 认为简单的最好，而最简单的莫过于什么都不显示了～ 为了使用 Git 进行版本控制，需要将工作目录进行初始化，在工作目录下右键点击 Git Bash Here ，输入如下命令即可： bash git init 将文件添加到暂存区、再将暂存区所记录的修改提交到版本库，依次使用以下命令（# 是 Git 的注释符）： bash git add \u003cfilename\u003e ## 将工作区修改到暂存区 git commit ## 将暂存区修改提交到版本库 若需要将工作目录下的所有修改或新增的文件添加到暂存区，可以使用 . 来代替所有的文件名。提交到版本库时， Git 会根据安装时设置的默认编辑器弹出编辑界面，在其中编写此次提交的备注，保存并关闭后即完成了 commit 命令。编写备注中， # 开头的行将作为注释忽略。一般情况下第一行简要说明此次修改的内容，空一行之后从第三行对此次修改进行详细说明，以便后期需要版本回退时精确定位回退的版本。 初始化仓库时会自从创建名为 master 的分支，若需要创建分支，可以使用这个命令： bash git branch \u003cbranchname\u003e [\u003chash\u003e] 上面的中括号表示可选参数，用于指定新分支所指向的提交（用哈希值表示），当留空时默认为当前所在的提交。 移动 HEAD 所指向的分支，可以使用 switch 命令，如下： bash git switch \u003cbranchname\u003e 将某分支合并到当前分支，采用如下命令： bash git merge \u003cbranchname\u003e 合并时，若某文件在两个分支不相同，Git 会提示存在冲突，并尝试进行差异对比。所有冲突解决之后会要求编写备注以产生新的提交。 使用时经常需要查看 Git 当前的状态，或者查看当前分支的整个开发历史，可以使用以下命令： bash git status ## 查看当前状态 git log ## 查看当前分支的历史提交 当历史太多又想掌握全部状态时，可以使用带参数的 log 命令，如本人常用以下命令查看整个仓库最近20次的提交： bash git log --all --oneline --graph --decorate -20 而为了简化这个命令，将整个命令取个别名： bash git config --global alias.logs 'log --all --oneline --graph --decorate -20' 以后就可以用 logs 这个别名查看 Git 最近20次提交的历史。 ","date":"2020-05-30","objectID":"/learngit/:2:0","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#使用示例"},{"categories":["好用的软件"],"content":" Git 其他技巧收集一些 Git 的使用技巧，看到了就随手记下来，或有用或没用，不定时更新。 ","date":"2020-05-30","objectID":"/learngit/:3:0","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#git-其他技巧"},{"categories":["好用的软件"],"content":" 清空历史提交随着提交越来越多，仓库体积也会越来越大。对于个人维护的项目，如果想要清理过去所有提交以减小仓库体积，可以使用下面这种 简单粗暴的方法 ： 创建孤立分支并将当前提交的文件检出到新分支：git checkout --orphan \u003cnewBranch\u003e 添加所有文件：git add . 提交更改：git commit 删除原分支：git branch -D master 重命名新分支：git branch -m master 强制提交到远程分支：git push -f origin master 警告 这种方法简单粗暴，会不可恢复地删除过往历史，在执行该操作前请做好备份。 ","date":"2020-05-30","objectID":"/learngit/:3:1","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#清空历史提交"},{"categories":["好用的软件"],"content":" 提取特定版本的文件可以采取下面的命令将特定版本中的某个文件提取出来，并写入到一个新文件中： bash git show \u003ccomment-id\u003e:\u003cfilename\u003e \u003e \u003cnewfilename\u003e ## 用法 git show 7926ba:spdoc.rst \u003e spdoc.temp.rst ## 示例 这种方法需要准确知道待提取的文件在对应版本下的名字。对文件夹内的文件，应当以相对路径的形式给出。 ","date":"2020-05-30","objectID":"/learngit/:3:2","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#提取特定版本的文件"},{"categories":["好用的软件"],"content":" 保存 HTTP 帐号密码如果使用 HTTP 的方式克隆仓库，在每次提交代码到远程仓库时都需要提供帐号和密码，这无疑是个繁琐的操作。为了将密码保存在本地，可以使用 储存凭证 的功能： bash git config --global credential.helper store ","date":"2020-05-30","objectID":"/learngit/:3:3","series":null,"tags":["Git","版本控制"],"title":"Git 版本控制","uri":"/learngit/#保存-http-帐号密码"},{"categories":["MATLAB"],"content":"理工科研究经常会涉及到各种公式推导，其中又难免涉及变量多、形式复杂的公式。这时可以使用 MATLAB 的符号计算工具包辅助完成。本文对此工具包进行简要介绍。 ","date":"2020-05-10","objectID":"/matlab-symbolic/:0:0","series":null,"tags":["MATLAB","符号计算"],"title":"MATLAB 符号计算","uri":"/matlab-symbolic/#"},{"categories":["MATLAB"],"content":" 定义符号变量在进行符号计算之前，需要提前定义符号变量，这可以通过函数 sym 和 syms 来完成。其中 syms 常用来批量定义符号变量，例如下面的第一行代码就同时定义了 $x$ 、 $y$ 、$z$ 三个符号变量，各符号变量之间用空格分开。 matlab syms x y z 利用 syms 所定义的符号变量，其变量名与符号相同。若想为符号另外指定变量名，可采用 sym 的方式，如： matlab w0 = sym('omega_0'); rs1 = sym('r_i_s'); rs2 = sym('r_i__i_s'); Vprms = sym('V_p_rms'); 在声明符号名时（单引号里边的字符串），下划线可以看作特殊的分隔符。单个下划线后面的字符表示下标，这与LaTeX相似，并且可以多次采用单下划线对下标进行分割，这会在最后导出LaTeX代码时自动插入逗号。类似地，若想为符号名加上标，可以连用两个下划线，其后的字符表示上标。例如上面所定义的四个符号变量分别代表以下符号： 符号变量 符号名 w0 $\\omega _{0}$ rs1 $r_{i,s}$ rs2 $r_{i,s}^{i}$ Vprms $V_{p,\\mathrm{rms}}$ 使用下划线为符号指定下标和上标时，上标或下标的声明顺序无关紧要，即无所谓先用连续下划线指定上标还是先用单下划线指定下标，甚至上下标交叉指定都不影响符号名。但分割指定多个上下标时，符号名下标的顺序与变量名声明时的顺序一致。例如上面 $r_{i,s}^{i}$ 的定义，下标先指定的是 $i$ ，因此符号名的下标中 $i$ 在前。这一点对一些表示相对关系的符号中至关重要。 除此之外， sym 还可以指定符号变量的维度，MATLAB会自动补充索引，如下： matlab r = sym('r',[1 3]); % r = [ r1, r2, r3 ] 一般情况下，MATLAB会自动地将符号名末尾的数字标识为下标，但也可以在定义变量名时候可以特殊地用 %d 显式指定索引出现的位置，如 matlab r1 = sym('r_%d',[1 3]); % 行向量，索引指定为下标 r2 = sym('r__%d',[1 3]); % 行向量，索引指定为上标 A = sym('A_%d__%d',[3 3]); % 矩阵，行列索引分别为下标和上标 定义完符号变量后，我们还可以使用 assume 命令对变量进行约束，例如我们可以对符号变量 x 进行如下设置 约束条件 命令 实数 assume(x,'real') 有理数 assume(x,'rational') 正数 assume(x,'positive') 正整数 assume(x,{'positive','integer'}) 小于 -1 或大于 1 assume(x\u003c-1 | x\u003e1) 2~10 之间的整数 assume(in(x,'integer') \u0026 x\u003e2 \u0026 x\u003c10) 不是整数 assume(~in(z,'integer')) 不为零 assume(x ~= 0) 偶数 assume(x/2,'integer') 奇数 assume((x-1)/2,'integer') 大于 0 且小于 $2\\pi$ assume(x\u003e0 \u0026 x\u003c2*pi) $\\pi$ 的整数倍 assume(x/pi,'integer') ","date":"2020-05-10","objectID":"/matlab-symbolic/:1:0","series":null,"tags":["MATLAB","符号计算"],"title":"MATLAB 符号计算","uri":"/matlab-symbolic/#定义符号变量"},{"categories":["MATLAB"],"content":" 符号计算示例我们以计算微分方程为例展示符号计算的一般步骤。假设待求解的微分方程为弹簧-质量-阻尼系统动力学方程： $$\\ddot x + 2 \\xi \\omega_0 \\dot x + \\omega_0^2 = sin(\\omega t)$$ 设初始位移为 $x_0$ ，初速度为 $v_0$ ，求解位移响应 $x(t)$ 。 我们可以采用以下代码： matlab % 定义符号变量 syms x(t) xi x0 v0 t ain = sym('a_in','real'); % 定义变量的同时引入约束 w = sym('omega','real'); w0 = sym('omega_0','real'); % 引入阻尼比约束 assume(x0,'real') assume(v0,'real') assume(xi\u003c1 \u0026 xi\u003e0) % 构造微分方程 dx = diff(x); % 需要单独定义一阶导数才能引入初速度约束 d2x = diff(x,2); eq = d2x + 2*xi*w0*dx + w0^2*x == ain; disp(eq) % 求解微分方程 S = dsolve(eq,[x(0)==0, dx(0)==v0]); S = simplify(S) 最后解得 $$ \\frac{a_{\\mathrm{in}}}{{\\omega _{0}}^2}-\\frac{a_{\\mathrm{in}}\\,{\\mathrm{e}}^{-\\omega _{0}\\,t\\,\\xi }\\,\\cos\\left(\\omega _{0}\\,t\\,\\sqrt{1-\\xi ^2}\\right)}{{\\omega _{0}}^2}-\\frac{{\\mathrm{e}}^{-\\omega _{0}\\,t\\,\\xi }\\,\\sin\\left(\\omega _{0}\\,t\\,\\sqrt{1-\\xi ^2}\\right)\\,\\left(a_{\\mathrm{in}}\\,\\xi -\\omega _{0}\\,v_{0}\\right)}{{\\omega _{0}}^2\\,\\sqrt{1-\\xi }\\,\\sqrt{\\xi +1}} $$ ","date":"2020-05-10","objectID":"/matlab-symbolic/:2:0","series":null,"tags":["MATLAB","符号计算"],"title":"MATLAB 符号计算","uri":"/matlab-symbolic/#符号计算示例"},{"categories":["MATLAB"],"content":" 输出计算结果如果采用 MATLAB 的实时脚本运行上面的代码，MATLAB 将会自动将公式转化为 $\\LaTeX$ 公式，如下图所示： 实时脚本下符号计算结果的渲染 更一般地，我们更希望将计算结果转化为 $\\LaTeX$ 代码，通过 MathType 或 $\\LaTeX$ 整合到文档中，这时可以使用 latex ，如： matlab \u003e\u003e latex(S) ans = '\\frac{a_{\\mathrm{in}}}{{\\omega _{0}}^2}-\\frac{a_{\\mathrm{in}}\\,{\\mathrm{e}}^{-\\omega _{0}\\,t\\,\\xi }\\,\\cos\\left(\\omega _{0}\\,t\\,\\sqrt{1-\\xi ^2}\\right)}{{\\omega _{0}}^2}-\\frac{{\\mathrm{e}}^{-\\omega _{0}\\,t\\,\\xi }\\,\\sin\\left(\\omega _{0}\\,t\\,\\sqrt{1-\\xi ^2}\\right)\\,\\left(a_{\\mathrm{in}}\\,\\xi -\\omega _{0}\\,v_{0}\\right)}{{\\omega _{0}}^2\\,\\sqrt{1-\\xi }\\,\\sqrt{\\xi +1}}' 如果大家仔细观察MATLAB转换的LaTeX代码，会发现它对希腊字母进行了识别和转换，对字符串下标也进行了识别并利用 \\mathrm{} 将其转化为正体。如果再仔细一些，自然对数的底 $\\mathrm{e}$ 也是正体。可见MATLAB对这种细节的处理非常到位。 生成的代码较长时，可以使用 clipboard 命令将结果直接复制到系统剪切板中： matlab texCode = latex(S); clipboard('copy',texCode) ","date":"2020-05-10","objectID":"/matlab-symbolic/:3:0","series":null,"tags":["MATLAB","符号计算"],"title":"MATLAB 符号计算","uri":"/matlab-symbolic/#输出计算结果"},{"categories":["MATLAB"],"content":"编写程序的时候会经常用到相似的代码片段，为了使代码整洁，可以将这些代码片段封装为函数使用。本文介绍 MATLAB 编写函数的一般方法。 ","date":"2020-04-29","objectID":"/matlab-function/:0:0","series":null,"tags":["MATLAB","函数"],"title":"MATLAB 编写函数","uri":"/matlab-function/#"},{"categories":["MATLAB"],"content":" 匿名函数匿名函数适用于一些简短操作的封装，常用于对一些较长的数学表达式进行封装。下面给出了定义匿名函数的一般方法。 matlab f = @(x) exp(-x.^2/2)/sqrt(2*pi); 可以看到，匿名函数的定义与 $y=f(x)$ 这种形式相似，我们只需要用 @ 和括号给定自变量，然后给出表达式，即可定义名为 f 的匿名函数。匿名函数必须在使用前进行定义。应当注意的是，有时为了向量化计算，在平方或乘除运算中通常采用加点的运算。 匿名函数还支持多元函数，这种情况下只需要在 @(x) 中增加变量即可，例如 @(x1,x2,x3) 。 在老版本中，与匿名函数非常相似的是内联函数，然而得知它在 MATLAB 以后的版本中将被移除，所以就不介绍了。 MATLAB 内联函数 ","date":"2020-04-29","objectID":"/matlab-function/:1:0","series":null,"tags":["MATLAB","函数"],"title":"MATLAB 编写函数","uri":"/matlab-function/#匿名函数"},{"categories":["MATLAB"],"content":" 自定义函数由于内联函数过于简单，且只在脚本内生效，即无法调用另一个独立脚本中定义的匿名函数。为了使函数能够进行更复杂的操作，且能够被多个脚本所调用，我们需要用 function 开头定义一个独立的 .m 文件。 函数的格式一般如下所示，例子中 \u003c\u003e 里边的内容仅为说明，不是代码。 matlab % 函数作用的简单说明 % 输入输出变量的基本说明 % 作者和修改日期 %% 主函数 function [y1,y2,y3] = simplefcn(x1,x2,x3) \u003c某些操作\u003e y1 = \u003c某变量\u003e; y2 = \u003c某变量\u003e; y3 = \u003c某变量\u003e; end 由于函数的通用性，共同工作的小伙伴们会经常分享一些好用的函数。因此，用 % 写好注释是一件非常重要的事情。MATLAB官方模板中将函数说明写在 function 紧接着的下一行，然而更实用的情况是写在文件的最前面，同时我们可以用 %% 对代码进行分节，使可读性更强。 注释是不参与代码计算的，因此上面这个例子中，函数真正开始于 function。然后分别给出输出、函数名和输入参数。当有多个输出时，只需用中括号和逗号构成输出向量即可。 函数编写完成后，将其另存为单独的m文件，这时需要文件名与函数名相同。在上面的例子中，对应的函数文件名为应当为 simplefcn.m 。 同各种其他编程一样，在未申明全局变量的情况下，函数体内的变量与函数外的变量相互独立。这就是说函数内的变量如果与脚本中的变量名字相同，他们并不会相互影响。同时，函数在计算结束后，其内部的变量都会在内存中清除，所以在函数内部计算过程中任何有用的变量都应当考虑将其输出。 有时候我们确实需要像函数一样封装一个较为复杂的代码，但是我们只需要这段代码对当前文件有用，其他文件无法对它进行调用。这时我们只需要将函数写在脚本的内部，更多情况下是写在脚本的末尾。一个简单的例子如下所示。 matlab % 脚本说明 % 作者和修改日期 %% 主代码 \u003c某些操作\u003e %% 子函数1 % 函数说明 % 变量说明 function y = subfcn1(x) \u003c某些操作\u003e y = \u003c某变量\u003e; end %% 子函数2 % 函数说明 % 变量说明 function y = subfcn2(x) \u003c某些操作\u003e y = \u003c某变量\u003e; end 同样地，建议将注释写完整并放在前面显眼的位置。例子中，subfcn1 和 subfcn2 是两个子函数，其只在脚本内有效。子函数不仅适用于脚本文件，在大型函数的定义中也可将一些小函数编写成子函数，从而提高代码的可读性。 注解 MATLAB 中函数文件以 function 开头的m文件，除此以外的m文件均可视为脚本。两者的不同之处在于函数可以有输入输出变量，且函数内的变量具有独立的变量空间。而脚本虽然能被其他脚本所调用，但不能提供输入参数，且脚本内的变量共享工作空间。例如两个脚本中都有 x 这个变量，那么 x 的值就会受两个脚本控制，有时会因为变量被覆盖而使计算与预期不符。这也是为什么建议将通用的算法写成函数而非脚本。 ","date":"2020-04-29","objectID":"/matlab-function/:2:0","series":null,"tags":["MATLAB","函数"],"title":"MATLAB 编写函数","uri":"/matlab-function/#自定义函数"},{"categories":["MATLAB"],"content":" 函数的重载从前面的介绍中可以看到，定义函数时需要给定输入、输出变量的数目，那么问题就来了：如果不确定有多少输入输出，允许函数内使用一定的默认值，或者当给定不同数量的输入、输出时函数进行不同的操作，要怎么做呢？可能有人会说，重新定义相应的函数就可以了。这确实是一种办法，但会使函数文件过多而显得冗余。这时就需要用到函数的重载。 在 MATLAB 中可利用关键字 varargin 作为输入，用 varargout 作为输出来代替可变数量的输入输出（variable-length input/output argument list）。同时，用 nargin 和 nargout 来获取输入和输出变量的数量。结合 if 或 switch 语句即可实现函数的重载。进一步，可使用函数 narginchk 和 nargoutchk 来限制输入输出变量的数量，但是这两个函数在较老的MATLAB版本中不存在。 这样一来，我们可以给出更加通用的函数定义模板： matlab % 函数说明 % 变量说明 % 作者和修改日期 %% 主函数 function varargout = fun(varargin) % 解析输入变量 switch nargin case 0 \u003c导入输入变量默认值\u003e case 1 \u003c变量1\u003e = varargin{1}; \u003c其他变量取默认值\u003e otherwise error('无效输入') end % 函数主体 \u003c某些操作\u003e % 解析输出变量 switch nargout \u003c定义不同数量输出时的操作\u003e end end %% 子函数1 % 函数说明 % 变量说明 function y = subfcn1(x) \u003c某些操作\u003e y = \u003c某变量\u003e; end %% 子函数2 % 函数说明 % 变量说明 function y = subfcn2(x) \u003c某些操作\u003e y = \u003c某变量\u003e; end 一般来说，主函数采用可变输入输出以增强通用性，而子函数由于只在文件内部有效，可采用简单的模式。上面以存在两个子函数的情况为例，实际使用时并不一定完全如此。 ","date":"2020-04-29","objectID":"/matlab-function/:3:0","series":null,"tags":["MATLAB","函数"],"title":"MATLAB 编写函数","uri":"/matlab-function/#函数的重载"},{"categories":["MATLAB"],"content":" 其他用法MATLAB 的函数中还有一些其他的\"高级\"用法，这里稍作提醒，有兴趣的伙伴们可以自行学习。 ","date":"2020-04-29","objectID":"/matlab-function/:4:0","series":null,"tags":["MATLAB","函数"],"title":"MATLAB 编写函数","uri":"/matlab-function/#其他用法"},{"categories":["MATLAB"],"content":" 从工作空间获取变量为了与函数内的变量进行交互，常用的方式是在函数内外采用 global 申明全局变量，从而实现参数传递。 如果仅仅想获取工作区变量而不对其进行操作的话，可采用 evalin 函数，例如，为了在函数内部获取工作区名为 x 变量的值，可使用以下代码： matlab x = evalin('base','x'); 这样就实现了在不定义全局变量时，从工作空间向函数内部单向传递参数的功能。应当注意，虽然函数内的变量名为 x，但由于不是全局变量，其与外部工作空间的 x 相互独立，除利用该函数传递数值外，互不干扰。 ","date":"2020-04-29","objectID":"/matlab-function/:4:1","series":null,"tags":["MATLAB","函数"],"title":"MATLAB 编写函数","uri":"/matlab-function/#从工作空间获取变量"},{"categories":["MATLAB"],"content":" 直接输出到工作空间与 evalin 类似但相反，assignin 能够将函数内的局部变量输出到工作空间。例如，将函数内计算的 x 输出到工作空间，并命名为 xout，相应的代码为 matlab assignin('base','xout',x) 危险 需要特别注意，这种方法会直接覆盖掉工作空间内的同名变量，因此不满足一般的编程规范。除非在特定情况下，否则不建议使用这个功能。 ","date":"2020-04-29","objectID":"/matlab-function/:4:2","series":null,"tags":["MATLAB","函数"],"title":"MATLAB 编写函数","uri":"/matlab-function/#直接输出到工作空间"},{"categories":["MATLAB"],"content":" 带参数的输入熟悉MATLAB的小伙伴或许知道有些函数可以像面向对象编程那样输入\"属性值\"，最经典的例子莫过于绘图函数的调用： matlab plot(x,y,'LineWidth',2,'LineStyle','--') 上面在调用绘图函数时还额外指定了线宽和线型。对于这样的输入，我们应当如何定义函数呢？ 有兴趣的小伙伴可以参考 MATLAB 解析输入参数。 ","date":"2020-04-29","objectID":"/matlab-function/:4:3","series":null,"tags":["MATLAB","函数"],"title":"MATLAB 编写函数","uri":"/matlab-function/#带参数的输入"},{"categories":["数字信号处理"],"content":"欧洲航空局（ESA）为LISA计划设计了完整的数据处理工具包 LTPDA，该工具包中内置一种对数频率点功率谱估计算法，即 LPSD 算法。本文介绍该算法的基本原理，并基于 MATLAB 进行复现。 ","date":"2019-02-23","objectID":"/lpsd/:0:0","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#"},{"categories":["数字信号处理"],"content":" 背景：常用功率谱估计算法功率谱估计是频域分析的一种常用手段，可用来检测信号中的单频信号或评估仪器的噪声本底等。常用的功率谱估计算法有周期图法（对应 MATLAB 函数为 periodogram）和 Welch 方法（pwelch）。对于采集系统收集到的数字信号，周期图法会对该数据进行加窗，然后利用快速傅里叶变换（FFT）将信号转化到频域 $$ X(k) = \\sum\\limits_{n = 0}^{N - 1} {x(n){e^{ - i\\frac{ {2\\pi} } {N}nk}}} $$ 然后利用 Wiener–Khinchin 定理即可获得功率谱 $$ S(k) = \\frac{2}{Nf_s}|X(k)|^2 $$ 式中，系数 $2$ 将双边谱转换到单边谱，这是因为负频率不具备实际的物理意义。 常用谱估计算法流程图 Welch 方法相对于周期图法增加了分段平均的思想，其将数据等分为多段，并且允许各段数据之间具有一定的重叠率以补偿窗函数引入的数据不平权的影响。对每段数据采用周期图法，最后将各段分别计算的功率谱进算数平均，获得最终的谱估计值。 周期图法和 Welch 法的谱估计结果示例 上图展示了周期图法和 Welch 方法对功率谱估计的结果。其中，蓝色曲线的周期图法一次性使用了全部的数据，因而有最高的频率分辨率，可以看到更低的频带。但是其高频部分的数据波动较大，且波动范围不会随着点数的增加而减小，即不满足所谓的一致性原则。橙色的 Welch 算法由于对数据进行了分段，直接进行 FFT 的数据相对较少，导致频率分辨率降低。但是分段平均使得高频波动的幅值大大减小，可以验证高频波动会随着分段次数的增加而进一步减小。 ","date":"2019-02-23","objectID":"/lpsd/:1:0","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#背景常用功率谱估计算法"},{"categories":["数字信号处理"],"content":" LPSD算法LPSD 算法的基本思想是采用对数分布的频率点，由于此时频率点的差值不是定值，即 DFT 的频率分辨率随频率点变化，因而在求取每个频率点对应的功率谱密度时应当对原始数据进行不同的分段。这就是说，LPSD 算法的每个频率点对应于不同分段次数下 Welch 算法中的相应点。 ","date":"2019-02-23","objectID":"/lpsd/:2:0","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#lpsd算法"},{"categories":["数字信号处理"],"content":" 对数频率的选取记采集到的离散数据为 $x(n),n=0,1,2…N-1$，采样率为 $f_s$。假设希望计算 $J_{\\rm des}$ 个点，其中第 $j$ 个点对应的频率为 $f(j)$、功率谱密度为 $P(j)$ 、频率分辨率为 $r(j)=f(j+1)-f(j)$。应当注意的是，这里的频率分辨率是指计算DFT的频率点之间的间隔，更一般的说法应当是栅栏效应。有限长数据的频率分辨率实际由 DTFT 定义，与数据的时间长度互为倒数，本文中称之为最小分辨率 $r_{\\rm min}$。在 LPSD 算法中不能采用 logspace 生成对数分布的频率点，因为数值计算的频率间隔不应当小于最小分辨率，否则这种计算是没有意义的。 对数频率的选取示意图 为了计算频率点，首先考察严格对数均匀的频率点应当满足 $$\\log f(j + 1) - \\log f(j) = C$$ 其中C为常数。频率范围受分辨率和采样率的影响，取 $$ \\begin{gathered} f(1) = {r_{\\rm min}} = \\frac{{{f_s}}}{N} \\\\ f({J_{\\rm des}}) = {f_{\\rm max}} = \\frac{{{f_s}}}{2} \\end{gathered} $$ 再令 $$g=\\log f_{\\rm max}- \\log r_{\\rm min}=\\log \\frac{N}{2}$$ 可以得到第 $j$ 个点的频率和频率分辨率分别为 $$ \\begin{gathered} f(j) = {r_{\\rm min}} \\times {10^{\\frac{{j - 1}}{{{J_{\\rm des}} - 1}}g}} \\\\ {r_0}(j) = f(j)({10^{\\frac{g}{{{J_{\\rm des}} - 1}}}} - 1) \\end{gathered} $$ 为了使低频段到高频段的频率分辨率变化较连续，对中频段对应的频率分辨率进行调整，为此，引入分段次数期望值 $K_{\\rm des}$（其典型值为100）。在分段重叠率为 $\\xi$ 时满足 $$({K_{\\rm des}} - 1)(1 - \\xi ){L_{\\rm avg}} + {L_{\\rm avg}} = N$$ 此时对应的频率分辨率为 $$r_{\\rm avg}=\\frac{f_s}{L_{\\rm avg}}=\\frac{f_s}{N}\\left[ (K_{\\rm des}-1)(1-\\xi) +1 \\right]$$ 根据分辨率限制和算法需求，我们需要对频率分辨率进行调整，如下 $$ r'(j) = \\left\\{ \\begin{array}{ll} {{r_0}(j)}\u0026 {r_0}(j) \\ge {r_{\\rm avg}} \\\\ {\\sqrt {{r_0}(j) \\cdot {r_{\\rm avg}}} }\u0026{r_0}(j) \u003c {r_{\\rm avg}}{\\text{ and }}\\sqrt {{r_0}(j) \\cdot {r_{\\rm avg}}} \u003e {r_{\\min }} \\\\ {{r_{\\rm min}}}\u0026\\text{else} \\end{array} \\right. $$ 除此之外，为了保证依据频率分辨率分段的数据长度为整数，频率分辨率还应当做进一步调整 $$ \\begin{gathered} L(j) = \\left\\lfloor {\\frac{{{f_s}}}{{r'(j)}}} \\right\\rfloor \\\\ r(j) = \\frac{{{f_s}}}{{L(j)}} \\end{gathered} $$ 其中，符号 $\\left\\lfloor \\right\\rfloor$ 表示向下取整。 综上所述，对数频率的选取算法为：以 $f(1)=r_{\\rm min}$ 为起点，根据频率和 $J_{\\rm des}$ 求解分辨率 $r_0(j)$ ，并根据要求对分辨率进行调整，得到 $r(j)$，接着利用 $f(j+1)=f(j)+r(j)$ 进行迭代。当计算的频率达到奈奎斯特频率即可停止迭代。值得注意的是，由于对频率分辨率进行了修正，获得的频率点并不是严格的对数分布，同时也会导致实际获得的频率点 $J$ 与期望的点数 $J_{\\rm des}$ 并不相等。 ","date":"2019-02-23","objectID":"/lpsd/:2:1","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#对数频率的选取"},{"categories":["数字信号处理"],"content":" 数据的分段处理对于第 $j$ 个频率点，由前可知其频率分辨率为 $r(j)$，分段后的每段数据长度为 $L(j)$。为了减小窗函数导致的数据不等权，允许分段之间存在一定的重叠率 $\\xi$，数据分段如下图所示。 数据分段示意图 由图可知，每段数据未重叠部分长度为 $$D(j) = (1 - \\xi ) \\cdot L(j)$$ 因而分段次数为 $$K(j) = \\left\\lfloor {\\frac{N - L(j)} {D(j) + 1} } \\right\\rfloor$$ 针对每段数据，我们可以选择利用 mean 函数求取数据平均值后予以扣除，或利用 detrend 函数直接去除数据中线性漂移。以扣除平均值为例，第 $j$ 个频率点的第 $k$ 段数据平均值为 $$a(j,k) = \\frac{1}{L(j)}\\sum\\limits_{l = 1}^{L(j)} {x\\left( {D(j) \\cdot (k - 1) + l} \\right)}$$ 将该段数据扣除平均值后，以相同长度的窗函数 $w(j,l)$ 对数据段进行加窗，得到预处理的数据段 $$ G(j,k,l) = \\left[ {x\\left( {D(j) \\cdot (k - 1) + l} \\right) - a(j,k)} \\right] \\cdot w(j,l) ,\\quad l = 1,\\,2,\\,3\\,...\\,L(j) $$ 然后对 $G(j,k,l)$ 进行离散傅里叶变换 $$A(j,k) = \\sum\\limits_{l = 1}^{L(j)} {G(j,k,l) \\cdot {e^{ - 2\\pi i\\frac{m(j)}{L(j)}l} } }$$ 应当注意的是 $G(j,k,l)$ 中 $j$ 表示频率点、 $k$ 表示分段、 $l$ 代表数据在分段内的位置，因此 $l$ 对应傅里叶变换的时间变量。严格来说，上式是离散傅里叶变换第 $m(j)$ 个点的值。其中 $$m(j)=\\frac{f(j)}{r(j)}$$ 在 FFT 算法中， $m(j)$ 应当是整数，而此处不一定满足该要求，故LPSD算法不能利用FFT进行加速，这是该算法耗时较长的原因之一。对 $m(j)$ 的具体讨论详见文献，此处不作赘述。 在进行以上操作后，我们得到了第 $j$ 个频率点对应的 $K(j)$ 段数据 DFT 的 $K(j)$ 个单点值，对这些值进行算数平均，根据Parseval等式可得谱密度为 $$P(j) = \\frac{C}{K(j)}\\sum\\limits_{k = 1}^{K(j)} { { {\\left| {A(j,k)} \\right|}^2} }$$ 其中 $C$ 为归一化系数，由下一节进行讨论。 ","date":"2019-02-23","objectID":"/lpsd/:2:2","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#数据的分段处理"},{"categories":["数字信号处理"],"content":" 功率谱的归一化功率谱的归一化系数与窗函数相关，而窗函数可根据不同需求进行不同的选择。对于任意窗函数 $w(j,l)$ ，做如下定义 $$ \\begin{gathered} {S_1}(j) = \\sum_{l = 1}^{L(j)} {w(j,l)} \\\\ {S_2}(j) = \\sum_{l = 1}^{L(j)} {{w^2}(j,l)} \\end{gathered} $$ 单边谱的归一化系数可按下式进行计算 $$ \\begin{gathered} {C_{\\rm PS}}(j) = \\frac{2}{{S_1^2(j)}} \\\\ {C_{\\rm PSD}}(j) = \\frac{2}{{{f_s} \\cdot {S_2}(j)}} \\end{gathered} $$ 其中， $C_{\\rm PS}$ 是功率谱的归一化系数，常用于单频信号的处理。由于绝大多数信号都均匀丰富的频率成分，我们更多地采用功率谱密度，其对于的归一化系数为 $C_{\\rm PSD}$ 。以电压为例，功率谱的单位是 ${\\rm V}^2$，而功率谱密度的单位是 ${\\rm V}^2/{\\rm Hz}$。在习惯上，我们所说的功率谱指的都是功率谱密度，且取其开方值，单位为 ${\\rm V}/\\sqrt{ {\\rm Hz} }$ 。 至此，我们依据实现的功率谱的求取，以 $f(j)$ 为横轴， $P(j)$ 为纵轴即可绘制功率谱。 ","date":"2019-02-23","objectID":"/lpsd/:2:3","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#功率谱的归一化"},{"categories":["数字信号处理"],"content":" 不同算法的对比依然以本文开头的数据为例，周期图法、Welch 方法以及 LPSD 算法得到的功率谱如下图所示。 不同谱估计算法对比 可见，LPSD 算法在低频出有更高的频率分辨率，在高频对谱密度的估计更准确，兼顾了周期图法和 Welch 方法的优点。然而 LPSD 算法牺牲了数值计算的速度，在一次利用400万个数据做谱的测试中，各算法的耗时如下。其中 iParLPSD 是利用了 MATLAB 并行工具包计算的 LPSD 算法。 不同谱估计算法用时对比 ","date":"2019-02-23","objectID":"/lpsd/:3:0","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#不同算法的对比"},{"categories":["数字信号处理"],"content":" 参考文献 Michael Tröbs, Gerhard Heinzel. Improved spectrum estimation from digitized time series on a logarithmic frequency axis. Measurement. 2005. ","date":"2019-02-23","objectID":"/lpsd/:4:0","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#参考文献"},{"categories":["数字信号处理"],"content":" MATLAB 源码 matlab % Use LPSD mothod to calculate power spectral density % Usage: % h = iLPSD(data,fs,_) % [pxx,f] = iLPSD(data,fs,_) % Required paramters: % data --- input data, processed by column % fs --- sample frequency, unit: Hz % Optional paramters: % Jdes --- desired frequency points, default: 1000 % Kdes --- desired number of segments, default: 100 % xi --- overlap ratio, default: 0.5 % win --- window function handle, default: @hann % par --- enable parallel compution, default: false % type --- type of the sepctrum: PSD|RMS|Amp, default: PSD % Extra paramters to control plotting are allowed (e.g. 'LineWidth') % Output paramters % h --- line handle of the plotted PSD % pxx --- [PSD] one-sided PSD, unit: *^2/Hz % [RMS| Amp] RMS or amplitude, unit: * % f --- frequency points related to PSD points, unit: Hz % % Ref: Improved spectrum estimation from digitized time series on a logarithmic frequency axis % Article DOI: 10.1016/j.measurement.2005.10.010 % % For more information, see \u003ca href=\"https://ichunyu.github.io/helps/functions/ilpsd\" % \u003eonline documentation\u003c/a\u003e. % XiaoCY 2019-02-23, first version (date from PPT report) % XiaoCY 2020-04-21, support matrix data: treated as columns % XiaoCY 2021-11-06, add inputParser to parse parameters % XiaoCY 2022-03-28, add parameters: 'parallel', 'type' % XiaoCY 2022-05-08, bug fix: window function in parallel mode %% Main function varargout = iLPSD(varargin) % parse input paramters p = inputParser; p.FunctionName = 'iLPSD'; p.KeepUnmatched = true; p.addRequired('data'); p.addRequired('fs'); p.addParameter('Jdes',1000); p.addParameter('Kdes',100); p.addParameter('xi',0.5); p.addParameter('window',@hann); p.addParameter('parallel',false); p.addParameter('type','PSD'); p.parse(varargin{:}); % unpack necessary parameters data = p.Results.data; fs = p.Results.fs; Jdes = p.Results.Jdes; Kdes = p.Results.Kdes; xi = p.Results.xi; win = p.Results.window; type = validatestring(p.Results.type,{'PSD','RMS','Amp'}); opts = p.Unmatched; % ensure input data as column vector(s) [N,nCol] = size(data); if N==1 \u0026\u0026 nCol~=1 data = data'; N = nCol; nCol = 1; end [f,L,m] = getFreqs(N,fs,Jdes,Kdes,xi); J = length(f); P = zeros(J,nCol); if p.Results.parallel parfor j = 1:J Dj = floor((1-xi)*L(j)); Kj = floor((N-L(j))/Dj+1); w = win(L(j)); l = (0:L(j)-1)'; W1 = cos(-2*pi*m(j)/L(j).*l); W2 = sin(-2*pi*m(j)/L(j).*l); A = zeros(1,nCol); for k = 0:Kj-1 G = data(k*Dj+1:k*Dj+L(j),:); G = G-mean(G); % G = detrend(G); G = G.*w; A = A + sum(G.*W1).^2+sum(G.*W2).^2; end switch type case 'PSD' P(j,:) = A/Kj*(2/fs/sum(w.^2)); case 'RMS' P(j,:) = A/Kj*(2/sum(w)^2); otherwise P(j,:) = 2*A/Kj*(2/sum(w)^2); end end else for j = 1:J Dj = floor((1-xi)*L(j)); Kj = floor((N-L(j))/Dj+1); w = win(L(j)); l = (0:L(j)-1)'; W1 = cos(-2*pi*m(j)/L(j).*l); W2 = sin(-2*pi*m(j)/L(j).*l); A = zeros(1,nCol); for k = 0:Kj-1 G = data(k*Dj+1:k*Dj+L(j),:); G = G-mean(G); % G = detrend(G); G = G.*w; A = A + sum(G.*W1).^2+sum(G.*W2).^2; end switch type case 'PSD' P(j,:) = A/Kj*(2/fs/sum(w.^2)); case 'RMS' P(j,:) = A/Kj*(2/sum(w)^2); otherwise P(j,:) = 2*A/Kj*(2/sum(w)^2); end end end switch nargout case 0 loglog(f,sqrt(P),opts); grid on xlabel('Frequency [Hz]','interpreter','latex') switch type case 'PSD' ylabel('PSD [$\\mathrm{*/\\sqrt{Hz}}$]','interpreter','latex') case 'RMS' ylabel('RMS [$\\mathrm{*}$]','interpreter','latex') otherwise ylabel('Amp [$\\mathrm{*}$]','interpreter','latex') end case 1 varargout{1} = loglog(f,sqrt(P),opts); grid on xlabel('Frequency [Hz]','interpreter','latex') switch type case 'PSD' ylabel('PSD [$\\mathrm{*/\\sqrt{Hz}}$]','interpreter','latex') case 'RMS' ylabel('RMS [$\\mathrm{*}$]','interpreter','latex') otherwise ylabel('Amp [$\\mathrm{*}$]','interpreter','latex') end case 2 if strcmp(type,'PSD') varargout{1} = P; else varargout{1} = sqrt(P); end varargout{2} = f; otherwise % Do Nothing end end %% Subfunctions % get logarithmic frequency points function [f,L,m] = getFreqs(N,fs,Jdes,Kdes,xi) fmin = fs/N; fmax = fs/2; r_","date":"2019-02-23","objectID":"/lpsd/:5:0","series":null,"tags":["功率谱","LPSD"],"title":"LPSD 功率谱估计","uri":"/lpsd/#matlab-源码"}]